'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/datas_tructure/%E5%85%A5%E9%97%A8/','title':"入门",'content':"数据结构入门  什么是数据结构 数据结构到底学什么 逻辑结构和物理结构 如何衡量一个算法的好坏  "});index.add({'id':1,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/','title':"1.词类",'content':"1.词类 1.1. 名词\n表人、事物、地点、或抽象概念的名称. 1.2. 代词\n用来代替名词 1.3. 形容词\n表人或事物的性质或特征\n1.4. 数词\n表数目或顺序 1.5. 动词\n表动作或状态 1.6. 副词\n修饰动词、形容词或副词\n说明时间，地点，程度等 1.7. 冠词\n用在名词前,帮助说明名词 1.8. 介词\n表示它后面的名词或代词与其他句子成分的关系 1.9. 连词\n用来连接词、短语或句子 1.10. 感叹词\n表示喜、怒、哀、乐等感情\n"});index.add({'id':2,'href':'/docs/english/2.%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/','title':"2.句子成分",'content':"2.句子成分 2.1.主语\n 是句子所要说的人或物,回答是\u0026quot;谁\u0026quot;或者\u0026quot;什么\u0026rdquo; 通常用名词或代词担任  2.2.谓语\n 说明主语的动作或状态,回答\u0026quot;做(什么)\u0026rdquo; 由动词\u0026amp;动词短语担任  2.3.表语\n 在系动词后,说明主语的身份或特征,回答是\u0026quot;什么\u0026quot;或者\u0026quot;怎么样\u0026rdquo; 由名词、代词或形容词担任  系动词由: be、感官动词 组成\n2.4.宾语\n 表及物动词的对象或结果 由名词或代词担任  2.5.双宾\n 有些及物动词带有两个宾语,一个指物，一个指人 指物的叫直接宾语，指人的叫间接宾语 间接宾语一般放在直接宾语的前面  注意:\n可把介词to或for加在间接宾语前构成短语, 放在直接宾语后面，来强调简介宾语\nHe wrote a letter to me\n2.6.定语\n 修饰名词或代词 能做定语的:  形容词 介词短语 动词ing 动词ed 动词todo 从句 2.7.状语\n 修饰动词、形容词、副词 能做状语的:  副词 介词短语 动词ing 动词ed 动词todo 从句 注: 有被修饰的名词，是定语，否则是状语\n2.8.宾语补足语\n 用来说明宾语怎么样或干什么 由形容词或动词充当  双宾\u0026amp;宾补\n动词 1 2 如果1 2 都能被改成被动语态的主语，是双宾，否则是宾补\n2.9.同位语\n跟在名词、代词后面，进一步说明它的情况\n"});index.add({'id':3,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/','title':"1.入门基础",'content':"入门基础  1.1.本地创建一个Git仓库 1.2.使用Git命令下载远程仓库到本地 1.3.如何把修改后的代码提交到远程仓库 1.4.使用diff查看修改了哪些代码 1.5.解决提示文件权限被修改问题 1.6.忽略指定文件或目录  "});index.add({'id':4,'href':'/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/','title':"1.开发环境",'content':"1.开发环境  1.1.安装 1.2.国内镜像配置 1.3.依赖管理  "});index.add({'id':5,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/','title':"2.1.变量和常量",'content':"2.1.变量和常量  2.1.1. 标识符与关键字 2.1.2. 变量 2.1.3. 常量  "});index.add({'id':6,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/','title':"常用",'content':"常用的操作  字符串操作 数组操作 切片操作 MAP操作 结构体操作  "});index.add({'id':7,'href':'/docs/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/','title':"常用命令",'content':"常用命令  命令基本格式 文件处理命令 文件搜索命令 帮助命令 压缩与解压缩命令 关机和重启命令 其他常用命令  "});index.add({'id':8,'href':'/docs/linux/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/','title':"文件系统",'content':"文件系统 FHS规范(3.0)  约定俗成的目录规范 定义/目录及其一级子目录  /etc 配置文件 /bin 必要命令 /usr 二级目录 /home 家目录 /var 动态数据 文件系统VFS "});index.add({'id':9,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/','title':"网络管理",'content':"网络管理  网络基础 网络配置 网络命令 远程登录  "});index.add({'id':10,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/','title':"软件安装管理",'content':"软件安装管理 "});index.add({'id':11,'href':'/docs/mysql/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/','title':"入门指南",'content':"入门指南  环境搭建  "});index.add({'id':12,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/','title':"进阶语言特性",'content':"进阶语言特性  字符串 列表vs元组 字典vs集合 迭代器和生成器 生成器表达式和列表生成式 函数进阶 函数式编程 入手装饰器 其它常用语言特性  "});index.add({'id':13,'href':'/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/','title':"入门指南",'content':"入门指南  环境搭建  "});index.add({'id':14,'href':'/docs/suanfa/3.%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E8%B7%B3%E8%A1%A8/','title':"3.数组链表跳表",'content':"数组链表跳表 "});index.add({'id':15,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E7%BA%BF%E6%80%A7%E8%A1%A8/','title':"1.线性表",'content':"线性表 "});index.add({'id':16,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/','title':"数据结构",'content':"数据结构 "});index.add({'id':17,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/','title':"常用数据结构",'content':"常用数据结构  1.数组与字符串 2.链表 3.栈 4.队列 5.双端队列 6.树  "});index.add({'id':18,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/','title':"高级数据结构",'content':"高级数据结构  1.优先队列 2.图 3.前缀树 4.线段树 5.树状数组  "});index.add({'id':19,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/','title':"算法",'content':"算法 "});index.add({'id':20,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml%E5%9B%BE/','title':"Uml图",'content':"UML图 "});index.add({'id':21,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88/','title':"1.数据结构与算法总览",'content':"1.数据结构与算法总览 精通一个领域  切碎知识点 刻意练习 反馈  数据结构   一维:\n 基础: 数组(array)、(string)、链表(linked list) 高级: 栈(stack)、队列(queue)、双端队列(deque)、集合(set)、映射(hash or map)    二维:\n 基础: 树(tree)、图(graph) 高级: 二叉搜索树 (red-black tree, AVL)    特殊:\n 位运算、布隆过滤器 LRU cache    算法  if-else switch -\u0026gt; branch for while loop -\u0026gt; iteration 递归 Recursion (Divide \u0026amp; Conquer Backtrace) 搜索Search: 深度优先搜索 Depth first search, 广度优先搜索 Breadth first search 动态规划 Dynamic Programming 二分查找 Binary Search 贪心 Greedy 数学 Math, 几何 Geometry  切题四件套  Clarification 澄清 possible solutions 可能的解决办法  compare (time/space) 比较(时间/空间) optimal (加强)   Coding (多写) Test cases (测试用例)  刷题方法:  第一遍  5分钟: 读题 + 思考 直接看解法: 注意! 多解法, 比较解法优劣 背诵、默写好的解法   第二遍  马上自己写 -\u0026gt; leetCode 提交 多种解法比较、体会 -\u0026gt; 优化!   第三遍  过了一天后, 在重复做题 不同解法的熟练程度 -\u0026gt; 专项练习   第四遍  过了一周: 反复回来练习相同题目   第五遍  面试前一周恢复性训练    脑图  数据结构脑图 http://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c 算法脑图 http://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec  "});index.add({'id':22,'href':'/docs/java/1.1.java%E5%88%9D%E4%BD%93%E9%AA%8C/1.1.1.java%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E7%89%88%E6%9C%AC/','title':"1.1.1 java的特性与版本",'content':"1.2.1 关键字 java的特性 开源、跨平台\njava的版本 j2se 1.8\n"});index.add({'id':23,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.1.%E5%90%8D%E8%AF%8D/','title':"1.1.名词",'content':"1.1.名词 1️⃣ 名词分类 1.1.1.专有名词  专有名词是个别的人、地、物、团体、机构等的专用名称 专有名词中实词的第一个字母要大写\nBeijing, Tom, the People\u0026rsquo;s Republic of China 专有名词如含有普通名词的短语,必须用定冠词the the Great Wall 长城 姓氏名采用复数形式\nthe Greens 格林一家人  1.1.2.普通名词  普通名词: 是许多人或事物的共有名称 pupil, family, man, foot  1.2.1.可数名词  可数名词是可以用数词进行计算的名词  box, child, orange\n1.2.2.不可数名词  不可数名词是不可以数词进行计数的名词  water, news, oil\n2️⃣ 单数-复数 规则  +s map-\u0026gt;maps, boy-\u0026gt;bodys, horse-\u0026gt;horses, table-\u0026gt;tables s, o, x, sh, ch 结尾的词加es class-\u0026gt;classes, box-\u0026gt;boxes, hero-\u0026gt;heroes, dish-\u0026gt;dishes bench-\u0026gt;benches\n【注】:少数以o结尾的词,变复数时只加s photo-\u0026gt;photos, piano-\u0026gt;pianos 以辅音字母加y结尾的名词,变y为i,再加es family-\u0026gt;families, city-\u0026gt;cities, party-\u0026gt;parties 以f或fe结尾的名词,变f或fe为v,再加es shelf-\u0026gt;shelves, wolf-\u0026gt;wolves, life-\u0026gt;lives, knife-\u0026gt;knives  不规则 man-\u0026gt;men\nwoman-\u0026gt;women\nsheep-\u0026gt;sheep\ntooth-\u0026gt;teeth\n 不可数名词一般没有复数形式,说明其数量时,要用有关计量名词 a bag of rice -\u0026gt; two bags of rice\na piece of paper -\u0026gt; three pieces of paper\na bottle of milk -\u0026gt; five bootles of milk  3️⃣ 名词所有格 含义: 表示所属关系,相当于物主代词; 在句中做定义、宾语或主语\n 表示人或其它有声明的东西的名词常在词尾加\u0026rsquo;s\nChildren\u0026rsquo;s Day 儿童节 以s或es结尾的复数名词.只在词尾加\u0026rsquo;\nTeachers\u0026rsquo; Day 教师节 the cimate in sy is colder than other \u0026lsquo;s cities 有些表示时间、距离以及世界、国家、城镇等无声明的名词,在词尾加\u0026rsquo;s\ntoday\u0026rsquo;s newspaper 今天的报纸 无论表示有生命韩式无生命的东西的名词,一般均可以用介词of短语来表示所有关系\na fine dauthter of the Party 党的好女儿 \u0026lsquo;s还可以表示某人的家或者某个店铺\nmy aunt\u0026rsquo;s 我阿姨家\nthe doctor\u0026rsquo;s 诊所 两个共有某物时,可以采用A and B\u0026rsquo;s的形式\nLucy and Lily\u0026rsquo;s bedroom 双重所有格: \u0026ldquo;of + 名词所有格/名词性物主代词\u0026rdquo;\na friend of my father\u0026rsquo;s 我父亲的一位朋友\na friend of mine 我的一位朋友  4️⃣ 主谓一致   主语是可数名词单数或不可数名词，谓语动词用单数形式\nThe computer was a great invention 计算机是个了不起的发明\nThe water in the glass is very cold 玻璃杯里的水很冷\n  集体名词做主语\n 表示整体概念 谓语用单数形式\nClass Three is a very good class 三班是好班 表示其中的所有成员,谓语用复数形式\nClass Three have a map of China 三班有张中国地图 Chinese, Japanese, fish, sheep, people等表示单个时谓语用单数,表示许多时,谓语用复数\nThere is a sheep in the yard 院子里有只绵羊\nThere are some sheep in the yard 院子里有一些绵羊 有s结尾,但不是复数,谓语动词用单数\nThe news is very exciting 这个消息令人兴奋 glasses, shoes, socks, trousers, gloves 等名词常用复数形式, 谓语用复数\nThe trousers are very cheap and i want to take them 裤子很便宜，我想买 a lot of 跟名词复数时谓语用单数形式，跟不可数名词时谓语用单数形式\nA lot of students are playing baseball now A lot of time was wasted on that work and 连接两个名词做主语时,谓语多用复数；但两个名词构成一个整体食物时，谓语则用单数\nThe teacher and his son are picking apples now\nFish and chips is very famous food there be 就近原则\nThere is a table and four chairs in the room 用both\u0026hellip;and\u0026hellip;连接两个事物做主语时,谓语一般用复数\nBoth you and i are required to be here tomorrow 主语中有with的短语时,谓语单复数由with之前的人物决定\na woman with a 7-year-old child was standing at the side of the road either\u0026hellip;or\u0026hellip;或者neither\u0026hellip;nor\u0026hellip;连接两个人物做句子主语时,谓语就近原则\nEither you or he is right\nNeither you nor i am going there 表示一段时间或长度概念的复数名词做主语时,谓语一般用单数\nTwo months is not a short tim\nTwo thousand kilomenters is quite a long distance 主语中含有half of \u0026hellip;/ (three quarters) of \u0026hellip; / all (of) the \u0026hellip;等词语时,谓语的单复数由名词确定\nOver three quarters of the information on the Internet is in English 补充: 主谓一致 \u0026ldquo;就近原则\u0026rdquo;  there be neither ... nor either ... or not only ... but also not ... but  补充: 主谓一致 \u0026ldquo;就远原则\u0026rdquo;  as well as; (together/along) with; rather than; except; besides; but; including; in addition to; apart from The president of the college， together with the deans， is planning a conference for the purpose of laying down certain regulations   5️⃣ 单复数意义不同的名词  "});index.add({'id':24,'href':'/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.1.%E5%AE%89%E8%A3%85/','title':"1.1.安装",'content':"1.1.安装 linux 下安装  wget https://dl.google.com/go/go1.x.x.linux-amd64.tar.gz 下载安装包 tar -C /usr/local -zxvf go1.x.x.linux-amd64.tar.gz 添加/usr/loacl/go/bin目录到PATH变量中。添加到/etc/profile 或$HOME/.profile都可以  vim /etc/profile export GOROOT=/usr/local/go #设置为go安装的路径,有些安装包会自动设置默认的goroot export GOPATH=/usr/local/goprojects/ #GO项目路径多个用\u0026rsquo;,\u0026lsquo;分开 export PATH=$PATH:$GOROOT/bin:$GOPATH/bin #加载 source /etc/profile   执行go version，如果现实版本号，则Go环境安装成功.  "});index.add({'id':25,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.1.%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgit%E4%BB%93%E5%BA%93/','title':"1.1.本地创建一个Git仓库",'content':"1.1.本地创建一个Git仓库 ~ mkdir test ~ cd test ~/test git init 已初始化空的 Git 仓库于 /Users/ruichengm/test/.git/ ~/test(master) ls -al total 0 drwxr-xr-x 3 ruichengm staff 96 7 18 08:46 . drwxr-xr-x+ 107 ruichengm staff 3424 7 18 08:47 .. drwxr-xr-x 9 ruichengm staff 288 7 18 08:46 .git 认识.git ➜ .git git:(master) ls -al total 24 drwxr-xr-x 10 song staff 320 6 25 22:11 . drwxr-xr-x 3 song staff 96 6 25 22:11 .. -rw-r--r-- 1 song staff 23 6 25 22:11 HEAD drwxr-xr-x 2 song staff 64 6 25 22:11 branches -rw-r--r-- 1 song staff 137 6 25 22:11 config -rw-r--r-- 1 song staff 73 6 25 22:11 description drwxr-xr-x 13 song staff 416 6 25 22:11 hooks drwxr-xr-x 3 song staff 96 6 25 22:11 info drwxr-xr-x 4 song staff 128 6 25 22:11 objects drwxr-xr-x 4 song staff 128 6 25 22:11 refs 文件夹的作用\n HEAD 文件指示目前被检出的分支 branches 新版本已经废弃无须理会 description 用来显示对仓库的描述信息 config 文件包含项目特有的配置选项 info 目录包含一个全局性排除文件 hooks 目录包含客户端或服务端的钩子脚本 index 文件保存暂存区信息 objects 目录存储所有数据内容 refs 目录存储分支的提交对象的指针  基础配置 配置名称 git config user.name #查看 git config --global user.name \u0026quot;你的昵称\u0026quot; #修改 配置邮箱 git config user.email #查看 git config --global user.email \u0026quot;你的邮箱\u0026quot; #修改 命令行修改配置 git config --global --replace-all user.name \u0026quot;your user name\u0026quot; git config --global --replace-all user.email\u0026quot;your user email\u0026quot; 修改配置文件 修改文件的方式，主要是修改位于主目录下.gitconfig 文件，可以看到如下配置：\n[user] name = daxia email = 78778443@qq.com git config –list可以查看是否修改成功了\n"});index.add({'id':26,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.1.%E7%BA%BF%E6%80%A7%E8%A1%A8/','title':"1.1.线性表",'content':"1.1.线性表 1.1.1 线性表的定义和特点  1.1.2 "});index.add({'id':27,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.1.%E5%85%B3%E9%94%AE%E5%AD%97/','title':"1.2.1 关键字",'content':"1.2.1 关键字 Java 中常用关键字：\n Java 关键字是区分大小写的哦！所以 void 是关键字，但 Void 就不是了~~\n"});index.add({'id':28,'href':'/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.1.if/','title':"1.4.1 if",'content':"1.4.1 if if  if else  多重if  嵌套if  "});index.add({'id':29,'href':'/docs/java/1.5.%E6%95%B0%E7%BB%84/1.5.1.%E6%95%B0%E7%BB%84/','title':"1.5.1.数组",'content':"1.5.1 数组  声明数组 语法： 数据类型[ ] 数组名；\n或者 数据类型 数组名[ ]；\n 分配空间 语法： 数组名 = new 数据类型 [ 数组长度 ];\n 话说，我们也可以将上面的两个步骤合并，在声明数组的同时为它分配空间，如：\n 赋值 分配空间后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 scores 数组中存放学生成绩\nscores[0] = 89; 处理数组中数据 在 Java 中还提供了另外一种直接创建数组的方式，它将声明数组、分配空间和赋值合并完成，如  等价于:  使用循环操作 Java 中的数组   其中， 数组名.length 用于获取数组的长度\n"});index.add({'id':30,'href':'/docs/docker/1.docker%E5%AE%89%E8%A3%85/','title':"1.Docker安装",'content':"1.Docker安装 1.1 安装  yum包更新到最新  yum update  安装需要的软件包, yum-util提供yum-config-manager功能,另外两个是devicemapper驱动依赖的  yum install -y yum-utils device-mapper-persistent-data lvm2  设置yum源为阿里云  yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  安装docker  yum -y install docker-ce  安装后查看docker版本  docker -v 1.2 设置ustc的镜像 ustc是老牌的linux镜像服务提供者了, ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是 不需要注册,是真正的公共服务.\n编辑该文件\nmkdir -p /etc/docker vi /etc/docker/daemon.json 在该文件中输入如下内容\n{ \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://docker.mirrors.ustc.edu.cn\u0026quot;] } 1.3 Docker的启动与停止 启动docker:\nsystemctl start docker 查看docker状态:\nsystemctl status docker 查看docker信息\ndocker info 停止docker\nsystemctl stop docker docker帮助信息\ndocker --help docker重启\nsystemctl restart docker "});index.add({'id':31,'href':'/docs/kafka/1.kafka%E6%A6%82%E8%BF%B0/','title':"1.kafka概述",'content':"1.kafka概述 定义 kafka 是一个分布式的基于发布/订阅模式的消息队列, 主要应用于大数据实时处理领域\n消息队列的作用 削峰、解耦\n消息队列的两种模式 点对点模式、发布/订阅模式 发布/订阅模式:分为消息队列主动推，消费者主动拉，这2种模式， kafka属于后种(但是这种有个缺点需要客户端维护轮训)\nkafka基础架构 "});index.add({'id':32,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/','title':"1.优先队列",'content':"1.优先队列 特点 能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是自定义的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。\n应用场景 从一堆杂乱无章的数据当中按照一定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据。\n举例：任意一个数组，找出前 k 大的数。 解法 1：先对这个数组进行排序，然后依次输出前 k 大的数，复杂度将会是 O(nlogn)，其中，n 是数组的元素个数。这是一种直接的办法。\n解法 2：使用优先队列，复杂度优化成 O(k + nlogk)。\n当数据量很大（即 n 很大），而 k 相对较小的时候，显然，利用优先队列能有效地降低算法复杂度。因为要找出前 k 大的数，并不需要对所有的数进行排序。\n实现 优先队列的本质是一个二叉堆结构。堆在英文里叫 Binary Heap，它是利用一个数组结构来实现的完全二叉树。换句话说，优先队列的本质是一个数组，数组里的每个元素既有可能是其他元素的父节点，也有可能是其他元素的子节点，而且，每个父节点只能有两个子节点，很像一棵二叉树的结构。\n牢记下面优先队列有三个重要的性质。  1.数组里的第一个元素 array[0] 拥有最高的优先级别。 2.给定一个下标 i，那么对于元素 array[i] 而言：  它的父节点所对应的元素下标是 (i-1)/2 它的左孩子所对应的元素下标是 2×i + 1 它的右孩子所对应的元素下标是 2×i + 2   3.数组里每个元素的优先级别都要高于它两个孩子的优先级别。  优先队列最基本的操作有两个。  1.向上筛选（sift up / bubble up）  当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。 不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止。  时间复杂度：由于二叉堆是一棵完全二叉树，并假设堆的大小为 k，因此整个过程其实就是沿着树的高度往上爬，所以只需要 O(logk) 的时间。   2.向下筛选（sift down / bubble down）  当堆顶的元素被取出时，要更新堆顶的元素来作为下一次按照优先级顺序被取出的对象，需要将堆底部的元素放置到堆顶，然后不断地对它执行向下筛选的操作。 将该元素和它的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，直到无法继续交换为止。  时间复杂度：整个过程就是沿着树的高度往下爬，所以时间复杂度也是 O(logk)。\n因此，无论是添加新的数据还是取出堆顶的元素，都需要 O(logk) 的时间。    初始化 优先队列的初始化是一个最重要的时间复杂度，是分析运用优先队列性能时必不可少的，也是经常容易弄错的地方。\n举例：有 n 个数据，需要创建一个大小为 n 的堆。\n误区：每当把一个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是 O(nlogn)。\n解法：在创建这个堆的过程中，二叉树的大小是从 1 逐渐增长到 n 的，所以整个算法的复杂度经过推导，最终的结果是 O(n)。  注意：算法面试中是不要求推导的，你只需要记住，初始化一个大小为 n 的堆，所需要的时间是 O(n) 即可。\n"});index.add({'id':33,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/','title':"1.数组与字符串",'content':"1.数组与字符串 字符串 字符串转化 数组和字符串是最基本的数据结构\n很多时候，在分析字符串相关面试题的过程中，我们往往要针对字符串当中的每一个字符进行分析和处理，甚至有时候我们得先把给定的字符串转换成字符数组之后再进行分析和处理。\n数组 优点  构建非常简单 能在 O(1) 的时间里根据数组的下标（index）查询某个元素  缺点  构建时必须分配一段连续的空间 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数） 删除和添加某个元素时，同样需要耗费 O(n) 的时间  练习 LeetCode: 242\n"});index.add({'id':34,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.1.%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/','title':"2.1.1.标识符与关键字",'content':"2.1.1.标识符与关键字 标识符 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。\n关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。\nGo语言中有25个关键字：\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，Go语言中还有37个保留字。\nConstants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover "});index.add({'id':35,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/','title':"2.1.1.类和对象",'content':"2.1.1.类和对象 类的定义  类的实例化  局部变量和全局变量  作用域  局部变量: 仅限于定义它的方法 成员变量: 整个类的内部  构造方法    static静态变量  static静态方法  1、静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。如：  如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。如：  2、在普通成员方法中，则可以直接访问同类的非静态变量和静态变量，如下所示：  3、静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。如：  static静态初始化块  在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。\n需要特别注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。\n "});index.add({'id':36,'href':'/docs/english/2.%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/2.1.%E4%B8%BB%E8%AF%AD/','title':"2.1.主语",'content':"2.1.主语 "});index.add({'id':37,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.1.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/','title':"2.1.常用命令",'content':"2.1.常用命令 镜像相关命令 查看镜像 docker images 搜索镜像 docker search centos 镜像拉取 docker pull centos:7 删除镜像 # 按镜像id删除镜像 docker rmi 镜像id(imageId) # 删除所有镜像 docker rmi `docker images -q` 容器相关命令 查看容器 # 查看正在运行的容器 docker ps # 查看所有容器 docker ps -a # 查看最后一次运行的容器 docker ps -l # 查看停止的容器 docker ps -f status=exited 创建与启动容器 创建容器常用的参数说明:\n创建容器命令:\ndocker run  -i: 表示运行容器 -t: 表示容器启动后进入其命令行。加入这个两个参数后, 容器创建就能登录进去。即分配一个伪终端 \u0026ndash;name: 为创建的容器命名 -v: 表示目录映射关系(前者是宿主机目录,后者是映射到宿主机上的目录), 可以使用多个v做多个目录或文件映射.注意: 最好做目录映射,在宿主机上做修改,然后共享到容器上。 -d:在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器,如果只加-i-t两个参数，创建后就会自动进去容器)。 -p: 表示端口映射,前者是宿主机端口,后者是容器内的映射端口,可以使用多个-p做多个端口映射 更多参数执行: docker run \u0026ndash;help 查看  1.交互式方式创建容器\ndocker run -it --name=容器名称 镜像名称:标签/bin/bash 这时我们通过ps命令查看,发现可以看到启动的容器,状态为启动状态\n退出当前容器\nexit 2.守护式方式创建容器\ndocker run -di --name=容器名称 镜像名称:标签 登陆守护式容器的方式:\ndocker exec -it [容器名称|容器id] /bin/bash 停止容器 docker stop [容器名称|容器id] 启动容器 docker start [容器名称|容器id] 将文件从宿主机拷贝到docke容器 docker cp 文件 [容器名称|容器id]:/usr/local 将文件从docke容器拷贝到宿主机 docker cp [容器名称|容器id]:文件 文件 # docker cp 44002a55b84c:/usr/local/abc.log abc.log 目录挂载 我们可以在创建容器的时候, 将宿主机的目录与容器内的目录进行映射,这样我们就可以修改宿主机某个目录的文件从而去影响容器.\n创建容器添加 -v参数后边为宿主机:容器目录, 例如\ndocker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级目录,可能会出现权限不足的提示.\n这是因为Centos7中的安全模块selinux把权限禁掉了,我们需要添加参数 \u0026ndash;privileged=true 来解决挂载目录没有权限的问题\n查看容器ip地址 我们可以通过以下命令查看容器运行的各种数据\ndocker inspect 容器名称(容器id) 也可以直接执行下面的命令直接输出ip地址\ndocker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称(容器id) 删除容器 docker rm [容器名称|容器id] # 注意:不能删除一个正在运行的容器 "});index.add({'id':38,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.1.%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/','title':"2.10.1.类型别名和自定义类型",'content':"2.10.1.类型别名和自定义类型 Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\n自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。\n自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：\n//将MyInt定义为int类型 type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性。\n类型别名 类型别名是Go1.9版本添加的新功能。\n类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。\ntype TypeAlias = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下：\ntype byte = uint8 type rune = int32 类型定义和类型别名的区别 类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。\n//类型定义 type NewInt int //类型别名 type MyInt = int func main() { var a NewInt var b MyInt fmt.Printf(\u0026quot;type of a:%T\\n\u0026quot;, a) //type of a:main.NewInt fmt.Printf(\u0026quot;type of b:%T\\n\u0026quot;, b) //type of b:int } 结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。\n"});index.add({'id':39,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.11.%E5%8C%85/2.11.1.%E5%8C%85/','title':"2.11.1.包",'content':"2.11.1.包 在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。\n包介绍 包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、os、io等。\n定义包 我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放.go文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。\npackage 包名 注意事项：\n 一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。 包名可以不和文件夹的名字一样，包名不能包含 - 符号。 包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。  可见性 如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。\n举个例子， 我们定义一个包名为pkg2的包，代码如下：\npackage pkg2 import \u0026quot;fmt\u0026quot; // 包变量可见性 var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用 // 首字母大写外部包可见，可在其他包中使用 const Mode = 1 type person struct { // 首字母小写，外部包不可见，只能在当前包内使用 name string } // 首字母大写，外部包可见，可在其他包中使用 func Add(x, y int) int { return x + y } func age() { // 首字母小写，外部包不可见，只能在当前包内使用 var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用 fmt.Println(Age) } 结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法。例如：\ntype Student struct { Name string //可在包外访问的方法 class string //仅限包内访问的字段 } type Payer interface { init() //仅限包内访问的方法 Pay() //可在包外访问的方法 } 包的导入 要在代码中引用其他包的内容，需要使用import关键字导入使用的包。具体语法如下:\nimport \u0026quot;包的路径\u0026quot; 注意事项：\n import导入语句通常放在文件开头包声明语句的下面。 导入的包名需要使用双引号包裹起来。 包名是从$GOPATH/src/后开始计算的，使用/进行路径分隔。 Go语言中禁止循环导入包。  单行导入 单行导入的格式如下:\nimport \u0026quot;包1\u0026quot; import \u0026quot;包2\u0026quot; 多行导入 多行导入的格式如下：\nimport ( \u0026quot;包1\u0026quot; \u0026quot;包2\u0026quot; ) 自定义包名 在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体语法格式如下：\nimport 别名 \u0026quot;包的路径\u0026quot; 单行导入方式定义别名：\nimport \u0026quot;fmt\u0026quot; import m \u0026quot;github.com/Q1mi/studygo/pkg_test\u0026quot; func main() { fmt.Println(m.Add(100, 200)) fmt.Println(m.Mode) } 多行导入方式定义别名：\nimport ( \u0026quot;fmt\u0026quot; m \u0026quot;github.com/Q1mi/studygo/pkg_test\u0026quot; ) func main() { fmt.Println(m.Add(100, 200)) fmt.Println(m.Mode) } 匿名导入包 如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式如下：\nimport _ \u0026quot;包的路径\u0026quot; 匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。\ninit()初始化函数 init()函数介绍 在Go语言程序执行时导入包语句会自动触发包内部init()函数的调用。需要注意的是： init()函数没有参数也没有返回值。 init()函数在程序运行时自动被调用执行，不能在代码中主动调用它。\n包初始化执行的顺序如下图所示：\n init()函数执行顺序 Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。\n在运行时，被最后导入的包会最先初始化并调用其init()函数， 如下图示：\n "});index.add({'id':40,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.12.%E6%8E%A5%E5%8F%A3/2.12.1.%E6%8E%A5%E5%8F%A3/','title':"2.12.1.接口",'content':"2.12.1.接口 接口类型 在Go语言中接口（interface）是一种类型，一种抽象的类型。\ninterface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。\n为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。\n为什么要使用接口 type Cat struct{} func (c Cat) Say() string { return \u0026quot;喵喵喵\u0026quot; } type Dog struct{} func (d Dog) Say() string { return \u0026quot;汪汪汪\u0026quot; } func main() { c := Cat{} fmt.Println(\u0026quot;猫:\u0026quot;, c.Say()) d := Dog{} fmt.Println(\u0026quot;狗:\u0026quot;, d.Say()) } 上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？\n像类似的例子在我们编程过程中会经常遇到：\n比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？\n比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？\n比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？\nGo语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。\n接口的定义 Go语言提倡面向接口编程。\n每个接口由数个方法组成，接口的定义格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 其中:\n 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。  举个例子:\ntype writer interface{ Write([]byte) error } 当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。\n实现接口的条件 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。 我们来定义一个Sayer接口：\n// Sayer 接口 type Sayer interface { say() } 定义dog和cat两个结构体：\ntype dog struct {} type cat struct {} 因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。\n// dog实现了Sayer接口 func (d dog) say() { fmt.Println(\u0026quot;汪汪汪\u0026quot;) } // cat实现了Sayer接口 func (c cat) say() { fmt.Println(\u0026quot;喵喵喵\u0026quot;) } 接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。\n接口类型变量 那实现了接口有什么用呢？\n接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。\nfunc main() { var x Sayer // 声明一个Sayer类型的变量x a := cat{} // 实例化一个cat b := dog{} // 实例化一个dog x = a // 可以把cat实例直接赋值给x x.say() // 喵喵喵 x = b // 可以把dog实例直接赋值给x x.say() // 汪汪汪 } Tips： 观察下面的代码，体味此处_的妙用\n// 摘自gin框架routergroup.go type IRouter interface{ ... } type RouterGroup struct { ... } var _ IRouter = \u0026amp;RouterGroup{} // 确保RouterGroup实现了接口IRouter 值接收者和指针接收者实现接口的区别 使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。\n我们有一个Mover接口和一个dog结构体。\ntype Mover interface { move() } type dog struct {} 值接收者实现接口 func (d dog) move() { fmt.Println(\u0026quot;狗会动\u0026quot;) } 此时实现接口的是dog类型：\nfunc main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x可以接收dog类型 var fugui = \u0026amp;dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 x.move() } 从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值fugui。\n指针接收者实现接口 同样的代码我们再来测试一下使用指针接收者有什么区别：\nfunc (d *dog) move() { fmt.Println(\u0026quot;狗会动\u0026quot;) } func main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x不可以接收dog类型 var fugui = \u0026amp;dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 } 此时实现Mover接口的是dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储dog类型的值。\n类型与接口的关系 一个类型实现多个接口 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口。\n// Sayer 接口 type Sayer interface { say() } // Mover 接口 type Mover interface { move() } dog既可以实现Sayer接口，也可以实现Mover接口。\ntype dog struct { name string } // 实现Sayer接口 func (d dog) say() { fmt.Printf(\u0026quot;%s会叫汪汪汪\\n\u0026quot;, d.name) } // 实现Mover接口 func (d dog) move() { fmt.Printf(\u0026quot;%s会动\\n\u0026quot;, d.name) } func main() { var x Sayer var y Mover var a = dog{name: \u0026quot;旺财\u0026quot;} x = a y = a x.say() y.move() } 多个类型实现同一接口 Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法。\n// Mover 接口 type Mover interface { move() } 例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：\ntype dog struct { name string } type car struct { brand string } // dog类型实现Mover接口 func (d dog) move() { fmt.Printf(\u0026quot;%s会跑\\n\u0026quot;, d.name) } // car类型实现Mover接口 func (c car) move() { fmt.Printf(\u0026quot;%s速度70迈\\n\u0026quot;, c.brand) } 这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。\nfunc main() { var x Mover var a = dog{name: \u0026quot;旺财\u0026quot;} var b = car{brand: \u0026quot;保时捷\u0026quot;} x = a x.move() x = b x.move() } 上面的代码执行结果如下：\n旺财会跑 保时捷速度70迈 并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。\n// WashingMachine 洗衣机 type WashingMachine interface { wash() dry() } // 甩干器 type dryer struct{} // 实现WashingMachine接口的dry()方法 func (d dryer) dry() { fmt.Println(\u0026quot;甩一甩\u0026quot;) } // 海尔洗衣机 type haier struct { dryer //嵌入甩干器 } // 实现WashingMachine接口的wash()方法 func (h haier) wash() { fmt.Println(\u0026quot;洗刷刷\u0026quot;) } 接口嵌套 接口与接口间可以通过嵌套创造出新的接口。\n// Sayer 接口 type Sayer interface { say() } // Mover 接口 type Mover interface { move() } // 接口嵌套 type animal interface { Sayer Mover } 嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：\ntype cat struct { name string } func (c cat) say() { fmt.Println(\u0026quot;喵喵喵\u0026quot;) } func (c cat) move() { fmt.Println(\u0026quot;猫会动\u0026quot;) } func main() { var x animal x = cat{name: \u0026quot;花花\u0026quot;} x.move() x.say() } 空接口 空接口的定义 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。\n空接口类型的变量可以存储任意类型的变量。\nfunc main() { // 定义一个空接口x var x interface{} s := \u0026quot;Hello 沙河\u0026quot; x = s fmt.Printf(\u0026quot;type:%T value:%v\\n\u0026quot;, x, x) i := 100 x = i fmt.Printf(\u0026quot;type:%T value:%v\\n\u0026quot;, x, x) b := true x = b fmt.Printf(\u0026quot;type:%T value:%v\\n\u0026quot;, x, x) } 空接口的应用 空接口作为函数的参数\n使用空接口实现可以接收任意类型的函数参数。\n// 空接口作为函数参数 func show(a interface{}) { fmt.Printf(\u0026quot;type:%T value:%v\\n\u0026quot;, a, a) } 空接口作为map的值\n使用空接口实现可以保存任意值的字典。\n// 空接口作为map值 var studentInfo = make(map[string]interface{}) studentInfo[\u0026quot;name\u0026quot;] = \u0026quot;沙河娜扎\u0026quot; studentInfo[\u0026quot;age\u0026quot;] = 18 studentInfo[\u0026quot;married\u0026quot;] = false fmt.Println(studentInfo) 类型断言 空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？\n接口值 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。\n我们来看一个具体的例子：\nvar w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil 请看下图分解：  想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：\nx.(T) 其中：\n x：表示类型为interface{}的变量 T：表示断言x可能是的类型。 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。  举个例子：\nfunc main() { var x interface{} x = \u0026quot;Hello 沙河\u0026quot; v, ok := x.(string) if ok { fmt.Println(v) } else { fmt.Println(\u0026quot;类型断言失败\u0026quot;) } } 上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现：\nfunc justifyType(x interface{}) { switch v := x.(type) { case string: fmt.Printf(\u0026quot;x is a string，value is %v\\n\u0026quot;, v) case int: fmt.Printf(\u0026quot;x is a int is %v\\n\u0026quot;, v) case bool: fmt.Printf(\u0026quot;x is a bool is %v\\n\u0026quot;, v) default: fmt.Println(\u0026quot;unsupport type！\u0026quot;) } } 因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。\n关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。\n"});index.add({'id':41,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.1.%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%9C%A8%E6%9C%BA%E5%88%B6/','title':"2.13.1.变量的内在机制",'content':"2.13.1.变量的内在机制 Go语言中的变量是分为两部分的:\n 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。  "});index.add({'id':42,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.1.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/','title':"2.14.1.并发与并行",'content':"2.14.1.并发与并行 并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。\n并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。\nGo语言的并发通过goroutine实现。goroutine类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。\nGo语言还提供channel在多个goroutine间进行通信。goroutine和channel是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。\n"});index.add({'id':43,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.1.gotest%E5%B7%A5%E5%85%B7/','title':"2.16.1.gotest工具",'content':"gotest工具 Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。\ngo test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。\n在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。\n   类型 格式 作用     测试函数 函数名前缀为Test 测试程序的一些逻辑行为是否正确   基准函数 函数名前缀为Benchmark 测试函数的性能   示例函数 函数名前缀为Example 为文档提供示例文档    go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。\n"});index.add({'id':44,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.1.%E6%95%B4%E5%9E%8B/','title':"2.2.1.整型",'content':"2.2.1.整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。\n   类型 描述     uint8 无符号8位整型   uint16 无符号16位整型   uint32 无符号32位整型   uint64 无符号64位整型   int8 有符号8位整型   int16 有符号16位整型   int32 有符号32位整型   int64 有符号64位整型    特殊整型    类型 描述     uint 32位操作系统上就是uint32, 64位操作系统就是uint64   int 32位操作系统上就是int32， 64位操作系统就是int64   uintptr 无符号整型, 用于存放一个指针    注意: 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。\n注意事项: 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint。\n数字字面量语法 Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如： v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。 我们可以借助fmt函数来将一个整数以不同进制形式展示。\npackage main import \u0026quot;fmt\u0026quot; func main(){ // 十进制 var a int = 10 fmt.Printf(\u0026quot;%d \\n\u0026quot;, a) // 10 fmt.Printf(\u0026quot;%b \\n\u0026quot;, a) // 1010 占位符%b表示二进制 // 八进制 以0开头 var b int = 077 fmt.Printf(\u0026quot;%o \\n\u0026quot;, b) // 77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(\u0026quot;%x \\n\u0026quot;, c) // ff fmt.Printf(\u0026quot;%X \\n\u0026quot;, c) // FF } "});index.add({'id':45,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.1.%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5/','title':"2.2.1.集合的概念",'content':"2.2.1.集合的概念   对象的容器,定义了对多个对象进行操作的常用方法。可实现数组的功能。\n  和数组的区别\n 数组长度固定，集合长度不固定 数组可以存储基本类型和引用类型，集合只能存储引用类型    位置: java.util.*\n  "});index.add({'id':46,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.1.%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"2.3.1.算术运算符",'content':"2.3.1.算术运算符    运算符 描述     + 相加   - 相减   * 相乘   / 相除   % 求余    注意： ++（自增）和\u0026ndash;（自减）在Go语言中是单独的语句，并不是运算符。\n"});index.add({'id':47,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.1.if/','title':"2.4.1.if",'content':"2.4.1.if(分支结构).md if条件判断基本写法 Go语言中if条件判断的格式如下：\nif 表达式1 { 分支1 } else if 表达式2 { 分支2 } else{ 分支3 } 当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的else if和else都是可选的，可以根据实际需要进行选择。\nGo语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 同理，与else匹配的{也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。\n举个例子：\nfunc ifDemo1() { score := 65 if score \u0026gt;= 90 { fmt.Println(\u0026quot;A\u0026quot;) } else if score \u0026gt; 75 { fmt.Println(\u0026quot;B\u0026quot;) } else { fmt.Println(\u0026quot;C\u0026quot;) } } if条件判断特殊写法 if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：\nfunc ifDemo2() { if score := 65; score \u0026gt;= 90 { fmt.Println(\u0026quot;A\u0026quot;) } else if score \u0026gt; 75 { fmt.Println(\u0026quot;B\u0026quot;) } else { fmt.Println(\u0026quot;C\u0026quot;) } } "});index.add({'id':48,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.5.%E6%95%B0%E7%BB%84/2.5.%E6%95%B0%E7%BB%84/','title':"2.5.数组",'content':"数组 数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：\n// 定义一个长度为3元素类型为int的数组a var a [3]int 数组定义 var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。\nvar a [3]int var b [4]int a = b //不可以这样做，因为此时a和b是不同的类型 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。\n数组的初始化 方法一 初始化数组时可以使用初始化列表来设置数组元素的值。\nvar testArray [3]int //数组会初始化为int类型的零值 var numArray = [3]int{1, 2} //使用指定的初始值完成初始化 方法二 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：\nvar numArray = [...]int{1, 2} 方法三 我们还可以使用指定索引值的方式来初始化数组，例如:\na := [...]int{1: 1, 3: 5} 数组的遍历 遍历数组a有以下两种方法：\nfunc main() { var a = [...]string{\u0026quot;北京\u0026quot;, \u0026quot;上海\u0026quot;, \u0026quot;深圳\u0026quot;} // 方法1：for循环遍历 for i := 0; i \u0026lt; len(a); i++ { fmt.Println(a[i]) } // 方法2：for range遍历 for index, value := range a { fmt.Println(index, value) } } 多维数组 Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。\n二维数组的定义 a := [3][2]string{ {\u0026quot;北京\u0026quot;, \u0026quot;上海\u0026quot;}, {\u0026quot;广州\u0026quot;, \u0026quot;深圳\u0026quot;}, {\u0026quot;成都\u0026quot;, \u0026quot;重庆\u0026quot;}, } 二维数组的遍历 func main() { a := [3][2]string{ {\u0026quot;北京\u0026quot;, \u0026quot;上海\u0026quot;}, {\u0026quot;广州\u0026quot;, \u0026quot;深圳\u0026quot;}, {\u0026quot;成都\u0026quot;, \u0026quot;重庆\u0026quot;}, } for _, v1 := range a { for _, v2 := range v1 { fmt.Printf(\u0026quot;%s\\t\u0026quot;, v2) } fmt.Println() } } 注意： 多维数组只有第一层可以使用\u0026hellip;来让编译器推导数组长度。例如：\n//支持的写法 a := [...][2]string{ {\u0026quot;北京\u0026quot;, \u0026quot;上海\u0026quot;}, {\u0026quot;广州\u0026quot;, \u0026quot;深圳\u0026quot;}, {\u0026quot;成都\u0026quot;, \u0026quot;重庆\u0026quot;}, } //不支持多维数组的内层使用... b := [3][...]string{ {\u0026quot;北京\u0026quot;, \u0026quot;上海\u0026quot;}, {\u0026quot;广州\u0026quot;, \u0026quot;深圳\u0026quot;}, {\u0026quot;成都\u0026quot;, \u0026quot;重庆\u0026quot;}, } 数组是值类型 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。\nfunc modifyArray(x [3]int) { x[0] = 100 } func modifyArray2(x [3][2]int) { x[2][0] = 100 } func main() { a := [3]int{10, 20, 30} modifyArray(a) //在modify中修改的是a的副本x fmt.Println(a) //[10 20 30] b := [3][2]int{ {1, 1}, {1, 1}, {1, 1}, } modifyArray2(b) //在modify中修改的是b的副本x fmt.Println(b) //[[1 1] [1 1] [1 1]] } 注意:\n 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]T表示指针数组，[n]T表示数组指针 。  "});index.add({'id':49,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/2.6.%E5%88%87%E7%89%87/','title':"2.6.切片",'content':"切片 引子 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：\nfunc arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum + v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，\na := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。\n切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。\n切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。\n切片的定义 声明切片类型的基本语法如下：\nvar name []T 其中，\n name:表示变量名 T:表示切片中的元素类型 举个例子：  func main() { // 声明切片类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 var d = []bool{false, true} //声明一个布尔切片并初始化 fmt.Println(a) //[] fmt.Println(b) //[] fmt.Println(c) //[false true] fmt.Println(a == nil) //true fmt.Println(b == nil) //false fmt.Println(c == nil) //false // fmt.Println(c == d) //切片是引用类型，不支持直接比较，只能和nil比较 } 切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。\n切片表达式 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。\n简单切片表达式 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1\u0026lt;=索引值\u0026lt;4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\u0026quot;s:%v len(s):%v cap(s):%v\\n\u0026quot;, s, len(s), cap(s)) } 输出:\ns:[2 3] len(s):2 cap(s):4 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:\na[2:] // 等同于 a[2:len(a)] a[:3] // 等同于 a[0:3] a[:] // 等同于 a[0:len(a)] 注意:\n对于数组或字符串，如果0 \u0026lt;= low \u0026lt;= high \u0026lt;= len(a)，则索引合法，否则就会索引越界（out of range）。\n对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low \u0026lt;= high。如果索引在运行时超出范围，就会发生运行时panic。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\u0026quot;s:%v len(s):%v cap(s):%v\\n\u0026quot;, s, len(s), cap(s)) s2 := s[3:4] // 索引的上限是cap(s)而不是len(s) fmt.Printf(\u0026quot;s2:%v len(s2):%v cap(s2):%v\\n\u0026quot;, s2, len(s2), cap(s2)) } 输出:\ns:[2 3] len(s):2 cap(s):4 s2:[5] len(s2):1 cap(s2):1 完整切片表达式 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：\na[low : high : max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} t := a[1:3:5] fmt.Printf(\u0026quot;t:%v len(t):%v cap(t):%v\\n\u0026quot;, t, len(t), cap(t)) } 输出结果：\nt:[2 3] len(t):2 cap(t):4 完整切片表达式需要满足的条件是0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a)，其他条件和简单切片表达式相同。\n使用make()函数构造切片 我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下：\nmake([]T, size, cap) 其中：\n T:切片的元素类型 size:切片中元素的数量 cap:切片的容量 举个例子：  func main() { a := make([]int, 2, 10) fmt.Println(a) //[0 0] fmt.Println(len(a)) //2 fmt.Println(cap(a)) //10 } 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。\n切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。\n举个例子，现在有一个数组a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片s1 := a[:5]，相应示意图如下。\n 判断切片是否为空 要检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断。\n切片不能直接比较 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：\nvar s1 []int //len(s1)=0;cap(s1)=0;s1==nil s2 := []int{} //len(s2)=0;cap(s2)=0;s2!=nil s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil 所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。\n切片的赋值拷贝 下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。\nfunc main() { s1 := make([]int, 3) //[0 0 0] s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0] } 切片遍历 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。\nfunc main() { s := []int{1, 3, 5} for i := 0; i \u0026lt; len(s); i++ { fmt.Println(i, s[i]) } for index, value := range s { fmt.Println(index, value) } } append()方法为切片添加元素 Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。\nfunc main(){ var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int{5, 6, 7} s = append(s, s2...) // [1 2 3 4 5 6 7] } 注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。\nvar s []int s = append(s, 1, 2, 3) 没有必要像下面的代码一样初始化一个切片再传入append()函数使用，\ns := []int{} // 没有必要初始化 s = append(s, 1, 2, 3) var s = make([]int) // 没有必要初始化 s = append(s, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。\n举个例子：\nfunc main() { //append()添加元素和切片扩容 var numSlice []int for i := 0; i \u0026lt; 10; i++ { numSlice = append(numSlice, i) fmt.Printf(\u0026quot;%v len:%d cap:%d ptr:%p\\n\u0026quot;, numSlice, len(numSlice), cap(numSlice), numSlice) } } 输出:\n[0] len:1 cap:1 ptr:0xc0000a8000 [0 1] len:2 cap:2 ptr:0xc0000a8040 [0 1 2] len:3 cap:4 ptr:0xc0000b2020 [0 1 2 3] len:4 cap:4 ptr:0xc0000b2020 [0 1 2 3 4] len:5 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc0000b8000 [0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc0000b8000 从上面的结果可以看出：\n append()函数将元素追加到切片的最后并返回该切片。 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。  append()函数还支持一次性追加多个元素。 例如：\nvar citySlice []string // 追加一个元素 citySlice = append(citySlice, \u0026quot;北京\u0026quot;) // 追加多个元素 citySlice = append(citySlice, \u0026quot;上海\u0026quot;, \u0026quot;广州\u0026quot;, \u0026quot;深圳\u0026quot;) // 追加切片 a := []string{\u0026quot;成都\u0026quot;, \u0026quot;重庆\u0026quot;} citySlice = append(citySlice, a...) fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆] 切片的扩容策略 可以通过查看$GOROOT/src/runtime/slice.go源码，其中扩容相关代码如下：\nnewcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { newcap = cap } else { if old.len \u0026lt; 1024 { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } 从上面的代码可以看出以下内容：\n 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）， 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap \u0026gt;= cap） 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。  需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。\n使用copy()函数复制切片 首先我们来看一个问题：\nfunc main() { a := []int{1, 2, 3, 4, 5} b := a fmt.Println(a) //[1 2 3 4 5] fmt.Println(b) //[1 2 3 4 5] b[0] = 1000 fmt.Println(a) //[1000 2 3 4 5] fmt.Println(b) //[1000 2 3 4 5] } 由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。\nGo语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：\ncopy(destSlice, srcSlice []T) 其中：\n srcSlice: 数据来源切片 destSlice: 目标切片  举个例子：\nfunc main() { // copy()复制切片 a := []int{1, 2, 3, 4, 5} c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1 2 3 4 5] c[0] = 1000 fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1000 2 3 4 5] } 从切片中删除元素 Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：\nfunc main() { // 从切片中删除元素 a := []int{30, 31, 32, 33, 34, 35, 36, 37} // 要删除索引为2的元素 a = append(a[:2], a[3:]...) fmt.Println(a) //[30 31 33 34 35 36 37] } 总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]\u0026hellip;)\n"});index.add({'id':50,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.7.map/2.7.map/','title':"2.7.map",'content':"2.7.map Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。\nmap是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。\nmap定义 Go语言中 map的定义语法如下：\nmap[KeyType]ValueType 其中\n KeyType:表示键的类型。 ValueType:表示键对应的值的类型。 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：  make(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。\nmap基本使用 map中的数据都是成对出现的，map的基本使用示例代码如下：\nfunc main() { scoreMap := make(map[string]int, 8) scoreMap[\u0026quot;张三\u0026quot;] = 90 scoreMap[\u0026quot;小明\u0026quot;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[\u0026quot;小明\u0026quot;]) fmt.Printf(\u0026quot;type of a:%T\\n\u0026quot;, scoreMap) } 输出：\nmap[小明:100 张三:90] 100 type of a:map[string]int map也支持在声明的时候填充元素，例如：\nfunc main() { userInfo := map[string]string{ \u0026quot;username\u0026quot;: \u0026quot;沙河小王子\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;123456\u0026quot;, } fmt.Println(userInfo) // } 判断某个键是否存在 Go语言中有个判断map中键是否存在的特殊写法，格式如下:\nvalue, ok := map[key] 举个例子：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026quot;张三\u0026quot;] = 90 scoreMap[\u0026quot;小明\u0026quot;] = 100 // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值 v, ok := scoreMap[\u0026quot;张三\u0026quot;] if ok { fmt.Println(v) } else { fmt.Println(\u0026quot;查无此人\u0026quot;) } } map的遍历 Go语言中使用for range遍历map。\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026quot;张三\u0026quot;] = 90 scoreMap[\u0026quot;小明\u0026quot;] = 100 scoreMap[\u0026quot;娜扎\u0026quot;] = 60 for k, v := range scoreMap { fmt.Println(k, v) } } 注意： 遍历map时的元素顺序与添加键值对的顺序无关。\n使用delete()函数删除键值对 使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：\ndelete(map, key) 其中,\n map:表示要删除键值对的map key:表示要删除的键值对的键 示例代码如下：  func main(){ scoreMap := make(map[string]int) scoreMap[\u0026quot;张三\u0026quot;] = 90 scoreMap[\u0026quot;小明\u0026quot;] = 100 scoreMap[\u0026quot;娜扎\u0026quot;] = 60 delete(scoreMap, \u0026quot;小明\u0026quot;)//将小明:100从map中删除 for k,v := range scoreMap{ fmt.Println(k, v) } } 按照指定顺序遍历map func main() { rand.Seed(time.Now().UnixNano()) //初始化随机数种子 var scoreMap = make(map[string]int, 200) for i := 0; i \u0026lt; 100; i++ { key := fmt.Sprintf(\u0026quot;stu%02d\u0026quot;, i) //生成stu开头的字符串 value := rand.Intn(100) //生成0~99的随机整数 scoreMap[key] = value } //取出map中的所有key存入切片keys var keys = make([]string, 0, 200) for key := range scoreMap { keys = append(keys, key) } //对切片进行排序 sort.Strings(keys) //按照排序后的key遍历map for _, key := range keys { fmt.Println(key, scoreMap[key]) } } 元素为map类型的切片 下面的代码演示了切片中的元素为map类型时的操作：\nfunc main() { var mapSlice = make([]map[string]string, 3) for index, value := range mapSlice { fmt.Printf(\u0026quot;index:%d value:%v\\n\u0026quot;, index, value) } fmt.Println(\u0026quot;after init\u0026quot;) // 对切片中的map元素进行初始化 mapSlice[0] = make(map[string]string, 10) mapSlice[0][\u0026quot;name\u0026quot;] = \u0026quot;小王子\u0026quot; mapSlice[0][\u0026quot;password\u0026quot;] = \u0026quot;123456\u0026quot; mapSlice[0][\u0026quot;address\u0026quot;] = \u0026quot;沙河\u0026quot; for index, value := range mapSlice { fmt.Printf(\u0026quot;index:%d value:%v\\n\u0026quot;, index, value) } } 值为切片类型的map 下面的代码演示了map中值为切片类型的操作：\nfunc main() { var sliceMap = make(map[string][]string, 3) fmt.Println(sliceMap) fmt.Println(\u0026quot;after init\u0026quot;) key := \u0026quot;中国\u0026quot; value, ok := sliceMap[key] if !ok { value = make([]string, 0, 2) } value = append(value, \u0026quot;北京\u0026quot;, \u0026quot;上海\u0026quot;) sliceMap[key] = value fmt.Println(sliceMap) } "});index.add({'id':51,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.1.%E5%87%BD%E6%95%B0/','title':"2.8.1.函数",'content':"2.8.1.函数 Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。\n函数定义 Go语言中定义函数使用func关键字，具体格式如下：\nfunc 函数名(参数)(返回值){ 函数体 } 其中:\n 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名 参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔。 函数体：实现指定功能的代码块。  我们先来定义一个求两个数之和的函数：\nfunc intSum(x int, y int) int { return x + y } 函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：\nfunc sayHello() { fmt.Println(\u0026quot;Hello 沙河\u0026quot;) } 函数的调用 定义了函数之后，我们可以通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：\nfunc main() { sayHello() ret := intSum(10, 20) fmt.Println(ret) } 注意，调用有返回值的函数时，可以不接收其返回值。\n参数 类型简写 函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：\nfunc intSum(x, y int) int { return x + y } 上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型。\n可变参数 可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加\u0026hellip;来标识。\n注意：可变参数通常要作为函数的最后一个参数。\n举个例子：\nfunc intSum2(x ...int) int { fmt.Println(x) //x是一个切片 sum := 0 for _, v := range x { sum = sum + v } return sum } 调用上面的函数：\nret1 := intSum2() ret2 := intSum2(10) ret3 := intSum2(10, 20) ret4 := intSum2(10, 20, 30) fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60 固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：\nfunc intSum3(x int, y ...int) int { fmt.Println(x, y) sum := x for _, v := range y { sum = sum + v } return sum } 调用上述函数：\nret5 := intSum3(100) ret6 := intSum3(100, 10) ret7 := intSum3(100, 10, 20) ret8 := intSum3(100, 10, 20, 30) fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160 本质上，函数的可变参数是通过切片来实现的。\n返回值 Go语言中通过return关键字向外输出返回值。\n多返回值 Go语言中函数支持多返回值，函数如果有多个返回值时必须用()将所有返回值包裹起来。 举个例子：\nfunc calc(x, y int) (int, int) { sum := x + y sub := x - y return sum, sub } 返回值命名 函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。\n例如:\nfunc calc(x, y int) (sum, sub int) { sum = x + y sub = x - y return } 返回值补充 当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。\nfunc someFunc(x string) []int { if x == \u0026quot;\u0026quot; { return nil // 没必要返回[]int{} } ... } "});index.add({'id':52,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.9.%E6%8C%87%E9%92%88/2.9.1.%E6%8C%87%E9%92%88/','title':"2.9.1.指针",'content':"2.9.1.指针 区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。\n要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。\n任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\n比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭。\nGo语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：\u0026amp;（取地址）和*（根据地址取值）。\n指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用\u0026amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。\n取变量指针的语法如下：\nptr := \u0026amp;v // v的类型为T 其中:\n v:代表被取地址的变量，类型为T ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。 举个例子:  func main() { a := 10 b := \u0026amp;a fmt.Printf(\u0026quot;a:%d ptr:%p\\n\u0026quot;, a, \u0026amp;a) // a:10 ptr:0xc00001a078 fmt.Printf(\u0026quot;b:%p type:%T\\n\u0026quot;, b, b) // b:0xc00001a078 type:*int fmt.Println(\u0026amp;b) // 0xc00000e018 } 我们来看一下b := \u0026amp;a的图示：\n 指针取值 在对普通变量使用\u0026amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。\nfunc main() { //指针取值 a := 10 b := \u0026amp;a // 取变量a的地址，将指针保存到b中 fmt.Printf(\u0026quot;type of b:%T\\n\u0026quot;, b) c := *b // 指针取值（根据指针去内存取值） fmt.Printf(\u0026quot;type of c:%T\\n\u0026quot;, c) fmt.Printf(\u0026quot;value of c:%v\\n\u0026quot;, c) } 输出如下：\ntype of b:*int type of c:int value of c:10 总结： 取地址操作符\u0026amp;和取值操作符*是一对互补操作符，\u0026amp;取出地址，*根据地址取出地址指向的值。\n变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：\n 对变量进行取地址（\u0026amp;）操作，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。  指针传值示例： func modify1(x int) { x = 100 } func modify2(x *int) { *x = 100 } func main() { a := 10 modify1(a) fmt.Println(a) // 10 modify2(\u0026amp;a) fmt.Println(a) // 100 } new和make 我们先来看一个例子：\nfunc main() { var a *int *a = 100 fmt.Println(*a) var b map[string]int b[\u0026quot;沙河娜扎\u0026quot;] = 100 fmt.Println(b) } 执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。\nnew new是一个内置的函数，它的函数签名如下：\nfunc new(Type) *Type 其中，\n Type表示类型，new函数只接受一个参数，这个参数是一个类型 Type表示类型指针，new函数返回一个指向该类型内存地址的指针。  new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：\nfunc main() { a := new(int) b := new(bool) fmt.Printf(\u0026quot;%T\\n\u0026quot;, a) // *int fmt.Printf(\u0026quot;%T\\n\u0026quot;, b) // *bool fmt.Println(*a) // 0 fmt.Println(*b) // false }\t本节开始的示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：\nfunc main() { var a *int a = new(int) *a = 10 fmt.Println(*a) } make make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：\nfunc make(t Type, size ...IntegerType) Type make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。\n本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：\nfunc main() { var b map[string]int b = make(map[string]int, 10) b[\u0026quot;沙河娜扎\u0026quot;] = 100 fmt.Println(b) } new与make的区别 1.二者都是用来做内存分配的。\n2.make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；\n3.而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。\n"});index.add({'id':53,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/','title':"2.Docker使用",'content':"2.Docker使用 "});index.add({'id':54,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.1.fmt/','title':"3.1.fmt",'content':"3.1.fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。\n向外输出 标准库fmt提供了以下几种输出相关函数。\nprint Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。\nfunc Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) 举个简单的例子：\nfunc main() { fmt.Print(\u0026quot;在终端打印该信息。\u0026quot;) name := \u0026quot;沙河小王子\u0026quot; fmt.Printf(\u0026quot;我是：%s\\n\u0026quot;, name) fmt.Println(\u0026quot;在终端打印单独一行显示\u0026quot;) } 执行上面的代码输出：\n在终端打印该信息。我是：沙河小王子 在终端打印单独一行显示 Fprint Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。\nfunc Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) 举个例子：\n// 向标准输出写入内容 fmt.Fprintln(os.Stdout, \u0026quot;向标准输出写入内容\u0026quot;) fileObj, err := os.OpenFile(\u0026quot;./xx.txt\u0026quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\u0026quot;打开文件出错，err:\u0026quot;, err) return } name := \u0026quot;沙河小王子\u0026quot; // 向打开的文件句柄中写入内容 fmt.Fprintf(fileObj, \u0026quot;往文件中写如信息：%s\u0026quot;, name) 注意，只要满足io.Writer接口的类型都支持写入。\nSprint Sprint系列函数会把传入的数据生成并返回一个字符串。\nfunc Sprint(a ...interface{}) string func Sprintf(format string, a ...interface{}) string func Sprintln(a ...interface{}) string 简单的示例代码如下：\ns1 := fmt.Sprint(\u0026quot;沙河小王子\u0026quot;) name := \u0026quot;沙河小王子\u0026quot; age := 18 s2 := fmt.Sprintf(\u0026quot;name:%s,age:%d\u0026quot;, name, age) s3 := fmt.Sprintln(\u0026quot;沙河小王子\u0026quot;) fmt.Println(s1, s2, s3) Errorf Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。\nfunc Errorf(format string, a ...interface{}) error 通常使用这种方式来自定义错误类型，例如：\nerr := fmt.Errorf(\u0026quot;这是一个错误\u0026quot;) Go1.13版本为fmt.Errorf函数新加了一个%w占位符用来生成一个可以包裹Error的Wrapping Error。\ne := errors.New(\u0026quot;原始错误e\u0026quot;) w := fmt.Errorf(\u0026quot;Wrap了一个错误%w\u0026quot;, e) 格式化占位符 *printf系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。\n通用占位符    占位符 说明     %v 值的默认格式表示   %+v 类似%v，但输出结构体时会添加字段名   %#v 值的Go语法表示   %T 打印值的类型   %% 百分号   示例代码如下：     fmt.Printf(\u0026quot;%v\\n\u0026quot;, 100) fmt.Printf(\u0026quot;%v\\n\u0026quot;, false) o := struct{ name string }{\u0026quot;小王子\u0026quot;} fmt.Printf(\u0026quot;%v\\n\u0026quot;, o) fmt.Printf(\u0026quot;%#v\\n\u0026quot;, o) fmt.Printf(\u0026quot;%T\\n\u0026quot;, o) fmt.Printf(\u0026quot;100%%\\n\u0026quot;) 输出结果如下：\n100 false {小王子} struct { name string }{name:\u0026quot;小王子\u0026quot;} struct { name string } 100% 布尔值    占位符 说明     %t true或false    整型    占位符 说明     %b 表示为二进制   %c 该值对应的unicode码值   %d 表示为十进制   %o 表示为八进制   %x 表示为十六进制，使用a-f   %X 表示为十六进制，使用A-F   %U 表示为Unicode格式：U+1234，等价于”U+%04X”   %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示    示例代码如下：\nn := 65 fmt.Printf(\u0026quot;%b\\n\u0026quot;, n) fmt.Printf(\u0026quot;%c\\n\u0026quot;, n) fmt.Printf(\u0026quot;%d\\n\u0026quot;, n) fmt.Printf(\u0026quot;%o\\n\u0026quot;, n) fmt.Printf(\u0026quot;%x\\n\u0026quot;, n) fmt.Printf(\u0026quot;%X\\n\u0026quot;, n) 输出结果如下：\n1000001 A 65 101 41 41 浮点数与复数    占位符 说明     %b 无小数部分、二进制指数的科学计数法，如-123456p-78   %e 科学计数法，如-1234.456e+78   %E 科学计数法，如-1234.456E+78   %f 有小数部分但无指数部分，如123.456   %F 等价于%f   %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）   %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）    示例代码如下：\nf := 12.34 fmt.Printf(\u0026quot;%b\\n\u0026quot;, f) fmt.Printf(\u0026quot;%e\\n\u0026quot;, f) fmt.Printf(\u0026quot;%E\\n\u0026quot;, f) fmt.Printf(\u0026quot;%f\\n\u0026quot;, f) fmt.Printf(\u0026quot;%g\\n\u0026quot;, f) fmt.Printf(\u0026quot;%G\\n\u0026quot;, f) 输出结果如下：\n6946802425218990p-49 1.234000e+01 1.234000E+01 12.340000 12.34 12.34 字符串和[]byte    占位符 说明     %s 直接输出字符串或者[]byte   %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示   %x 每个字节用两字符十六进制数表示（使用a-f   %X 每个字节用两字符十六进制数表示（使用A-F）    示例代码如下：\ns := \u0026quot;小王子\u0026quot; fmt.Printf(\u0026quot;%s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%q\\n\u0026quot;, s) fmt.Printf(\u0026quot;%x\\n\u0026quot;, s) fmt.Printf(\u0026quot;%X\\n\u0026quot;, s) 输出结果如下：\n小王子 \u0026quot;小王子\u0026quot; e5b08fe78e8be5ad90 E5B08FE78E8BE5AD90 指针    占位符 说明     %p 表示为十六进制，并加上前导的0x    示例代码如下：\na := 10 fmt.Printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;a) fmt.Printf(\u0026quot;%#p\\n\u0026quot;, \u0026amp;a) 输出结果如下：\n0xc000094000 c000094000 宽度标识符 宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：\n   占位符 说明     %f 默认宽度，默认精度   %9f 宽度9，默认精度   %.2f 默认宽度，精度2   %9.2f 宽度9，精度2   %9.f 宽度9，精度0    示例代码如下：\nn := 12.34 fmt.Printf(\u0026quot;%f\\n\u0026quot;, n) fmt.Printf(\u0026quot;%9f\\n\u0026quot;, n) fmt.Printf(\u0026quot;%.2f\\n\u0026quot;, n) fmt.Printf(\u0026quot;%9.2f\\n\u0026quot;, n) fmt.Printf(\u0026quot;%9.f\\n\u0026quot;, n) 输出结果如下：\n12.340000 12.340000 12.34 12.34 12 其他flag    占位符 说明     ’+’ 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；   ’ ‘ 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格   ’-’ 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；   ’#’ 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；   ‘0’ 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；    举个例子：\ns := \u0026quot;小王子\u0026quot; fmt.Printf(\u0026quot;%s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%5s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%-5s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%5.7s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%-5.7s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%5.2s\\n\u0026quot;, s) fmt.Printf(\u0026quot;%05s\\n\u0026quot;, s) 输出结果如下：\n小王子 小王子 小王子 小王子 小王子 小王 00小王子 获取输入 Go语言fmt包下有fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，可以在程序运行过程中从标准输入获取用户的输入。\nfmt.Scan 函数定签名如下：\nfunc Scan(a ...interface{}) (n int, err error)  Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。  具体代码示例如下：\nfunc main() { var ( name string age int married bool ) fmt.Scan(\u0026amp;name, \u0026amp;age, \u0026amp;married) fmt.Printf(\u0026quot;扫描结果 name:%s age:%d married:%t \\n\u0026quot;, name, age, married) } 将上面的代码编译后在终端执行，在终端依次输入小王子、28和false使用空格分隔。\n$ ./scan_demo 小王子 28 false 扫描结果 name:小王子 age:28 married:false fmt.Scan从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。\nfmt.Scanf 函数签名如下：\nfunc Scanf(format string, a ...interface{}) (n int, err error)  Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。 本函数返回成功扫描的数据个数和遇到的任何错误。  代码示例如下：\nfunc main() { var ( name string age int married bool ) fmt.Scanf(\u0026quot;1:%s 2:%d 3:%t\u0026quot;, \u0026amp;name, \u0026amp;age, \u0026amp;married) fmt.Printf(\u0026quot;扫描结果 name:%s age:%d married:%t \\n\u0026quot;, name, age, married) } 将上面的代码编译后在终端执行，在终端按照指定的格式依次输入小王子、28和false。\n$ ./scan_demo 1:小王子 2:28 3:false 扫描结果 name:小王子 age:28 married:false fmt.Scanf不同于fmt.Scan简单的以空格作为输入数据的分隔符，fmt.Scanf为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。\n例如，我们还是按照上个示例中以空格分隔的方式输入，fmt.Scanf就不能正确扫描到输入的数据。\n$ ./scan_demo 小王子 28 false 扫描结果 name: age:0 married:false fmt.Scanln 函数签名如下：\nfunc Scanln(a ...interface{}) (n int, err error)  Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。 本函数返回成功扫描的数据个数和遇到的任何错误。  具体代码示例如下：\nfunc main() { var ( name string age int married bool ) fmt.Scanln(\u0026amp;name, \u0026amp;age, \u0026amp;married) fmt.Printf(\u0026quot;扫描结果 name:%s age:%d married:%t \\n\u0026quot;, name, age, married) } 将上面的代码编译后在终端执行，在终端依次输入小王子、28和false使用空格分隔。\n$ ./scan_demo 小王子 28 false 扫描结果 name:小王子 age:28 married:false fmt.Scanln遇到回车就结束扫描了，这个比较常用。\nbufio.NewReader 有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现。示例代码如下：\nfunc bufioDemo() { reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象 fmt.Print(\u0026quot;请输入内容：\u0026quot;) text, _ := reader.ReadString('\\n') // 读到换行 text = strings.TrimSpace(text) fmt.Printf(\u0026quot;%#v\\n\u0026quot;, text) } Fscan系列 这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据。\nfunc Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) Sscan系列 这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。\nfunc Sscan(str string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) "});index.add({'id':55,'href':'/docs/suanfa/3.%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E8%B7%B3%E8%A1%A8/3.1.%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E8%B7%B3%E8%A1%A8/','title':"3.1.数组链表跳表",'content':"3.1.数组链表跳表 数组 时间复杂度:\n   操作 时间复杂度     查找 O(1)   插入 O(n)   删除 O(n)    链表 时间复杂度:\n   操作 时间复杂度     头部增加 O(1)   尾部增加 O(1)   查找 O(n)   插入 O(1)   删除 O(1)    思想:\n 空间换时间 升维  单链表 node节点有next\n双链表 node节点有next和privious\n循环链表 node节点的next指向头节点\n跳表    操作 时间复杂度     查找 O(logn)    空间复杂度: O(n)\n扩展阅读:\nLRU Cache-Linked list\nhttps://www.jianshu.com/p/b1ab4a170c3c\nhttps://leetcode-cn.com/problems/lru-cache/\nRedis-Skip List\nhttps://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html\nhttps://www.zhihu.com/question/20202931\n"});index.add({'id':56,'href':'/docs/java/4.2.spring/4.2.1.spring/','title':"4.2.1.spring",'content':"4.2.1.spring 核心 Ioc(控制反转)    Di(依赖注入) "});index.add({'id':57,'href':'/docs/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/bug/','title':"bug规则",'content':"bug 规则 研发BUG处理规范  BUG状态及时更新，附BUG状态说明  New - 新创建，该状态P0/P1级别问题不要超过一天，P2不超过2天 Assign - 已分配 Duplicate - 重复bug，通过链接把相关bug link在一起 Invalid - 无效bug Wontfix - 确认是bug，但是无需修复 workaround - 确认是bug，但是可以通过其他方式绕过 Worksforme - 无法复现，需要测试提供更多信息 Fixed - 已修复   BUG及时分配给对应人员，同时写明原因，不是自己处理范围的问题不要挂在自己身上 BUG及时回复，通过文字记录修复过程，避免口口相传  Track过程中阶段性结论 与相关人员沟通的信息   BUG修复，写清楚修复逻辑以及对应build版本号  便于测试理解修复原理 便于后续Review问题    "});index.add({'id':58,'href':'/docs/c++/','title':"C++",'content':"C++ Let\u0026rsquo;s Go, Go Go Go!!!\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':59,'href':'/docs/docker/','title':"docker",'content':"Docker "});index.add({'id':60,'href':'/docs/english/','title':"Englinsh",'content':"英语语法  词类 句子成分 构词法  "});index.add({'id':61,'href':'/docs/go/','title':"Go",'content':"Golang 1.开发环境 2.Golang基础 3.标准库 4.Web开发相关 5.Golang高级 6.Golang源码 7.应用 "});index.add({'id':62,'href':'/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/test/','title':"Go Test 单元测试简明教程",'content':"Go Test 单元测试简明教程 1.如何写好单元测试 单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。\n如何写好单元测试呢？\n首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 mock。\n然后，写可测试的代码。\u0026ldquo;高内聚,低耦合\u0026rdquo; 是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。\n接下来将介绍如何使用 Go 语言的标准库 testing 进行单元测试。\n2.一个简单例子 Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。\nexample/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下:\npackage main func Add(a int, b int) int { return a + b } func Mul(a int, b int) int { return a * b } 那么 calc_test.go 中的测试用例可以这么写：\npackage main import \u0026quot;testing\u0026quot; func TestAdd(t *testing.T) { if ans := Add(1, 2); ans != 3 { t.Errorf(\u0026quot;1 + 2 expected be 3, but %d got\u0026quot;, ans) } if ans := Add(-10, -20); ans != -30 { t.Errorf(\u0026quot;-10 + -20 expected be -30, but %d got\u0026quot;, ans) } }  测试用例名称一般命名为 Test 加上待测试的方法名。 测试用的参数有且只有一个，在这里是 t *testing.T。 基准测试(benchmark)的参数是 *testing.B，TestMain 的参数是 *testing.M 类型。 运行 go test，该 package 下所有的测试用例都会被执行。  $ go test ok example 0.009s 或 go test -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。\n$ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) === RUN TestMul --- PASS: TestMul (0.00s) PASS ok example 0.007s 如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。\n$ go test -run TestAdd -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.007s 3.子测试(Subtests) 子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 t.Run创建不同的子测试用例：\n// calc_test.go func TestMul(t *testing.T) { t.Run(\u0026quot;pos\u0026quot;, func(t *testing.T) { if Mul(2, 3) != 6 { t.Fatal(\u0026quot;fail\u0026quot;) } }) t.Run(\u0026quot;neg\u0026quot;, func(t *testing.T) { if Mul(2, -3) != -6 { t.Fatal(\u0026quot;fail\u0026quot;) } }) }  之前的例子测试失败时使用 t.Error/t.Errorf，这个例子中使用 t.Fatal/t.Fatalf，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。  运行某个测试用例的子测试：\n$ go test -run TestMul/pos -v === RUN TestMul === RUN TestMul/pos --- PASS: TestMul (0.00s) --- PASS: TestMul/pos (0.00s) PASS ok example 0.008s 对于多个子测试的场景，更推荐如下的写法(table-driven tests)：\n// calc_test.go func TestMul(t *testing.T) { cases := []struct { Name string A, B, Expected int }{ {\u0026quot;pos\u0026quot;, 2, 3, 6}, {\u0026quot;neg\u0026quot;, 2, -3, -6}, {\u0026quot;zero\u0026quot;, 2, 0, 0}, } for _, c := range cases { t.Run(c.Name, func(t *testing.T) { if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026quot;%d * %d expected %d, but %d got\u0026quot;, c.A, c.B, c.Expected, ans) } }) } } 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：\n 新增用例非常简单，只需给 cases 新增一条测试数据即可。 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。 用例失败时，报错信息的格式比较统一，测试报告易于阅读。  如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。\n4.帮助函数(helpers) 对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。\n例如，我们可以将创建子测试的逻辑抽取出来：\n// calc_test.go package main import \u0026quot;testing\u0026quot; type calcCase struct{ A, B, Expected int } func createMulTestCase(t *testing.T, c *calcCase) { // t.Helper() if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026quot;%d * %d expected %d, but %d got\u0026quot;, c.A, c.B, c.Expected, ans) } } func TestMul(t *testing.T) { createMulTestCase(t, \u0026amp;calcCase{2, 3, 6}) createMulTestCase(t, \u0026amp;calcCase{2, -3, -6}) createMulTestCase(t, \u0026amp;calcCase{2, 0, 1}) // wrong case } 在这里，我们故意创建了一个错误的测试用例，运行 go test，用例失败，会报告错误发生的文件和行号信息：\n$ go test --- FAIL: TestMul (0.00s) calc_test.go:11: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.007s 可以看到，错误发生在第11行，也就是帮助函数 createMulTestCase 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 t.Helper()，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。\n修改 createMulTestCase，调用 t.Helper()\nfunc createMulTestCase(c *calcCase, t *testing.T) { t.Helper() t.Run(c.Name, func(t *testing.T) { if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026quot;%d * %d expected %d, but %d got\u0026quot;, c.A, c.B, c.Expected, ans) } }) } 运行 go test，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。\n$ go test --- FAIL: TestMul (0.00s) calc_test.go:20: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.006s 关于 helper 函数的 2 个建议：\n 不要返回错误， 帮助函数内部直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。 调用 t.Helper() 让报错信息更准确，有助于定位。  5.setup 和 teardown 如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 testing 提供了这样的机制：\nfunc setup() { fmt.Println(\u0026quot;Before all tests\u0026quot;) } func teardown() { fmt.Println(\u0026quot;After all tests\u0026quot;) } func Test1(t *testing.T) { fmt.Println(\u0026quot;I'm test1\u0026quot;) } func Test2(t *testing.T) { fmt.Println(\u0026quot;I'm test2\u0026quot;) } func TestMain(m *testing.M) { setup() code := m.Run() teardown() os.Exit(code) }  在这个测试文件中，包含有2个测试用例，Test1 和 Test2。 如果测试文件中包含函数 TestMain，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。 调用 m.Run() 触发所有测试用例的执行，并使用 os.Exit() 处理返回的状态码，如果不为0，说明有用例失败。 因此可以在调用 m.Run() 前后做一些额外的准备(setup)和回收(teardown)工作。  执行 go test，将会输出\n$ go test Before all tests I'm test1 I'm test2 PASS After all tests ok example 0.006s 6.网络测试(Network) 6.1 TCP/HTTP 假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler\nfunc helloHandler(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026quot;hello world\u0026quot;)) } 那我们可以创建真实的网络连接进行测试：\n// test code import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;net\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;testing\u0026quot; ) func handleError(t *testing.T, err error) { t.Helper() if err != nil { t.Fatal(\u0026quot;failed\u0026quot;, err) } } func TestConn(t *testing.T) { ln, err := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;127.0.0.1:0\u0026quot;) handleError(t, err) defer ln.Close() http.HandleFunc(\u0026quot;/hello\u0026quot;, helloHandler) go http.Serve(ln, nil) resp, err := http.Get(\u0026quot;http://\u0026quot; + ln.Addr().String() + \u0026quot;/hello\u0026quot;) handleError(t, err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) handleError(t, err) if string(body) != \u0026quot;hello world\u0026quot; { t.Fatal(\u0026quot;expected hello world, but got\u0026quot;, string(body)) } }  net.Listen(\u0026ldquo;tcp\u0026rdquo;, \u0026ldquo;127.0.0.1:0\u0026rdquo;)：监听一个未被占用的端口，并返回 Listener。 调用 http.Serve(ln, nil) 启动 http 服务。 使用 http.Get 发起一个 Get 请求，检查返回值是否正确。 尽量不对 http 和 net 库使用 mock，这样可以覆盖较为真实的场景。  6.2 httptest 针对 http 开发的场景，使用标准库 net/http/httptest 进行测试更为高效。\n上述的测试用例改写如下：\n// test code import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;net/http/httptest\u0026quot; \u0026quot;testing\u0026quot; ) func TestConn(t *testing.T) { req := httptest.NewRequest(\u0026quot;GET\u0026quot;, \u0026quot;http://example.com/foo\u0026quot;, nil) w := httptest.NewRecorder() helloHandler(w, req) bytes, _ := ioutil.ReadAll(w.Result().Body) if string(bytes) != \u0026quot;hello world\u0026quot; { t.Fatal(\u0026quot;expected hello world, but got\u0026quot;, string(bytes)) } } 使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。\n7.Benchmark 基准测试 基准测试是指通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量的和可对比的测试。\n基准测试用例的定义如下：\nfunc BenchmarkName(b *testing.B){ // ... }  函数名必须以 Benchmark 开头，后面一般跟待测试的函数名 参数为 b *testing.B。 执行基准测试时，需要添加 -bench 参数。  例如：\nfunc BenchmarkHello(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026quot;hello\u0026quot;) } } $ go test -benchmem -bench . ... BenchmarkHello-16 15991854 71.6 ns/op 5 B/op 1 allocs/op ... 基准测试报告每一列值对应的含义如下：\ntype BenchmarkResult struct { N int // 迭代次数 T time.Duration // 基准测试花费的时间 Bytes int64 // 一次迭代处理的字节数 MemAllocs uint64 // 总的分配内存的次数 MemBytes uint64 // 总的分配内存的字节数 } 如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：\nfunc BenchmarkHello(b *testing.B) { ... // 耗时操作 b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026quot;hello\u0026quot;) } } 使用 RunParallel 测试并发性能\nfunc BenchmarkParallel(b *testing.B) { templ := template.Must(template.New(\u0026quot;test\u0026quot;).Parse(\u0026quot;Hello, {{.}}!\u0026quot;)) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { // 所有 goroutine 一起，循环一共执行 b.N 次 buf.Reset() templ.Execute(\u0026amp;buf, \u0026quot;World\u0026quot;) } }) } $ go test -benchmem -bench . ... BenchmarkParallel-16 3325430 375 ns/op 272 B/op 8 allocs/op ... 附 参考  https://golang.org/pkg/testing/  "});index.add({'id':63,'href':'/docs/java/','title':"java",'content':"Java https://www.bilibili.com/video/BV1zz4y197wF/?spm_id_from=333.788.videocard.1\n"});index.add({'id':64,'href':'/docs/kafka/','title':"kafka",'content':"kafka "});index.add({'id':65,'href':'/docs/linux/1.linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/','title':"Linux命令行快捷键",'content':"Linux命令行快捷键 涉及在linux命令行下进行快速移动光标、命令编辑、编辑后执行历史命令、Bang(!)命令、控制命令等。让basher更有效率。\n常用 ctrl+左右键:在单词之间跳转 * ctrl+a:跳到本行的行首 * ctrl+e:跳到页尾 Ctrl+u：删除当前光标前面的文字 （还有剪切功能） ctrl+k：删除当前光标后面的文字(还有剪切功能) Ctrl+L：进行清屏操作 Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容 Ctrl+w:删除光标前面的单词的字符 Alt – d ：由光标位置开始，往右删除单词。往行尾删 说明 Ctrl – k: 先按住 Ctrl 键，然后再按 k 键； Alt – k: 先按住 Alt 键，然后再按 k 键； M – k：先单击 Esc 键，然后再按 k 键。 移动光标 Ctrl – a ：移到行首 Ctrl – e ：移到行尾 Ctrl – b ：往回(左)移动一个字符 Ctrl – f ：往后(右)移动一个字符 Alt – b ：往回(左)移动一个单词 Alt – f ：往后(右)移动一个单词 Ctrl – xx ：在命令行尾和光标之间移动 M-b ：往回(左)移动一个单词 M-f ：往后(右)移动一个单词 编辑命令 Ctrl – h ：删除光标左方位置的字符 Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端） Ctrl – w ：由光标位置开始，往左删除单词。往行首删 Alt – d ：由光标位置开始，往右删除单词。往行尾删 M – d ：由光标位置开始，删除单词，直到该单词结束。 Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。 Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。 Ctrl – y ：粘贴之前删除的内容到光标后。 ctrl – t ：交换光标处和之前两个字符的位置。 Alt + . ：使用上一条命令的最后一个参数。 Ctrl – _ ：回复之前的状态。撤销操作。 Ctrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。 Bang(!)命令 !! ：执行上一条命令。 ^foo^bar ：把上一条命令里的foo替换为bar，并执行。 !wget ：执行最近的以wget开头的命令。 !wget:p ：仅打印最近的以wget开头的命令，不执行。 !$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。 !* ：上一条命令的所有参数 !*:p ：打印上一条命令是所有参数，也即 !*的内容。 ^abc ：删除上一条命令中的abc。 ^foo^bar ：将上一条命令中的 foo 替换为 bar ^foo^bar^ ：将上一条命令中的 foo 替换为 bar !-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5 查找历史命令 Ctrl – p ：显示当前命令的上一条历史命令 Ctrl – n ：显示当前命令的下一条历史命令 * Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。 Ctrl – g ：从历史搜索模式（Ctrl – r）退出。 控制命令 Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。 Ctrl – o ：执行当前命令，并选择上一条命令。 Ctrl – s ：阻止屏幕输出 Ctrl – q ：允许屏幕输出 Ctrl – c ：终止命令 Ctrl – z ：挂起命令 重复执行操作动作 M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。 "});index.add({'id':66,'href':'/docs/linux/%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/linux%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E6%9F%90%E4%B8%AA%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/','title':"Linux如何关闭某个占用端口的进程",'content':"Linux如何关闭某个占用端口的进程 1）查找被占用的端口: netstat -tln | grep 8000 tcp 0 0 192.168.2.106:8000 0.0.0.0:* LISTEN 2）查看被占用端口的PID： sudo lsof -i:8000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nginx 850 root 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) nginx 851 www-data 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) nginx 852 www-data 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) 3）kill掉该进程\nsudo kill -9 850 "});index.add({'id':67,'href':'/docs/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':68,'href':'/docs/git/2.%E8%BF%9B%E9%98%B6/0.reset%E5%91%BD%E4%BB%A4%E5%B0%86%E4%BB%93%E5%BA%93%E8%AE%B0%E5%BD%95%E5%92%8C%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E5%8E%86%E5%8F%B2%E4%BD%8D%E7%BD%AE/','title':"reset命令:将仓库记录和恢复指定历史位置",'content':"0.reset命令:将仓库记录和恢复指定历史位置 有时候我们用 git commit 提交代码后发现这一次提交的内容是错误的，需要将代码复原，这个时候常见有两种做法。\n第一种是把代码错误内容修改正确，然后重新使用 commit 提交一次； 这种情况会多2条log记录\n第二种方法是使用 git reset 命令撤销上一次错误的 commit 记录。 git reset HEAD^ # 撤销我们最近一次提交 git reset 815ac616803fa89c75467618b2be44f85696543d # 指定回滚位置, commitid git reset 815ac616803fa89c75467618b2be44f85696543d filename # 回滚某个文件到某次提交 "});index.add({'id':69,'href':'/docs/rust/','title':"Rust",'content':"Rust "});index.add({'id':70,'href':'/docs/shell/shell%E5%9F%BA%E7%A1%80/','title':"shell基础",'content':"shell基础 shell是命令行解析器 关系: 内存-\u0026gt; shell -\u0026gt; 用户  shell概述 脚本执行方法 Bash的基本功能 "});index.add({'id':71,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml%E5%9B%BE/%E7%B1%BB%E5%9B%BE%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7/','title':"UML",'content':"UML类图 1.类图基础属性   +表示public -表示private #表示protected ~表示default,也就是包权限 _下划线表示static 斜体表示抽象  2.类与类之间关系 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)\n泛化 介绍： 泛化(Generalization)表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系\n(1) 继承\n介绍：\n继承表示是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。 表示方法：\n继承使用空心三角形+实线表示。\n示例：\n鸟类继承抽象类动物\n （2）实现\n介绍：\n实现表示一个class类实现interface接口（可以是多个）的功能。\n表示方法：\n1）矩形表示法\n使用空心三角形+虚线表示\n比如：大雁需要飞行，就要实现飞()接口\n 2）棒棒糖表示法\n使用实线表示\n 依赖 介绍：\n对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。\n表示方法：\n依赖关系用虚线箭头表示。\n示例：\n动物依赖氧气和水。调用新陈代谢方法需要氧气类与水类的实例作为参数\n 关联 介绍：\n对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。\n表示方法：\n关联关系用实线箭头表示。\n示例：\n企鹅需要‘知道’气候的变化，需要‘了解’气候规律。当一个类‘知道’另一个类时，可以用关联。\n 聚合 介绍：\n表示一种弱的‘拥有’关系，即has-a的关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 两个对象具有各自的生命周期。\n表示方法：\n聚合关系用空心的菱形+实线箭头表示。\n示例：\n每一只大雁都属于一个大雁群，一个大雁群可以有多只大雁。当大雁死去后大雁群并不会消失，两个对象生命周期不同。\n 组合 介绍：\n组合是一种强的‘拥有’关系，是一种contains-a的关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。\n表示方法：\n组合关系用实心的菱形+实线箭头表示，还可以使用连线两端的数字表示某一端有几个实例。\n示例：\n鸟和翅膀就是组合关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。\n "});index.add({'id':72,'href':'/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/','title':"什么是数据结构",'content':"什么是数据结构 数据结构，直白地理解，就是研究数据的存储方式。\n"});index.add({'id':73,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/','title':"变量\u0026常量",'content':"变量\u0026amp;常量 变量 1、显式的完整声明 var varName dataType [ = value] 说明: 关键字var用于变量声明 varName 是变量名称标识符 dataType 数据类型 value 初始化值 例子: var a int = 1 2、短类型声明 varName := value := 声明只能出现在函数内（包括在方法内） 此时Go编译器自动进行数据类型推断 a, b := 1, \u0026quot;hello\u0026quot;  常量 const a = 1 const ( a = iota ) "});index.add({'id':74,'href':'/docs/datas_tructure/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/','title':"垃圾回收算法",'content':"常见垃圾回收算法   引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。\n 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。 代表语言：Python、PHP、Swift    标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为\u0026quot;被引用\u0026rdquo;，没有被标记的进行回收。\n 优点：解决了引用计数的缺点。 缺点：需要STW，即要暂时停掉程序运行。 代表语言：Golang(其采用三色标记法)    分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。\n 优点：回收性能好 缺点：算法复杂 代表语言： JAVA    "});index.add({'id':75,'href':'/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F/','title':"复杂度",'content':"复杂度 复杂度是衡量代码运行效率的重要的度量因素，复杂度通常包括时间复杂度和空间复杂度\n复杂度特性:  复杂度与具体的常系数无关 多项式级的复杂度相加的时候，选择高者作为结果 O(1) 也是表示一个特殊复杂度, 与输入数据量n无关  复杂度的经验结论  一个顺序结构的代码，时间复杂度是O(1) 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度是O(logn). 一个简单的for循环，时间复杂度是O(n) 两个顺序执行的for循环,时间复杂度是O(n)+O(n)=O(2n),其实也是O(n) 两个嵌套的for循环, 时间复杂度是O(n2)  总结 时间复杂度与\u0026laquo;代码的结构设计\u0026raquo;高度相关\n空间复杂度与\u0026laquo;数据结构的选择\u0026raquo;高度相关\n"});index.add({'id':76,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E7%AC%A6%E4%B8%B2/','title':"字符串",'content':"字符串 "});index.add({'id':77,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/','title':"字符串操作",'content':"字符串操作 "});index.add({'id':78,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/%E5%AE%B9%E9%94%99%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E7%81%BE%E5%A4%87/','title':"容错，高可用和灾备",'content':"容错，高可用和灾备 容错 容错（fault tolerance）指的是， 发生故障时，系统还能继续运行。\n飞机有四个引擎，如果一个引擎坏了，剩下三个引擎，还能继续飞，这就是\u0026quot;容错\u0026rdquo;。同样的，汽车的一个轮子扎破了，剩下三个轮子，也还是勉强能行驶。\n容错的目的是，发生故障时，系统的运行水平可能有所下降，但是依然可用，不会完全失败。\n高可用 高可用（high availability）指的是， 系统能够比正常时间更久地保持一定的运行水平。\n汽车的备胎就是一个高可用的例子。如果没有备胎，轮胎坏了，车就开不久了。备胎延长了汽车行驶的可用时间。\n注意，高可用不是指系统不中断（那是容错能力），而是指一旦中断能够快速恢复，即中断必须是短暂的。如果需要很长时间才能恢复可用性，就不叫高可用了。上面例子中，更换备胎就必须停车，但只要装上去，就能回到行驶状态。\n灾备 灾备（又称灾难恢复，disaster recovery）指的是， 发生灾难时恢复业务的能力。\n上图中，飞机是你的 IT 基础设施，飞行员是你的业务，飞行员弹射装置就是灾备措施。一旦飞机即将坠毁，你的基础设施就要没了，灾备可以让你的业务幸存下来。\n灾备的目的就是，保存系统的核心部分。一个好的灾备方案，就是从失败的基础设施中获取企业最宝贵的数据，然后在新的基础设施上恢复它们。注意，灾备不是为了挽救基础设置，而是为了挽救业务。\n总结 上面三个方面可以结合起来，设计一个可靠的系统。\n 容错：发生故障时，如何让系统继续运行。 高可用：系统中断时，如何尽快恢复。 灾备：系统毁灭时，如何抢救数据。  "});index.add({'id':79,'href':'/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E6%A0%88%E9%80%83%E9%80%B8/','title':"栈逃逸",'content':"栈逃逸 "});index.add({'id':80,'href':'/docs/git/2.%E8%BF%9B%E9%98%B6/1.%E6%B8%85%E7%90%86%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%88%86%E6%94%AF%E6%95%B0%E6%8D%AE/','title':"清理无意义的分支数据",'content':"清理无意义的分支数据  本地不存在，远程存在该分支，但不需要了 远程不存在，本地存在该分支，也不需要了  清理远程分支 1. 查看分支, 远程分支显示红色 git branch -a remotes/origin/dev 2. 执行命令 git push origin --delete dev 清理本地分支 1. 模拟场景 git checkout -b test6 2. 查看当前版本库的分支 git branch -a 3. 将分支推送到远程服务器中 git push --set-upstream origin test6 4. 查看远程分支的信息 git remote show origin 5. 删除远程分支 git push origin --delete test1 "});index.add({'id':81,'href':'/docs/mysql/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/','title':"环境搭建",'content':"环境搭建 Mac版环境搭建 安装 brew install mysql 安装完后启动mysql mysql.server start 执行安全设置 mysql_secure_installation "});index.add({'id':82,'href':'/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/','title':"环境搭建",'content':"环境搭建 安装 1、 安装rustup $ curl https://sh.rustup.rs -sSf | sh 2、执行 $ source $HOME/.cargo/env 更新 $ rustup update 卸载Rust和rustup $ rustup self uninstall 故障排除 $ rustc --version # 看到rustc x.y.z (abcabcabc yyyy-mm-dd)表示安装成功 恭喜入坑！ "});index.add({'id':83,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/1.%E7%AE%80%E4%BB%8B/','title':"简介",'content':"简介 软件包分类  源码包  脚本安装包   二进制包(RPM包、系统默认包)  "});index.add({'id':84,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/','title':"网络基础",'content':"网络基础 1.iso/osi七层模型 7 应用层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-应用层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 应用层 APDU(应用协议数据单元)\n6 表示层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-表示层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 表示层 PPDU(表示协议数据单元) 5 会话层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-会话层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 会话层 SPDU(会话协议数据单元) 4 传输层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-传输层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 传输层 TPDU(传输协议数据单元)\n3 网络层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-网络层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 网络层 报文 2 数据链路层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-数据链路层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 数据链路层 帧 1 物理层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-物理层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 物理层 比特\nMAC地址负责局域网通信\nIP地址负责外网通信\n物理层: 设备之间的比特流的传输、物理接口、电气特征等\n数据链路层: 成帧、用MAC地址访问媒介、错误检测与修正\n网络层: 提供逻辑地址、选路\n传输层: 可靠与不可靠的传输、传输前的错误检测、流控\n会话层: 对应用会话的管理、同步\n表示层: 数据的表示形式、特定功能的实现如-加密\n应用层: 用户接口\n2.Tcp/Ip四层模型  应用层 \u0026mdash;\u0026gt; (应用层, 表示层, 会话层) 传输层 \u0026mdash;\u0026gt; (传输层) 网际互联层 \u0026mdash;-\u0026gt; (网络层) 网络接口层 \u0026mdash;-\u0026gt; (物理层, 数据链路层)  网络接口层: 网络接入层是OSI参数模型中的物理层和数据链路层相对应.它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议,而 由参与互连的各网络使用自己的物理层和数据链路层协议, 然后与TCP/IP的网络接入层进行连接. ** 地址解析协议(ARP)工作在此层，即OSI参考模型的数据链路层。\n网际互联层: 网际互联层对应于OSI参考模型的网络层,主要解决主机到主机的通信问题. 它所包含的协议设计数据包在整个网络上的逻辑传输 。改层有三个主要协议: 网际协议(IP)、互联网组管理协议(IGMP) 和互联网控制报文协议(ICMP)\n传输层: 传输层对应于OSI参考模型的传输层, 为应用层实体提供端到端的通信功能, 保证了数据包的顺序传送及数据的完整性, 该层定义了两个主要的协议: 传输控制协议(TCP) 和用户数据报协议(UDP).\n应用层: 应用层对应于OSI参考模型的高层, 为用户提供所需要的各种服务, 例如:FTP、Telnet, DNS, SMTP等.\n数据封装过程               应用数据      字节流(数据)   应用层     FTP头 字节流(数据)   传输层    TCP头 FTP头 字节流(数据)   网络层   IP头 TCP头 FTP头 字节流(数据)   数据链路层  以太帧头 IP头 TCP头 FTP头 字节流(数据)    TCP/IP模型与OSI模型的比较  共同点\n1、OSI参考模型和TCP/IP参考模型都采用了层次结构的概念 2、都能够提供面向连接和无连接两种通信服务机制 不同点\n1、前者是七层模型, 后者是四层结构 2、对可靠性要求不同(后者更高)\n3、OSI模型是在协调开发前设计的,具有通用性.TCP/IP是先有协议集然后建立模型, 不适用于非TCP/IP网络\n4、实际市场应用不同(OSI模型只是理论上的模型), 并没有成熟的产品，而TCP/IP已经成为\u0026quot;实际上的国际标准\u0026rdquo;  3.IP地址 IP报文    0  15 16 31     版本(4)) 头部长度(4) 优先级和服务类型(8) 总长度(16)    标识(16)   标志(3) 偏移量(13)   生存时间(8)  协议(8) 头部校验和(16)      源IP地址(32)       目的IP地址(32)       选项(如果有)       数据      注: 字段后面括号中的数字是指该字段在ip数据包头部信息中所占的位数\nIP地址分类    网络类别 最大网络数 IP地址范围 最大主机数 私有IP地址范围     A 2^7-2 1.0.0.0 - 126.255.255.255 2^24-2 10.0.0.0 - 10.255.255.255   B 2^14 128.0.0.0 - 191.255.255.255 2^16-2 127.16.0.0 - 172.31.255.255   C 2^21 192.0.0.0 - 223.255.255.255 2^8-2 192.168.0.0 - 192.168.255.255    4.子网掩码 255.255.255.0 C类标准网段\n26 另外一种子网掩码的表示\n5.端口作用 TCP协议包头    0  15 16 31     源端口(16))   目的端口(16)      序列号(32)       确认号(32)     数据偏移(4) 保留(6) 标识(13)     校验和(16))   紧急指针(16)      选项       数据      注: 字段后面括号中的数字是指该字段在TCP头部信息中所占的位数\nUDP协议包头    0 15 16 31     源端口(16)  目的端口(16)    长度(16)  校验和(16)      数据     注: 字段后面括号中的数字是指该字段在UDP头部信息中所占的位数\n端口范围: 0-65535 1万以内的端口系统用，以外自己用\n查看本机启用的端口 netstat -an 选项:\n-a: 查看所有连接和监听端口\n-n: 显示IP地址和端口号，而不显示域名和服务名\n6.DNS作用 DNS: 域名系统\n 在互联网中, 通过IP地址来进行通信 IP地址用数字表示, 挤一起来台困难了 人对域名跟家敏感  DNS服务的作用: 将域名解析为IP地址\n域名空间结构  \u0026ldquo;.\u0026rdquo; 根域 根域名的服务器只有13台 顶级域: (组织域, 国家或地区域) 二级域 主机名  7.网关作用 网关作用  网关(Gateway)又称网间连接器、协议转换器 网关在网络层以上实现网络互连,是最复杂的网络互连设备, 仅用于两个高层协议不同的网络互连 网关既可以用于广域网互连, 也可以用于局域网互连。 网关是一种充当转换重任的服务器或路由器  "});index.add({'id':85,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/02%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/','title':"进程与线程的一个简单解释",'content':"进程与线程的一个简单解释 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。\n最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。\n 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。\n 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。\n 一个车间里，可以有很多工人。他们协同完成一个任务。\n 线程就好比车间里的工人。一个进程可以包括多个线程。\n 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。\n 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。\n 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫\u0026quot;互斥锁\u0026rdquo;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。\n 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。\n 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做\u0026quot;信号量\u0026rdquo;（Semaphore），用来保证多个线程不会互相冲突。\n不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。\n 操作系统的设计，因此可以归结为三点：\n（1）以多进程形式，允许多个任务同时运行；\n（2）以多线程形式，允许单个任务分成不同的部分运行；\n（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。\n"});index.add({'id':86,'href':'/docs/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/','title':"项目管理",'content':"项目管理 "});index.add({'id':87,'href':'/docs/datas_tructure/%E7%BA%BF/','title':"线",'content':"线 "});index.add({'id':88,'href':'/docs/git/2.%E8%BF%9B%E9%98%B6/','title':"2.进阶",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n 程序基础 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':89,'href':'/docs/git/3.%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/','title':"3.团队协作",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n 程序基础 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':90,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/','title':"2.2.基本数据类型",'content':"2.2.基本数据类型  2.2.1. 整型 2.2.2. 浮点型 2.2.3. 复数 2.2.4. 布尔值 2.2.5. 字符串 2.2.6. byte和rune类型 2.2.7. 类型转换  "});index.add({'id':91,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/','title':"2. Golang基础",'content':"2.Golang基础  2.1 变量和常量 2.2 基本数据类型 2.3 运算符 2.4 流程控制 2.5 数组 2.6 切片 2.7 amp 2.8 函数 2.9 指针 2.10 结构体 2.11 包 2.12 接口 2.13 反射 2.14 并发 2.15 网络编程 2.16 单元测试  "});index.add({'id':92,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/','title':"基础篇",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n 程序基础 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':93,'href':'/docs/python/','title':"Python",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':94,'href':'/docs/python/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/','title':"必备知识",'content':"必备知识  IO操作 进程和线程 虚拟环境 更加python的python代码风格  "});index.add({'id':95,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/2.%E5%87%86%E5%A4%87%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/','title':"2.准备与复杂度分析",'content':"2.准备与复杂度分析 算法网站 https://leetcode-cn.com/\nhttps://leetcode.com/ 主要看discuss最好票的3个评论\n时间复杂度\u0026amp;空间复杂度  "});index.add({'id':96,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.2.%E6%A0%87%E8%AF%86%E7%AC%A6/','title':"1.2.2 标识符",'content':"1.2.2 标识符 标识符就是用于给 Java 程序中变量、类、方法等命名的符号\n 使用标识符时，需要遵守几条规则：\n  标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法滴\n  标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以\n  标识符是严格区分大小写的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！\n  标识符的命名最好能反映出其作用，做到见名知意。\n  "});index.add({'id':97,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.2.%E4%BB%A3%E8%AF%8D/','title':"1.2.代词",'content':"1.2.代词 代词分类 一、人称代词 人称代词代替任何事物的名词,分为主格和宾格两种形式\n 1.主格: 用来作句子的主语,表语 Are they from Brazil?\nWhere have they gone?\nit\u0026rsquo;s he!\n2.宾格: 用来作及物动词或者介词的宾语 who teaches you English this year?\nwho often write letters to her\n3.主/宾格 人称代词作表语或放比较状语从句连词than或as之后, 可用主格形式/宾语形式\nwho is it?\nit\u0026rsquo;s I/me\n4.顺序 人称代词顺序: \u0026ldquo;you-\u0026gt;he_\u0026gt;I\u0026rdquo;\nBoth he and i are working at that computer company\nwho will go there? You and me\n5.it 指人/指物\n表示\u0026quot;时间、天气、温度、距离、情况\u0026quot;等含义\n作形式主语/宾语: 替代作主语或宾语的不定式、动名词或名词性从句\nwhat\u0026rsquo;s the weather like today?\nlt\u0026lsquo;s fine\n二、物主代词 1.形容词性物主代词 2.名词性物主代词 3.双重所有格 00:35:13 ️三、反身代词 ️四、指示代词 ️五、关系代词 六、疑问代词 七、连接代词 八、不定代词\n第三章 08:50\n"});index.add({'id':98,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.2.%E4%BD%BF%E7%94%A8git%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%B0%E6%9C%AC%E5%9C%B0/','title':"1.2.使用Git命令下载远程仓库到本地",'content':"1.2.使用Git命令下载远程仓库到本地 HTTP(S)获取远程仓库 首次拉取 git clone 版本库地址\t[本地文件夹名称]\n更新代码 git pull\n临时记住密码  git config –-global credential.helper cache #默认缓存15分钟 git config credential.helper \u0026lsquo;cache –timeout=3600\u0026rsquo; #自定义配置记住 1 小时的命令  永久记住密码 git config \u0026ndash;global credential.helper store\n修改配置文件.gitconfig\n[credential] helper = store 在上面的命令中，如果没有\u0026ndash;global，则会在当前项目下的.git/config文件增加配置\nSSH拉取 git clone git@gitee.com:xxx/xxxx.git xxxx\n创建一个ssh key 执行命令: ssh-keygen 之后一直回车\n查看公钥 cat ~/.ssh/id_rsa.pub\n添加公钥到服务器 把公钥粘贴上去\n"});index.add({'id':99,'href':'/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.2.%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/','title':"1.2.国内镜像配置",'content':"1.2.国内镜像配置 Go 1.13及以上(推荐) 打开你的终端并执行: go env -w GOPROXY=https://goproxy.cn,direct  Go module 打开你的终端并执行: go env -w GO111MODULE=on  go imports go imports包的引入可以让代码书写变得更加快捷 $ go get -v golang.org/x/tools/cmd/goimports  "});index.add({'id':100,'href':'/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.2.switch/','title':"1.4.2 switch",'content':"1.4.2 switch switch  "});index.add({'id':101,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.2.%E5%8F%98%E9%87%8F/','title':"2.1.2.变量",'content':"2.1.2.变量 变量的来历 程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。\n变量类型 变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。\nGo语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。\n变量声明 Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。\n标准声明 Go语言的变量声明格式为：\nvar 变量名 变量类型 变量声明以关键字var开头，变量类型放在变量的后面，行尾无需分号。 举个例子：\nvar name string var age int var isOk bool 批量声明 每声明一个变量就需要写var关键字会比较繁琐，go语言中还支持批量变量声明：\nvar ( a string b int c bool d float32 ) 变量的初始化 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。\n当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：\nvar 变量名 类型 = 表达式 举个例子：\nvar name string = \u0026quot;Q1mi\u0026quot; var age int = 18 或者一次初始化多个变量\nvar name, age = \u0026quot;Q1mi\u0026quot;, 20 类型推导 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。\nvar name = \u0026quot;Q1mi\u0026quot; var age = 18 短变量声明 在函数内部，可以使用更简略的 := 方式声明并初始化变量。\npackage main import ( \u0026quot;fmt\u0026quot; ) // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m fmt.Println(m, n) } 匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如：\nfunc foo() (int, string) { return 10, \u0026quot;Q1mi\u0026quot; } func main() { x, _ := foo() _, y := foo() fmt.Println(\u0026quot;x=\u0026quot;, x) fmt.Println(\u0026quot;y=\u0026quot;, y) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)\n注意事项  函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。  "});index.add({'id':102,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.2.%E5%B0%81%E8%A3%85/','title':"2.1.2.封装",'content':"2.1.2.封装 修饰符 public\nprotecd\nprivate\nthis修饰符  this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 封装对象的属性的时候,经常会使用this关键字  "});index.add({'id':103,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.2.%E7%BB%93%E6%9E%84%E4%BD%93/','title':"2.10.2.结构体",'content':"2.10.2.结构体 Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。\nGo语言中通过struct来实现面向对象。\n结构体定义 使用type和struct关键字来定义结构体，具体代码格式如下：\ntype 类型名 struct { 字段名 字段类型 字段名 字段类型 … } 其中：\n 类型名：标识自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。  举个例子，我们定义一个Person（人）结构体，代码如下：\ntype person struct { name string city string age int8 } 同样类型的字段也可以写在一行，\ntype person1 struct { name, city string age int8 } 这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。\n语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型\n结构体实例化 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。\n结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。\nvar 结构体实例 结构体类型 基本实例化 举个例子：\ntype person struct { name string city string age int8 } func main() { var p1 person p1.name = \u0026quot;沙河娜扎\u0026quot; p1.city = \u0026quot;北京\u0026quot; p1.age = 18 fmt.Printf(\u0026quot;p1=%v\\n\u0026quot;, p1) //p1={沙河娜扎 北京 18} fmt.Printf(\u0026quot;p1=%#v\\n\u0026quot;, p1) //p1=main.person{name:\u0026quot;沙河娜扎\u0026quot;, city:\u0026quot;北京\u0026quot;, age:18} } 我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。\n匿名结构体 在定义一些临时数据结构等场景下还可以使用匿名结构体。\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { var user struct{Name string; Age int} user.Name = \u0026quot;小王子\u0026quot; user.Age = 18 fmt.Printf(\u0026quot;%#v\\n\u0026quot;, user) } 创建指针类型结构体 我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：\nvar p2 = new(person) fmt.Printf(\u0026quot;%T\\n\u0026quot;, p2) //*main.person fmt.Printf(\u0026quot;p2=%#v\\n\u0026quot;, p2) //p2=\u0026amp;main.person{name:\u0026quot;\u0026quot;, city:\u0026quot;\u0026quot;, age:0} 从打印的结果中我们可以看出p2是一个结构体指针。\n需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。\nvar p2 = new(person) p2.name = \u0026quot;小王子\u0026quot; p2.age = 28 p2.city = \u0026quot;上海\u0026quot; fmt.Printf(\u0026quot;p2=%#v\\n\u0026quot;, p2) //p2=\u0026amp;main.person{name:\u0026quot;小王子\u0026quot;, city:\u0026quot;上海\u0026quot;, age:28} 取结构体的地址实例化 使用\u0026amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。\np3 := \u0026amp;person{} fmt.Printf(\u0026quot;%T\\n\u0026quot;, p3) //*main.person fmt.Printf(\u0026quot;p3=%#v\\n\u0026quot;, p3) //p3=\u0026amp;main.person{name:\u0026quot;\u0026quot;, city:\u0026quot;\u0026quot;, age:0} p3.name = \u0026quot;七米\u0026quot; p3.age = 30 p3.city = \u0026quot;成都\u0026quot; fmt.Printf(\u0026quot;p3=%#v\\n\u0026quot;, p3) //p3=\u0026amp;main.person{name:\u0026quot;七米\u0026quot;, city:\u0026quot;成都\u0026quot;, age:30} p3.name = \u0026ldquo;七米\u0026quot;其实在底层是(*p3).name = \u0026ldquo;七米\u0026rdquo;，这是Go语言帮我们实现的语法糖。\n结构体初始化 没有初始化的结构体，其成员变量都是对应其类型的零值。\ntype person struct { name string city string age int8 } func main() { var p4 person fmt.Printf(\u0026quot;p4=%#v\\n\u0026quot;, p4) //p4=main.person{name:\u0026quot;\u0026quot;, city:\u0026quot;\u0026quot;, age:0} } 使用键值对初始化 使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。\np5 := person{ name: \u0026quot;小王子\u0026quot;, city: \u0026quot;北京\u0026quot;, age: 18, } fmt.Printf(\u0026quot;p5=%#v\\n\u0026quot;, p5) //p5=main.person{name:\u0026quot;小王子\u0026quot;, city:\u0026quot;北京\u0026quot;, age:18} 也可以对结构体指针进行键值对初始化，例如：\np6 := \u0026amp;person{ name: \u0026quot;小王子\u0026quot;, city: \u0026quot;北京\u0026quot;, age: 18, } fmt.Printf(\u0026quot;p6=%#v\\n\u0026quot;, p6) //p6=\u0026amp;main.person{name:\u0026quot;小王子\u0026quot;, city:\u0026quot;北京\u0026quot;, age:18} 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。\np7 := \u0026amp;person{ city: \u0026quot;北京\u0026quot;, } fmt.Printf(\u0026quot;p7=%#v\\n\u0026quot;, p7) //p7=\u0026amp;main.person{name:\u0026quot;\u0026quot;, city:\u0026quot;北京\u0026quot;, age:0} 使用值的列表初始化 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：\np8 := \u0026amp;person{ \u0026quot;沙河娜扎\u0026quot;, \u0026quot;北京\u0026quot;, 28, } fmt.Printf(\u0026quot;p8=%#v\\n\u0026quot;, p8) //p8=\u0026amp;main.person{name:\u0026quot;沙河娜扎\u0026quot;, city:\u0026quot;北京\u0026quot;, age:28} 使用这种格式初始化时，需要注意：\n 必须初始化结构体的所有字段。 初始值的填充顺序必须与字段在结构体中的声明顺序一致。 该方式不能和键值初始化方式混用。  结构体内存布局 结构体占用一块连续的内存。\ntype test struct { a int8 b int8 c int8 d int8 } n := test{ 1, 2, 3, 4, } fmt.Printf(\u0026quot;n.a %p\\n\u0026quot;, \u0026amp;n.a) fmt.Printf(\u0026quot;n.b %p\\n\u0026quot;, \u0026amp;n.b) fmt.Printf(\u0026quot;n.c %p\\n\u0026quot;, \u0026amp;n.c) fmt.Printf(\u0026quot;n.d %p\\n\u0026quot;, \u0026amp;n.d) 输出:\nn.a 0xc0000a0060 n.b 0xc0000a0061 n.c 0xc0000a0062 n.d 0xc0000a0063 空结构体 空结构体是不占用空间的。\nvar v struct{} fmt.Println(unsafe.Sizeof(v)) // 0 构造函数 Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。\nfunc newPerson(name, city string, age int8) *person { return \u0026amp;person{ name: name, city: city, age: age, } } 调用构造函数\np9 := newPerson(\u0026quot;张三\u0026quot;, \u0026quot;沙河\u0026quot;, 90) fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p9) //\u0026amp;main.person{name:\u0026quot;张三\u0026quot;, city:\u0026quot;沙河\u0026quot;, age:90} 方法和接收者 Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。\n方法的定义格式如下：\nfunc (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 } 其中，\n 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。  举个例子：\n//Person 结构体 type Person struct { name string age int8 } //NewPerson 构造函数 func NewPerson(name string, age int8) *Person { return \u0026amp;Person{ name: name, age: age, } } //Dream Person做梦的方法 func (p Person) Dream() { fmt.Printf(\u0026quot;%s的梦想是学好Go语言！\\n\u0026quot;, p.name) } func main() { p1 := NewPerson(\u0026quot;小王子\u0026quot;, 25) p1.Dream() } 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。\n指针类型的接收者 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。\n// SetAge 设置p的年龄 // 使用指针接收者 func (p *Person) SetAge(newAge int8) { p.age = newAge } 调用该方法：\nfunc main() { p1 := NewPerson(\u0026quot;小王子\u0026quot;, 25) fmt.Println(p1.age) // 25 p1.SetAge(30) fmt.Println(p1.age) // 30 } 值类型的接收者 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。\n// SetAge2 设置p的年龄 // 使用值接收者 func (p Person) SetAge2(newAge int8) { p.age = newAge } func main() { p1 := NewPerson(\u0026quot;小王子\u0026quot;, 25) p1.Dream() fmt.Println(p1.age) // 25 p1.SetAge2(30) // (*p1).SetAge2(30) fmt.Println(p1.age) // 25 } 什么时候应该使用指针类型接收者  需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。  任意类型添加方法 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。\n//MyInt 将int定义为自定义MyInt类型 type MyInt int //SayHello 为MyInt添加一个SayHello的方法 func (m MyInt) SayHello() { fmt.Println(\u0026quot;Hello, 我是一个int。\u0026quot;) } func main() { var m1 MyInt m1.SayHello() //Hello, 我是一个int。 m1 = 100 fmt.Printf(\u0026quot;%#v %T\\n\u0026quot;, m1, m1) //100 main.MyInt } 注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。\n结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。\n//Person 结构体Person类型 type Person struct { string int } func main() { p1 := Person{ \u0026quot;小王子\u0026quot;, 18, } fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p1) //main.Person{string:\u0026quot;北京\u0026quot;, int:18} fmt.Println(p1.string, p1.int) //北京 18 } 注意：这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。\n嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。\n//Address 地址结构体 type Address struct { Province string City string } //User 用户结构体 type User struct { Name string Gender string Address Address } func main() { user1 := User{ Name: \u0026quot;小王子\u0026quot;, Gender: \u0026quot;男\u0026quot;, Address: Address{ Province: \u0026quot;山东\u0026quot;, City: \u0026quot;威海\u0026quot;, }, } fmt.Printf(\u0026quot;user1=%#v\\n\u0026quot;, user1)//user1=main.User{Name:\u0026quot;小王子\u0026quot;, Gender:\u0026quot;男\u0026quot;, Address:main.Address{Province:\u0026quot;山东\u0026quot;, City:\u0026quot;威海\u0026quot;}} } 嵌套匿名字段 上面user结构体中嵌套的Address结构体也可以采用匿名字段的方式，例如：\n//Address 地址结构体 type Address struct { Province string City string } //User 用户结构体 type User struct { Name string Gender string Address //匿名字段 } func main() { var user2 User user2.Name = \u0026quot;小王子\u0026quot; user2.Gender = \u0026quot;男\u0026quot; user2.Address.Province = \u0026quot;山东\u0026quot; // 匿名字段默认使用类型名作为字段名 user2.City = \u0026quot;威海\u0026quot; // 匿名字段可以省略 fmt.Printf(\u0026quot;user2=%#v\\n\u0026quot;, user2) //user2=main.User{Name:\u0026quot;小王子\u0026quot;, Gender:\u0026quot;男\u0026quot;, Address:main.Address{Province:\u0026quot;山东\u0026quot;, City:\u0026quot;威海\u0026quot;}} } 当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。\n嵌套结构体的字段名冲突 嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。\n//Address 地址结构体 type Address struct { Province string City string CreateTime string } //Email 邮箱结构体 type Email struct { Account string CreateTime string } //User 用户结构体 type User struct { Name string Gender string Address Email } func main() { var user3 User user3.Name = \u0026quot;沙河娜扎\u0026quot; user3.Gender = \u0026quot;男\u0026quot; // user3.CreateTime = \u0026quot;2019\u0026quot; //ambiguous selector user3.CreateTime user3.Address.CreateTime = \u0026quot;2000\u0026quot; //指定Address结构体中的CreateTime user3.Email.CreateTime = \u0026quot;2000\u0026quot; //指定Email结构体中的CreateTime } 结构体的“继承” Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。\n//Animal 动物 type Animal struct { name string } func (a *Animal) move() { fmt.Printf(\u0026quot;%s会动！\\n\u0026quot;, a.name) } //Dog 狗 type Dog struct { Feet int8 *Animal //通过嵌套匿名结构体实现继承 } func (d *Dog) wang() { fmt.Printf(\u0026quot;%s会汪汪汪~\\n\u0026quot;, d.name) } func main() { d1 := \u0026amp;Dog{ Feet: 4, Animal: \u0026amp;Animal{ //注意嵌套的是结构体指针 name: \u0026quot;乐乐\u0026quot;, }, } d1.wang() //乐乐会汪汪汪~ d1.move() //乐乐会动！ } 结构体字段的可见性 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。\n结构体与JSON序列化 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号\u0026quot;\u0026ldquo;包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。\n//Student 学生 type Student struct { ID int Gender string Name string } //Class 班级 type Class struct { Title string Students []*Student } func main() { c := \u0026amp;Class{ Title: \u0026quot;101\u0026quot;, Students: make([]*Student, 0, 200), } for i := 0; i \u0026lt; 10; i++ { stu := \u0026amp;Student{ Name: fmt.Sprintf(\u0026quot;stu%02d\u0026quot;, i), Gender: \u0026quot;男\u0026quot;, ID: i, } c.Students = append(c.Students, stu) } //JSON序列化：结构体--\u0026gt;JSON格式的字符串 data, err := json.Marshal(c) if err != nil { fmt.Println(\u0026quot;json marshal failed\u0026quot;) return } fmt.Printf(\u0026quot;json:%s\\n\u0026quot;, data) //JSON反序列化：JSON格式的字符串--\u0026gt;结构体 str := `{\u0026quot;Title\u0026quot;:\u0026quot;101\u0026quot;,\u0026quot;Students\u0026quot;:[{\u0026quot;ID\u0026quot;:0,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu00\u0026quot;},{\u0026quot;ID\u0026quot;:1,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu01\u0026quot;},{\u0026quot;ID\u0026quot;:2,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu02\u0026quot;},{\u0026quot;ID\u0026quot;:3,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu03\u0026quot;},{\u0026quot;ID\u0026quot;:4,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu04\u0026quot;},{\u0026quot;ID\u0026quot;:5,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu05\u0026quot;},{\u0026quot;ID\u0026quot;:6,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu06\u0026quot;},{\u0026quot;ID\u0026quot;:7,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu07\u0026quot;},{\u0026quot;ID\u0026quot;:8,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu08\u0026quot;},{\u0026quot;ID\u0026quot;:9,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;,\u0026quot;Name\u0026quot;:\u0026quot;stu09\u0026quot;}]}` c1 := \u0026amp;Class{} err = json.Unmarshal([]byte(str), c1) if err != nil { fmt.Println(\u0026quot;json unmarshal failed!\u0026quot;) return } fmt.Printf(\u0026quot;%#v\\n\u0026quot;, c1) } 结构体标签（Tag） Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：\n`key1:\u0026quot;value1\u0026quot; key2:\u0026quot;value2\u0026quot;` 结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。\n注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。\n例如我们为Student结构体的每个字段定义json序列化时使用的Tag：\n//Student 学生 type Student struct { ID int `json:\u0026quot;id\u0026quot;` //通过指定tag实现json序列化该字段时的key Gender string //json序列化是默认使用字段名作为key name string //私有不能被json包访问 } func main() { s1 := Student{ ID: 1, Gender: \u0026quot;男\u0026quot;, name: \u0026quot;沙河娜扎\u0026quot;, } data, err := json.Marshal(s1) if err != nil { fmt.Println(\u0026quot;json marshal failed!\u0026quot;) return } fmt.Printf(\u0026quot;json str:%s\\n\u0026quot;, data) //json str:{\u0026quot;id\u0026quot;:1,\u0026quot;Gender\u0026quot;:\u0026quot;男\u0026quot;} } 结构体和方法补充知识点 因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：\ntype Person struct { name string age int8 dreams []string } func (p *Person) SetDreams(dreams []string) { p.dreams = dreams } func main() { p1 := Person{name: \u0026quot;小王子\u0026quot;, age: 18} data := []string{\u0026quot;吃饭\u0026quot;, \u0026quot;睡觉\u0026quot;, \u0026quot;打豆豆\u0026quot;} p1.SetDreams(data) // 你真的想要修改 p1.dreams 吗？ data[1] = \u0026quot;不睡觉\u0026quot; fmt.Println(p1.dreams) // ? } 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。\nfunc (p *Person) SetDreams(dreams []string) { p.dreams = make([]string, len(dreams)) copy(p.dreams, dreams) } 同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。\n面试题 请问下面代码的执行结果是什么？\ntype student struct { name string age int } func main() { m := make(map[string]*student) stus := []student{ {name: \u0026quot;小王子\u0026quot;, age: 18}, {name: \u0026quot;娜扎\u0026quot;, age: 23}, {name: \u0026quot;大王八\u0026quot;, age: 9000}, } for _, stu := range stus { m[stu.name] = \u0026amp;stu } for k, v := range m { fmt.Println(k, \u0026quot;=\u0026gt;\u0026quot;, v.name) } } "});index.add({'id':104,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.2.%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D/','title':"2.13.2.反射介绍",'content':"2.13.2.反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。\n支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。\nGo程序在运行期使用reflect包访问程序的反射信息。\n在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。\n"});index.add({'id':105,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.2.goroutine/','title':"2.14.2.goroutine",'content':"2.14.2.goroutine 在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？\nGo语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。\n在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。\n使用goroutine Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。\n一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。\n启动单个goroutine 启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。\n举个例子如下：\nfunc hello() { fmt.Println(\u0026quot;Hello Goroutine!\u0026quot;) } func main() { hello() fmt.Println(\u0026quot;main goroutine done!\u0026quot;) } 这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。\n接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。\nfunc main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\u0026quot;main goroutine done!\u0026quot;) } 这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？\n在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。\n当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。\n所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。\nfunc main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\u0026quot;main goroutine done!\u0026quot;) time.Sleep(time.Second) } 执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。\n首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。\n启动多个goroutine 在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）\nvar wg sync.WaitGroup func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(\u0026quot;Hello Goroutine!\u0026quot;, i) } func main() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) } wg.Wait() // 等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。\n"});index.add({'id':106,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.2.%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/','title':"2.16.2.测试函数",'content':"2.16.2.测试函数 测试函数的格式 每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：\nfunc TestName(t *testing.T){ // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：\nfunc TestAdd(t *testing.T){ ... } func TestSum(t *testing.T){ ... } func TestLog(t *testing.T){ ... } 其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：\nfunc (c *T) Error(args ...interface{}) func (c *T) Errorf(format string, args ...interface{}) func (c *T) Fail() func (c *T) FailNow() func (c *T) Failed() bool func (c *T) Fatal(args ...interface{}) func (c *T) Fatalf(format string, args ...interface{}) func (c *T) Log(args ...interface{}) func (c *T) Logf(format string, args ...interface{}) func (c *T) Name() string func (t *T) Parallel() func (t *T) Run(name string, f func(t *T)) bool func (c *T) Skip(args ...interface{}) func (c *T) SkipNow() func (c *T) Skipf(format string, args ...interface{}) func (c *T) Skipped() bool 测试函数示例 就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。\n接下来，我们定义一个split的包，包中定义了一个Split函数，具体实现如下：\n// split/split.go package split import \u0026quot;strings\u0026quot; // split package with a single split function. // Split slices s into all substrings separated by sep and // returns a slice of the substrings between those separators. func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u0026gt; -1 { result = append(result, s[:i]) s = s[i+1:] i = strings.Index(s, sep) } result = append(result, s) return } 在当前目录下，我们创建一个split_test.go的测试文件，并定义一个测试函数如下：\n// split/split_test.go package split import ( \u0026quot;reflect\u0026quot; \u0026quot;testing\u0026quot; ) func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数 got := Split(\u0026quot;a:b:c\u0026quot;, \u0026quot;:\u0026quot;) // 程序输出的结果 want := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;} // 期望的结果 if !reflect.DeepEqual(want, got) { // 因为slice不能比较直接，借助反射包中的方法比较 t.Errorf(\u0026quot;excepted:%v, got:%v\u0026quot;, want, got) // 测试失败输出错误提示 } } 此时split这个包中的文件如下：\nsplit $ ls -l total 16 -rw-r--r-- 1 liwenzhou staff 408 4 29 15:50 split.go -rw-r--r-- 1 liwenzhou staff 466 4 29 16:04 split_test.go 在split包路径下，执行go test命令，可以看到输出结果如下：\nsplit $ go test PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.005s 一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在split_test.go中添加如下测试函数：\nfunc TestMoreSplit(t *testing.T) { got := Split(\u0026quot;abcd\u0026quot;, \u0026quot;bc\u0026quot;) want := []string{\u0026quot;a\u0026quot;, \u0026quot;d\u0026quot;} if !reflect.DeepEqual(want, got) { t.Errorf(\u0026quot;excepted:%v, got:%v\u0026quot;, want, got) } } 再次运行go test命令，输出结果如下：\nsplit $ go test --- FAIL: TestMultiSplit (0.00s) split_test.go:20: excepted:[a d], got:[a cd] FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s 这一次，我们的测试失败了。我们可以为go test命令添加-v参数，查看测试函数名称和运行时间：\nsplit $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestMoreSplit --- FAIL: TestMoreSplit (0.00s) split_test.go:21: excepted:[a d], got:[a cd] FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.005s 这一次我们能清楚的看到是TestMoreSplit这个测试没有成功。 还可以在go test命令后添加-run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行。\nsplit $ go test -v -run=\u0026quot;More\u0026quot; === RUN TestMoreSplit --- FAIL: TestMoreSplit (0.00s) split_test.go:21: excepted:[a d], got:[a cd] FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s 现在我们回过头来解决我们程序中的问题。很显然我们最初的split函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug：\npackage split import \u0026quot;strings\u0026quot; // split package with a single split function. // Split slices s into all substrings separated by sep and // returns a slice of the substrings between those separators. func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u0026gt; -1 { result = append(result, s[:i]) s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度 i = strings.Index(s, sep) } result = append(result, s) return } 这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。\nsplit $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestMoreSplit --- PASS: TestMoreSplit (0.00s) PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s 这一次我们的测试都通过了。\n测试组 我们现在还想要测试一下split函数对中文字符串的支持，这个时候我们可以再编写一个TestChineseSplit测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。\nfunc TestSplit(t *testing.T) { // 定义一个测试用例类型 type test struct { input string sep string want []string } // 定义一个存储测试用例的切片 tests := []test{ {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;:\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;}}, {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;,\u0026quot;, want: []string{\u0026quot;a:b:c\u0026quot;}}, {input: \u0026quot;abcd\u0026quot;, sep: \u0026quot;bc\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;d\u0026quot;}}, {input: \u0026quot;沙河有沙又有河\u0026quot;, sep: \u0026quot;沙\u0026quot;, want: []string{\u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}}, } // 遍历切片，逐一执行测试用例 for _, tc := range tests { got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\u0026quot;excepted:%v, got:%v\u0026quot;, tc.want, got) } } } 我们通过上面的代码把多个测试用例合到一起，再次执行go test命令。\nsplit $ go test -v === RUN TestSplit --- FAIL: TestSplit (0.00s) split_test.go:42: excepted:[河有 又有河], got:[ 河有 又有河] FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s 我们的测试出现了问题，仔细看打印的测试失败提示信息：excepted:[河有 又有河], got:[ 河有 又有河]，你会发现[ 河有 又有河]中有个不明显的空串，这种情况下十分推荐使用%#v的格式化方式。\n我们修改下测试用例的格式化输出错误提示部分：\nfunc TestSplit(t *testing.T) { ... for _, tc := range tests { got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\u0026quot;excepted:%#v, got:%#v\u0026quot;, tc.want, got) } } } 此时运行go test命令后就能看到比较明显的提示信息了：\nsplit $ go test -v === RUN TestSplit --- FAIL: TestSplit (0.00s) split_test.go:42: excepted:[]string{\u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}, got:[]string{\u0026quot;\u0026quot;, \u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;} FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s 子测试 看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法：\nfunc TestSplit(t *testing.T) { type test struct { // 定义test结构体 input string sep string want []string } tests := map[string]test{ // 测试用例使用map存储 \u0026quot;simple\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;:\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;}}, \u0026quot;wrong sep\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;,\u0026quot;, want: []string{\u0026quot;a:b:c\u0026quot;}}, \u0026quot;more sep\u0026quot;: {input: \u0026quot;abcd\u0026quot;, sep: \u0026quot;bc\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;d\u0026quot;}}, \u0026quot;leading sep\u0026quot;: {input: \u0026quot;沙河有沙又有河\u0026quot;, sep: \u0026quot;沙\u0026quot;, want: []string{\u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}}, } for name, tc := range tests { got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\u0026quot;name:%s excepted:%#v, got:%#v\u0026quot;, name, tc.want, got) // 将测试用例的name格式化输出 } } } 上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用t.Run执行子测试：\nfunc TestSplit(t *testing.T) { type test struct { // 定义test结构体 input string sep string want []string } tests := map[string]test{ // 测试用例使用map存储 \u0026quot;simple\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;:\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;}}, \u0026quot;wrong sep\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;,\u0026quot;, want: []string{\u0026quot;a:b:c\u0026quot;}}, \u0026quot;more sep\u0026quot;: {input: \u0026quot;abcd\u0026quot;, sep: \u0026quot;bc\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;d\u0026quot;}}, \u0026quot;leading sep\u0026quot;: {input: \u0026quot;沙河有沙又有河\u0026quot;, sep: \u0026quot;沙\u0026quot;, want: []string{\u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}}, } for name, tc := range tests { t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试 got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\u0026quot;excepted:%#v, got:%#v\u0026quot;, tc.want, got) } }) } } 此时我们再执行go test命令就能够看到更清晰的输出内容了：\nsplit $ go test -v === RUN TestSplit === RUN TestSplit/leading_sep === RUN TestSplit/simple === RUN TestSplit/wrong_sep === RUN TestSplit/more_sep --- FAIL: TestSplit (0.00s) --- FAIL: TestSplit/leading_sep (0.00s) split_test.go:83: excepted:[]string{\u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}, got:[]string{\u0026quot;\u0026quot;, \u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;} --- PASS: TestSplit/simple (0.00s) --- PASS: TestSplit/wrong_sep (0.00s) --- PASS: TestSplit/more_sep (0.00s) FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s 这个时候我们要把测试用例中的错误修改回来：\nfunc TestSplit(t *testing.T) { ... tests := map[string]test{ // 测试用例使用map存储 \u0026quot;simple\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;:\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;}}, \u0026quot;wrong sep\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;,\u0026quot;, want: []string{\u0026quot;a:b:c\u0026quot;}}, \u0026quot;more sep\u0026quot;: {input: \u0026quot;abcd\u0026quot;, sep: \u0026quot;bc\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;d\u0026quot;}}, \u0026quot;leading sep\u0026quot;: {input: \u0026quot;沙河有沙又有河\u0026quot;, sep: \u0026quot;沙\u0026quot;, want: []string{\u0026quot;\u0026quot;, \u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}}, } ... } 我们都知道可以通过-run=RegExp来指定运行的测试用例，还可以通过/来指定要运行的子测试用例，例如：go test -v -run=Split/simple只会运行simple对应的子测试用例。\n测试覆盖率 测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。\nGo提供内置功能来检查你的代码覆盖率。我们可以使用go test -cover来查看测试覆盖率。例如：\nsplit $ go test -cover PASS coverage: 100.0% of statements ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.005s 从上面的结果可以看到我们的测试用例覆盖了100%的代码。\nGo还提供了一个额外的-coverprofile参数，用来将覆盖率相关的记录信息输出到一个文件。例如：\nsplit $ go test -cover -coverprofile=c.out PASS coverage: 100.0% of statements ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.005s 上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中，然后我们执行go tool cover -html=c.out，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。  上图中每个用绿色标记的语句块表示被覆盖了，而红色的表示没有被覆盖。\n"});index.add({'id':107,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.2.collection%E6%8E%A5%E5%8F%A3/','title':"2.2.2.Collection接口",'content':"2.2.2.Collection接口  Collection父接口  特点: 代表一组任意类型的对象,无序、无下标、不能重复 方法  boolean add(Object obj) // 添加一个对象 boolean addAll(Collection c) // 将一个集合中的所有对象添加到此结合中 void clear() // 清空此集合中的所有对象 boolean contains(Object o) //检查此集合中是否包含o对象 boolean equals(Object o) // 比较此集合是否与指定对象相等 boolean isEmpty() // 判断此集合是否为空 boolean remove(Object o) // 在此集合中移除o对象 int size() // 返回此集合中的元素个数 Object[] toArray() // 将此集合转换成数组    public class demo { public static void main(String[] args) { // 创建集合 Collection collection = new ArrayList(); // 添加元素 collection.add(\u0026quot;西瓜\u0026quot;); collection.add(\u0026quot;苹果\u0026quot;); collection.add(\u0026quot;榴莲\u0026quot;); System.out.println(collection.size()); System.out.println(collection); // 删除元素 collection.remove(\u0026quot;榴莲\u0026quot;); //collection.clear(); System.out.println(\u0026quot;删除之后:\u0026quot; + collection.size()); // 遍历元素 //// 增强for for (Object object: collection) { System.out.println(object); } // 使用迭代器 Iterator it = collection.iterator(); while (it.hasNext()) { String s = (String)it.next(); System.out.println(s); // 不能使用collection的删除方法 // collection.remove(s) it.remove(); } System.out.println(\u0026quot;元素个数:\u0026quot; + collection.size()); // 判断 System.out.println(collection.contains(\u0026quot;西瓜\u0026quot;)); System.out.println(collection.isEmpty()); // 2 class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \u0026quot;Student{\u0026quot; + \u0026quot;name='\u0026quot; + name + '\\'' + \u0026quot;, age=\u0026quot; + age + '}'; } } // 创建collection对象 Collection collection1 = new ArrayList(); Student s1 = new Student(\u0026quot;张三\u0026quot;, 10); Student s2 = new Student(\u0026quot;李四\u0026quot;, 11); Student s3 = new Student(\u0026quot;王五\u0026quot;, 12); // 添加数据 collection1.add(s1); collection1.add(s2); collection1.add(s3); System.out.println(\u0026quot;元素个数:\u0026quot; + collection1.size()); System.out.println(collection1.toString()); // 删除 collection1.remove(s1); collection1.remove(new Student(\u0026quot;王五\u0026quot;, 12)); // collection1.clear(); System.out.println(\u0026quot;删除之后:\u0026quot;+collection1.size()); // 遍历 for (Object object: collection1) { Student s = (Student) object; System.out.println(s.toString()); } Iterator it1 = collection1.iterator(); while (it1.hasNext()) { Student s = (Student)it1.next(); System.out.println(s.toString()); } // 判断 System.out.println(collection1.contains(s1)); System.out.println(collection1.contains(s2)); } } "});index.add({'id':108,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.2.%E6%B5%AE%E7%82%B9%E5%9E%8B/','title':"2.2.2.浮点型",'content':"2.2.2.浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。\n打印浮点数时，可以使用fmt包配合动词%f，代码如下：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) func main() { fmt.Printf(\u0026quot;%f\\n\u0026quot;, math.Pi) fmt.Printf(\u0026quot;%.2f\\n\u0026quot;, math.Pi) } "});index.add({'id':109,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.2.%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%A0%B7%E4%BE%8B/','title':"2.2.应用部署样例",'content':"2.2.应用部署样例 https://www.bilibili.com/video/BV1tK411A7iQ?p=10\n"});index.add({'id':110,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.2.%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"2.3.2.关系运算符",'content':"2.3.2.关系运算符    运算符 描述     == 检查两个值是否相等，如果相等返回 True 否则返回 False。   != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   \u0026gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   \u0026gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。   \u0026lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   \u0026lt;= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。    "});index.add({'id':111,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.2.for/','title':"2.4.2.for",'content':"2.4.2.for(循环结构) Go 语言中的所有循环类型均可以使用for关键字来完成。\nfor循环的基本格式如下：\nfor 初始语句;条件表达式;结束语句{ 循环体语句 } 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。\nfunc forDemo() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：\nfunc forDemo2() { i := 0 for ; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句和结束语句都可以省略，例如：\nfunc forDemo3() { i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } } 这种写法类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。\n无限循环 for { 循环体语句 } for循环可以通过break、goto、return、panic语句强制退出循环。\nfor range(键值循环) Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：\n 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。  for key, item := range list { } "});index.add({'id':112,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.2.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/','title':"2.8.2.函数进阶",'content':"2.8.2.函数进阶 变量作用域 全局变量 全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。\npackage main import \u0026quot;fmt\u0026quot; //定义全局变量num var num int64 = 10 func testGlobalVar() { fmt.Printf(\u0026quot;num=%d\\n\u0026quot;, num) //函数中可以访问全局变量num } func main() { testGlobalVar() //num=10 } 局部变量 局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：\nfunc testLocalVar() { //定义一个函数局部变量x,仅在该函数内生效 var x int64 = 100 fmt.Printf(\u0026quot;x=%d\\n\u0026quot;, x) } func main() { testLocalVar() fmt.Println(x) // 此时无法使用变量x } 如果局部变量和全局变量重名，优先访问局部变量。\npackage main import \u0026quot;fmt\u0026quot; //定义全局变量num var num int64 = 10 func testNum() { num := 100 fmt.Printf(\u0026quot;num=%d\\n\u0026quot;, num) // 函数中优先使用局部变量 } func main() { testNum() // num=100 } 接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。\nfunc testLocalVar2(x, y int) { fmt.Println(x, y) //函数的参数也是只在本函数中生效 if x \u0026gt; 0 { z := 100 //变量z只在if语句块生效 fmt.Println(z) } //fmt.Println(z)//此处无法使用变量z } 还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：\nfunc testLocalVar3() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) //变量i只在当前for语句块中生效 } //fmt.Println(i) //此处无法使用变量i } 函数类型与变量 定义函数类型 我们可以使用type关键字来定义一个函数类型，具体格式如下：\ntype calculation func(int, int) int 上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。\n简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。\nfunc add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } add和sub都能赋值给calculation类型的变量。\nvar c calculation c = add 函数类型变量 我们可以声明函数类型的变量并且为该变量赋值：\nfunc main() { var c calculation // 声明一个calculation类型的变量c c = add // 把add赋值给c fmt.Printf(\u0026quot;type of c:%T\\n\u0026quot;, c) // type of c:main.calculation fmt.Println(c(1, 2)) // 像调用add一样调用c f := add // 将函数add赋值给变量f1 fmt.Printf(\u0026quot;type of f:%T\\n\u0026quot;, f) // type of f:func(int, int) int fmt.Println(f(10, 20)) // 像调用add一样调用f } 高阶函数 高阶函数分为函数作为参数和函数作为返回值两部分。\n函数作为参数 函数可以作为参数：\nfunc add(x, y int) int { return x + y } func calc(x, y int, op func(int, int) int) int { return op(x, y) } func main() { ret2 := calc(10, 20, add) fmt.Println(ret2) //30 } 函数作为返回值 函数也可以作为返回值：\nfunc do(s string) (func(int, int) int, error) { switch s { case \u0026quot;+\u0026quot;: return add, nil case \u0026quot;-\u0026quot;: return sub, nil default: err := errors.New(\u0026quot;无法识别的操作符\u0026quot;) return nil, err } } 匿名函数和闭包 匿名函数 函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：\nfunc(参数)(返回值){ 函数体 } 匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:\nfunc main() { // 将匿名函数保存到变量 add := func(x, y int) { fmt.Println(x + y) } add(10, 20) // 通过变量调用匿名函数 //自执行函数：匿名函数定义完加()直接执行 func(x, y int) { fmt.Println(x + y) }(10, 20) } 匿名函数多用于实现回调函数和闭包。\n闭包 闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。 首先我们来看一个例子：\nfunc adder() func(int) int { var x int return func(y int) int { x += y return x } } func main() { var f = adder() fmt.Println(f(10)) //10 fmt.Println(f(20)) //30 fmt.Println(f(30)) //60 f1 := adder() fmt.Println(f1(40)) //40 fmt.Println(f1(50)) //90 } 变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。 闭包进阶示例1：\nfunc adder2(x int) func(int) int { return func(y int) int { x += y return x } } func main() { var f = adder2(10) fmt.Println(f(10)) //20 fmt.Println(f(20)) //40 fmt.Println(f(30)) //70 f1 := adder2(20) fmt.Println(f1(40)) //60 fmt.Println(f1(50)) //110 } 闭包进阶示例2：\nfunc makeSuffixFunc(suffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } func main() { jpgFunc := makeSuffixFunc(\u0026quot;.jpg\u0026quot;) txtFunc := makeSuffixFunc(\u0026quot;.txt\u0026quot;) fmt.Println(jpgFunc(\u0026quot;test\u0026quot;)) //test.jpg fmt.Println(txtFunc(\u0026quot;test\u0026quot;)) //test.txt } 闭包进阶示例3：\nfunc calc(base int) (func(int) int, func(int) int) { add := func(i int) int { base += i return base } sub := func(i int) int { base -= i return base } return add, sub } func main() { f1, f2 := calc(10) fmt.Println(f1(1), f2(2)) //11 9 fmt.Println(f1(3), f2(4)) //12 8 fmt.Println(f1(5), f2(6)) //13 7 } 闭包其实并不复杂，只要牢记闭包=函数+引用环境。\ndefer语句 Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。\n举个例子：\nfunc main() { fmt.Println(\u0026quot;start\u0026quot;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(\u0026quot;end\u0026quot;) } 输出结果：\nstart end 3 2 1 由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。\ndefer执行时机 在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：\n defer经典案例 阅读下面的代码，写出最后的打印结果。\nfunc f1() int { x := 5 defer func() { x++ }() return x } func f2() (x int) { defer func() { x++ }() return 5 } func f3() (y int) { x := 5 defer func() { x++ }() return x } func f4() (x int) { defer func(x int) { x++ }(x) return 5 } func main() { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) fmt.Println(f4()) } defer面试题 func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { x := 1 y := 2 defer calc(\u0026quot;AA\u0026quot;, x, calc(\u0026quot;A\u0026quot;, x, y)) x = 10 defer calc(\u0026quot;BB\u0026quot;, x, calc(\u0026quot;B\u0026quot;, x, y)) y = 20 } 问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）\n"});index.add({'id':113,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%9B%BE/','title':"2.图",'content':"2.图 基本知识点 图可以说是所有数据结构里面知识点最丰富的一个，最基本的知识点如下。\n 阶（Order）、度：出度（Out-Degree）、入度（In-Degree） 树（Tree）、森林（Forest）、环（Loop） 有向图（Directed Graph）、无向图（Undirected Graph）、完全有向图、完全无向图 连通图（Connected Graph）、连通分量（Connected Component） 存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）  围绕图的算法也是五花八门。\n 图的遍历：深度优先、广度优先 环的检测：有向图、无向图 拓扑排序 最短路径算法：Dijkstra、Bellman-Ford、Floyd Warshall 连通性相关算法：Kosaraju、Tarjan、求解孤岛的数量、判断是否为树 图的着色、旅行商问题等  以上的知识点只是图论里的冰山一角，对于算法面试而言，完全不需要对每个知识点都一一掌握，而应该有的放矢地进行准备。\n必会知识点 根据长期的经验总结，以下的知识点是必须充分掌握并反复练习的。\n 图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List） 图的遍历：深度优先、广度优先 二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图 拓扑排序 联合-查找算法（Union-Find） 最短路径：Dijkstra、Bellman-Ford  其中，环的检测、二部图的检测、树的检测以及拓扑排序都是基于图的遍历，尤其是深度优先方式的遍历。而遍历可以在邻接矩阵或者邻接链表上进行，所以掌握好图的遍历是重中之重！因为它是所有其他图论算法的基础。\n至于最短路径算法，能区分它们的不同特点，知道在什么情况下用哪种算法就很好了。对于有充足时间准备的面试者，能熟练掌握它们的写法当然是最好的。\n"});index.add({'id':114,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E9%93%BE%E8%A1%A8/','title':"2.链表",'content':"2.链表 单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。\n双链表：与单链表不同的是，双链表的每个结点中都含有两个引用字段。\n链表优缺点 优点  链表能灵活地分配内存空间； 能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。  缺点  不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取； 查询第 k 个元素需要 O(k) 时间。  应用场景 如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。\n经典解法 链表是实现很多复杂数据结构的基础，经典解法如下。\n1. 利用快慢指针（有时候需要用到三个指针） 典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。\n2. 构建一个虚假的链表头 一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。\n在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。\n建议：在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法，既可以帮助你分析问题，又可以在面试的时候，帮助面试官清楚地看到你的思路。\n"});index.add({'id':115,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.2.time/','title':"3.2.time",'content':"3.2.time 时间类型 time.Time类型表示时间。我们可以通过time.Now()函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。示例代码如下：\nfunc timeDemo() { now := time.Now() //获取当前时间 fmt.Printf(\u0026quot;current time:%v\\n\u0026quot;, now) year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(\u0026quot;%d-%02d-%02d %02d:%02d:%02d\\n\u0026quot;, year, month, day, hour, minute, second) } 输出结果:\ncurrent time:2020-11-16 18:19:06.066198 +0800 CST m=+0.000058943 2020-11-16 18:19:06 时间戳 时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。\n基于时间对象获取时间戳的示例代码如下：\nfunc timestampDemo() { now := time.Now() //获取当前时间 timestamp1 := now.Unix() //时间戳 timestamp2 := now.UnixNano() //纳秒时间戳 fmt.Printf(\u0026quot;current timestamp1:%v\\n\u0026quot;, timestamp1) fmt.Printf(\u0026quot;current timestamp2:%v\\n\u0026quot;, timestamp2) } 使用time.Unix()函数可以将时间戳转为时间格式。\nfunc timestampDemo2(timestamp int64) { timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式 fmt.Println(timeObj) year := timeObj.Year() //年 month := timeObj.Month() //月 day := timeObj.Day() //日 hour := timeObj.Hour() //小时 minute := timeObj.Minute() //分钟 second := timeObj.Second() //秒 fmt.Printf(\u0026quot;%d-%02d-%02d %02d:%02d:%02d\\n\u0026quot;, year, month, day, hour, minute, second) } 时间间隔 time.Duration是time包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最长时间段大约290年。\ntime包中定义的时间间隔类型的常量如下：\nconst ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) 例如：time.Duration表示1纳秒，time.Second表示1秒。\n时间操作 Add 我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下：\nfunc main() { now := time.Now() later := now.Add(time.Hour) // 当前时间加1小时后的时间 fmt.Println(later) } Sub 求两个时间之间的差值：\nfunc (t Time) Sub(u Time) Duration 返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。\nEqual func (t Time) Equal(u Time) bool 判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。\nBefore func (t Time) Before(u Time) bool 如果t代表的时间点在u之前，返回真；否则返回假。\nAfter func (t Time) After(u Time) bool 如果t代表的时间点在u之后，返回真；否则返回假。\n定时器 使用time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel）。\nfunc tickDemo() { ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器 for i := range ticker { fmt.Println(i)//每秒都会执行的任务 } } 时间格式化 时间类型有一个自带的方法Format进行格式化，需要注意的是Go语言中格式化时间模板不是常见的Y-m-d H:M:S而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。也许这就是技术人员的浪漫吧。\n补充：如果想格式化为12小时方式，需指定PM。\nfunc formatDemo() { now := time.Now() // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan // 24小时制 fmt.Println(now.Format(\u0026quot;2006-01-02 15:04:05.000 Mon Jan\u0026quot;)) // 12小时制 fmt.Println(now.Format(\u0026quot;2006-01-02 03:04:05.000 PM Mon Jan\u0026quot;)) fmt.Println(now.Format(\u0026quot;2006/01/02 15:04\u0026quot;)) fmt.Println(now.Format(\u0026quot;15:04 2006/01/02\u0026quot;)) fmt.Println(now.Format(\u0026quot;2006/01/02\u0026quot;)) } 解析字符串格式的时间 now := time.Now() fmt.Println(now) // 加载时区 loc, err := time.LoadLocation(\u0026quot;Asia/Shanghai\u0026quot;) if err != nil { fmt.Println(err) return } // 按照指定时区和指定格式解析字符串时间 timeObj, err := time.ParseInLocation(\u0026quot;2006/01/02 15:04:05\u0026quot;, \u0026quot;2019/08/04 14:15:20\u0026quot;, loc) if err != nil { fmt.Println(err) return } fmt.Println(timeObj) fmt.Println(timeObj.Sub(now)) 输出结果:\n2020-11-16 18:27:59.127717 +0800 CST m=+0.000053945 2019-08-04 14:15:20 +0800 CST -11284h12m39.127717s "});index.add({'id':116,'href':'/docs/shell/bash%E5%8F%98%E9%87%8F/','title':"Bash变量",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':117,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/defer/','title':"defer",'content':"defer 什么是defer  defer是Go语言的一种用于注册延迟调用的机制,使得函数或语句可以在当前函数执行完毕后执行.  为什么需要defer  Go语言提供的语法糖,减少资源泄露的发生.  如何使用defer  在创建资源语句的附近,使得defer语句释放资源.  例子 func f1() (r int) { t := 5 // 1. 赋值指令 r = t // 2. defer被插入到赋值与返回质检， 这个例子中返回值r没被修改过 defer func() { t = t + 5 }() // 3. 空的return指令 return t } 返回值是5 func f2() (r int) { defer func(r int) { r = r + 5 }(r) // 此处r是copy了一份 return 1 } 返回值是1 func f3() (r int) { defer func(r *int) { *r = *r + 5 }(\u0026amp;r) // 此处r是传址 return 1 } 返回值是6 defer 是先入先出 func e1() { var err error defer fmt.Println(err) err = errors.New(\u0026quot;defer1 error\u0026quot;) return } func e2() { var err error def func() { fmt.Println(err) }() err = errors.New(\u0026quot;defer2 error\u0026quot;) return } func e3() { var err error def func(err error) { fmt.Println(err) }(err) err = errors.New(\u0026quot;defer3 error\u0026quot;) return } main执行 e1() e2() e3() 结果是: nil defer2 error nil "});index.add({'id':118,'href':'/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/','title':"GC垃圾回收",'content':"垃圾回收 "});index.add({'id':119,'href':'/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/mock/','title':"Go Mock (gomock)简明教程",'content':"Go Mock (gomock)简明教程 1.gomock 简介 上一篇文章 Go Test 单元测试简明教程 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。\nGoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too. gomock 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。\n使用如下命令即可安装：\ngo get -u github.com/golang/mock/gomock go get -u github.com/golang/mock/mockgen 2.一个简单的 Demo // db.go type DB interface { Get(key string) (int, error) } func GetFromDB(db DB, key string) int { if value, err := db.Get(key); err != nil { return value } return -1 } 假设 DB 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 GetFromDB 这个函数内部的逻辑，就需要 mock 接口 DB。\n第一步：使用 mockgen 生成 db_mock.go。一般传递三个参数。包含需要被mock的接口得到源文件source，生成的目标文件destination，包名package。\n$ mockgen -source=db.go -destination=db_mock.go -package=main 第二步：新建 db_test.go，写测试用例。\nfunc TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Eq(\u0026quot;Tom\u0026quot;)).Return(0, errors.New(\u0026quot;not exist\u0026quot;)) if v := GetFromDB(m, \u0026quot;Tom\u0026quot;); v != -1 { t.Fatal(\u0026quot;expected -1, but got\u0026quot;, v) } }  这个测试用例有2个目的，一是使用 ctrl.Finish() 断言 DB.Get() 被是否被调用，如果没有被调用，后续的 mock 就失去了意义； 二是测试方法 GetFromDB() 的逻辑是否正确(如果 DB.Get() 返回 error，那么 GetFromDB() 返回 -1)。 NewMockDB() 的定义在 db_test.go 中，由 mockgen 自动生成。  最终的代码结构如下：\nproject/ |--db.go |--db_mock.go // generated by mockgen |--db_test.go 执行测试：\n$ go test . -cover -v === RUN TestGetFromDB --- PASS: TestGetFromDB (0.00s) PASS coverage: 81.2% of statements ok example 0.008s coverage: 81.2% of statements 3.打桩(stubs) 在上面的例子中，当 Get() 的参数为 Tom，则返回 error，这称之为打桩(stub)，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。\n3.1 参数(Eq, Any, Not, Nil) m.EXPECT().Get(gomock.Eq(\u0026quot;Tom\u0026quot;)).Return(0, errors.New(\u0026quot;not exist\u0026quot;)) m.EXPECT().Get(gomock.Any()).Return(630, nil) m.EXPECT().Get(gomock.Not(\u0026quot;Sam\u0026quot;)).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(\u0026quot;nil\u0026quot;))  Eq(value) 表示与 value 等价的值。 Any() 可以用来表示任意的入参。 Not(value) 用来表示非 value 以外的值。 Nil() 表示 None 值  3.2 返回值(Return, DoAndReturn) m.EXPECT().Get(gomock.Not(\u0026quot;Sam\u0026quot;)).Return(0, nil) m.EXPECT().Get(gomock.Any()).Do(func(key string) { t.Log(key) }) m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) { if key == \u0026quot;Sam\u0026quot; { return 630, nil } return 0, errors.New(\u0026quot;not exist\u0026quot;) })  Return 返回确定的值 Do Mock 方法被调用时，要执行的操作吗，忽略返回值。 DoAndReturn 可以动态地控制返回值。  3.3 调用次数(Times) func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Not(\u0026quot;Sam\u0026quot;)).Return(0, nil).Times(2) GetFromDB(m, \u0026quot;ABC\u0026quot;) GetFromDB(m, \u0026quot;DEF\u0026quot;) }  Times() 断言 Mock 方法被调用的次数。 MaxTimes() 最大次数。 MinTimes() 最小次数。 AnyTimes() 任意次数（包括 0 次）。  3.4 调用顺序(InOrder) func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) o1 := m.EXPECT().Get(gomock.Eq(\u0026quot;Tom\u0026quot;)).Return(0, errors.New(\u0026quot;not exist\u0026quot;)) o2 := m.EXPECT().Get(gomock.Eq(\u0026quot;Sam\u0026quot;)).Return(630, nil) gomock.InOrder(o1, o2) GetFromDB(m, \u0026quot;Tom\u0026quot;) GetFromDB(m, \u0026quot;Sam\u0026quot;) } 4 如何编写可 mock 的代码 写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？\n mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。 不直接依赖的实例，而是使用依赖注入降低耦合性。  在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。 如果 GetFromDB() 方法长这个样子\nfunc GetFromDB(key string) int { db := NewDB() if value, err := db.Get(key); err == nil { return value } return -1 } 对 DB 接口的 mock 并不能作用于 GetFromDB() 内部，这样写是没办法进行测试的。那如果将接口 db DB 通过参数传递到 GetFromDB()，那么就可以轻而易举地传入 Mock 对象了。\n附 "});index.add({'id':120,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/iota/','title':"iota",'content':"iota   const (\na = 1 \u0026laquo; iota // a==1 (iota == 0)\nb = 1 \u0026laquo; iota // b==2 （iota == 1）\nc = 3 // c == 3 (iota==2, unused)\nd = 1 \u0026laquo; iota // d==8 (iota == 3) )\n  const x = iota // x==0\n  const y = iota // y==0 分开的const语句,iota每次都从0开始\n  "});index.add({'id':121,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/rpm/','title':"RPM",'content':"RPM RPM包在系统光盘中 RPM包命名规则 httpd-2.2.15-15.el6.CENTOS.1.i686.rpm\n-httpd 软件包名\n-2.2.15 软件版本 -15 软件包发布的次数\n-el6.centos 适合的Linux平台 -i686 适合的硬件平台 -rpm rpm包扩展名\nRPM包依赖性  树形依赖: a -\u0026gt; b -\u0026gt; c 环形依赖: a -\u0026gt; b -\u0026gt; c -\u0026gt; a 模块依赖: 模块依赖, 查询网站: www.rpmfind.net  包全名与报名  包全名 操作的包是没有安装的软件包时,使用包全名,而且要注意路径 包名 操作已经安装的软件包时,使用包名,是搜索/var/lib/rpm中的数据库  RPM包安装  rpm -ivh 包全名 选项: -i (install) 安装 -v (verbose) 显示详细信息 -h (hash) 显示进度 \u0026ndash;nodeps 不检测依赖性  RPM包升级  rpm -Uvh 包全名 选项: -U (upgrade) 升级  RPM包卸载  rpm -e httpd 包名 选项: -e （erase）卸载 \u0026ndash;nodeps 不检查依赖性  RPM包查询 1.查询是否安装   rpm -q 包名 #查询包是否安装\n  选项:\n-q 查询\n  rpm -qa\n  选项:\n-a 所有(all)\n  rpm -qa|grep \u0026ldquo;test\u0026rdquo;\n2.查询软件包详细信息  rpm -qi 包名 选项:\n-i 查询软件信息\n-p 查询未安装包信息  3.查询包中文件安装位置  rpm -ql 包名 选项: -l 列表\n-p 查询未安装包信息  默认安装位置\n   路径 描述     /etc/ 配置文件安装目录   /usr/bin/ 可执行的命令安装目录   /usr/lib/ 程序所使用的函数库保存位置   /usr/share/doc 基本的软件使用手册保存位置   /usr/share/man 帮助文件保存位置    4.查询系统文件属于哪个RPM包  rpm -qf 系统文件名 选项:\n-f 查询系统文件属于哪个软件包  5.查询软件包的依赖性  rpm -qR 包名 选项: -R 查询软件包的依赖性 -p 查询未安装包的信息  RPM包校验 1.rpm包校验  rpm -V 已安装的包名 选项:\n-V 检验指定RPM包中的文件  # rpm -V httpd S.5....T. c /etc/httpd/conf/httpd.conf 验证内容中的8个信息的具体内容如下: S 文件大小是否改变\nM 文件的类型或文件的权限(rwx)是否被改变\n5 文件MD5校验和是否改变(可以看成文件内容是否改变)\nD 设备的主从代码是否改变\nL 文件路径是否改变\nU 文件的属主(所有者)是否改变\nG 文件的属组是否改变 T 文件的修改时间是否改变\n文件类型:\nc 配置文件\nd 普通文档\ng \u0026ldquo;鬼\u0026quot;文件, 很少见,就是该文件不应该被这个RPM包包含\nL 授权文件\nr 描述文件\n2.RPM包中文件提取   rpm2cpio 包全名| cpio -idv .文件绝对路径\n-rpm2cpio 将rpm包转换为cpio格式的命令\n-cpio 是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件\n  cpio 选项 \u0026lt; [文件|设备]\n  选项: -i copy-in模式, 还原\n-d 还原时自动新建目录\n-v 显示还原过程\n  过程:\n 查询ls命令属于哪个软件包 rpm -qf /bin/ls 造成ls命令误删除假象 mv /bin/ls/tmp 提取RPM包中ls命令到当前目录的/bin/ls下\nrpm2cpio /mnt/cdrom/PACKAGES/coreutils-8.4-19.el6.i686.rpm| cpio -idv ./bin/ls 把ls命令复制到/bin/目录,修复文件丢失 cp /root/bin/ls /bin/  "});index.add({'id':122,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%88%97%E8%A1%A8vs%E5%85%83%E7%BB%84/','title':"列表vs元组",'content':"列表vs元组 列表 一、创建列表 1.创建空的列表 列表 = [] 2.创建包含元素的列表 列表 = [元素1, 元素2, ..., 元素N] 二、列表元素的获取 1.通过索引获取元素 元素 = 列表[索引] 2.通过元素获取索引 索引 = 列表.index(元素) 3.查看元素是否存在于列表中 布尔值 = 元素 in 列表 4.统计元素在列表中的个数 个数 = 列表.count(元素) 三、列表元素的添加 1.向列表末尾追加元素 列表.append(元素) 2.向列表的任意位置插入元素 列表.insert(索引, 元素) 3.列表末尾追加另一个列表的所有元素 列表.extend(另一列表) 四、列表元素的删除 1.按索引删除元素 元素 = 列表.pop(索引) 2.按索引删除元素（del方法) del 列表[索引] 3.直接删除元素 列表.remove(元素) 4.清空所有元素 列表.clear() 五、列表元素的修改 1.通过赋值修改列表元素 列表[索引] = 新元素 2.反转整个列表 列表.reverse() 3.列表元素排序 列表.sort() 元组 元组和列表非常相似，也是用于存放元素的有序序列。它用的圆括号（()）表示，元素写入圆括号中，多个元素时用逗号分隔，如 (1, 2, 3)。\n元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素。所以它与列表相比，只能查找元素，也就是说只具备读的功能，不具备写的功能。元组的这一特性叫作不可变（性）（Immutable），而列表是可变的（Mutable）。\n一、创建元组 1.创建空的元组 元组 = () 2.创建包含多个元素的元组 元组 = (元素1, 元素2, ..., 元素N) 3.创建只包含一个元素的元组 元组 = (元素,) 二、元组元素的获取 1.通过索引获取元素 元素 = 元组[索引] 2.通过元素获取索引 索引 = 元组.index(元素) 3.查看元素是否存在于元组中 布尔值 = 元素 in 元组 4.统计元素在元组中出现的个数 个数 = 元组.count(元素) 元组和列表的差别  元组是不可变的（Immutable），列表是可变的（Mutable），元组在被创建之后，就不能添加、删除和修改元素，而列表可以 一般情况下元组的性能在略高于列表  "});index.add({'id':123,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/','title':"并行、并发与分布式计算",'content':"ddd\n"});index.add({'id':124,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/','title':"数组操作",'content':"数组操作 "});index.add({'id':125,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/','title':"网络配置",'content':"网络配置 配置IP地址 1. ifconfig命令临时配置ip地址 ifconfig命令: 查看与配置网络状态命令\n#临时设置eth0网卡的IP地址与子网掩码 ifconfig eth0 192.168.0.200 netmask 255.255.255.0\n2. setup工具永久配置IP地址(rethat专有) 3. 修改网络配置文件  网卡信息文件  vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 //网卡设备名 BOOTPROTO=none //是否自动获取IP(none、static、dhcp) HWADDR=00:0c:29:17:c4:09 //MAC地址 NM_CONTROLLED=yes //是否可以由network manager图形管理工具托管 ONBOOT=yes //是否随网络服务启动, eth0生效 TYPE=Ethernet //类型为以太网 UUID=\u0026quot;xxsfwafewfw\u0026quot; //唯一识别码 IPADDR=192.168.0.252 //IP地址 NETMASK=255.255.255.0 //子网掩码 GATEWAY=192.168.0.1 //网关 DNS1=202.106.0.20 //DNS IPV6INIT=no //IPv6没有启用 USERCTL=no //不允许非root用户控制此网卡  主机名文件  vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=localhost.localdomain # 查看与临时设置主机名命令 [root@localhost ~]# hostname imooc  DNS配置文件  vi /etc/resolv.conf nameserver 202.106.0.20 search localhost 4. 图形界面配置IP地址 5. 修改uuid 1） vi /etc/sysconfig/network-scripts/ifcfg-eth0\n删除MAC地址行\n2) rm -rf /etc/udev/rules.d/70-persistent-net.rules\n# 删除网卡和mac地址绑定文件\n3) 重启系统\n5. 设置虚拟机网络连接方式  桥接\n虚拟机和真实机之间通讯使用的是真实网卡，配置简单，和真实机配置同一个网段，当成局域网真实的计算机 NAT\n虚拟机和真实机之间通讯使用的是vm-nat8虚拟网卡，只能和主机通讯，利用主机上网 Host-only\n虚拟机和真实机之间通讯使用的是vm-nat1虚拟网卡，只能和主机通讯，不能上网  6. 修改桥接网卡 打开虚拟网络编辑器，选择已桥接到的网卡\n"});index.add({'id':126,'href':'/docs/datas_tructure/','title':"Datas Tructure",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':127,'href':'/docs/datas_tructure/%E6%A0%91/','title':"树",'content':"线 "});index.add({'id':128,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"2.3.运算符",'content':"2.3.运算符  2.3.1. 算术运算符 2.3.2. 关系运算符 2.3.3. 逻辑运算符 2.3.4. 为运算符 2.3.5. 赋值运算符  "});index.add({'id':129,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/','title':"3.标准库",'content':"3.标准库  3.1.fmt 3.2.time 3.3.log 3.4.strconv 3.5.net/http 3.6.context  "});index.add({'id':130,'href':'/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/','title':"运行时篇",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':131,'href':'/docs/linux/%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/','title':"端口进程",'content':"端口进程 "});index.add({'id':132,'href':'/docs/python/%E5%BA%93/','title':"库",'content':"库 标准库 其中常用的库有 datetime：日期和时间处理相关 random：随机取值相关 josn：json 相关 XML：XML 相关 collections：集合相关 base64：base64 编码相关 hashlib：摘要算法相关，如 MD5、SHA1 itertools：迭代工具相关 contextlib：上下文管理相关 urllib：HTTP 请求相关  标准库 https://docs.python.org/zh-cn/3.7/library/index.html  第三方包 https://pypi.org/ "});index.add({'id':133,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/3.%E6%95%B0%E7%BB%84.%E9%93%BE%E8%A1%A8.%E8%B7%B3%E8%A1%A8/','title':"3.数组.链表.跳表",'content':"3.数组.链表.跳表 "});index.add({'id':134,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.3.%E5%8F%98%E9%87%8F/','title':"1.2.3 变量",'content':"1.2.3 变量 通过三个元素描述变量：变量类型、变量名以及变量值。\n 变量使用规则\n 1、Java 中的变量需要先声明后使用 2、变量使用时，可以声明变量的同时进行初始化, 也可以先声明后赋值 3、变量中每次只能赋一个值，但可以修改多次 4、main 方法中定义的变量必须先赋值，然后才能输出 5、虽然语法中没有提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患，譬如后期跨平台操作时出现乱码等等  "});index.add({'id':135,'href':'/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.3.%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/','title':"1.3.依赖管理",'content':"1.3.依赖管理 依赖管理的三个阶段: GOPATH, GOVENDOR, go mod\nGOPATH 默认在~/go\ngo mod的使用 使用intelij Idea创建项目  打开Intelij Idea, File-\u0026gt;new-\u0026gt;project 选择Go MOdules(vgo), 将Proxy: 改为https://goproxy.cn,direct 打开ide的terminal输入go env查看GO111MODULE是否为on，和查看GOPROXY是否为: https://goproxy.cn,direct 继续在terminal输入: go get -u go.uber.org/zap  获取某个固定版本: go get -u go.uber.org/zap@1.11\n获取最新的版本: go get -u go.uber.org/zap\n清洁: go mod tidy\n增加依赖：\n1. go get\n2. 代码直接写, 点run的时候自动下载\ngo build ./...  迁移到go mod go mod init modtest2 go build ./... 增加依赖 go get  总结  由go命令统一的管理, 用户不必关心目录结构 初始化: go mode init [名称] 增加依赖: go get 或者 直接写代码,在build的时候把依赖加进去 更新依赖: go get [@v\u0026hellip;], go mod tidy # 不加@v表示拿最新版本 将旧项目迁移到go mod: go mod init, go build ./\u0026hellip;, 删掉vendor，glide.yaml等文件  目录的整理 把每一个包含main的文件，分别放在不同的目录里\ngo build ./\u0026hellip; #编译当前和所有下级目录中的main方法，不产生编译文件 go install ./\u0026hellip; # 产生编译文件， 在GOPATH的bin目录中\n"});index.add({'id':136,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.3.%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/','title':"1.3.如何把修改后的代码提交到远程仓库",'content':"1.3.如何把修改后的代码提交到远程仓库 同步远程代码 git pull\n检查改动文件 git status\n Untracked: 未跟踪,一般为新增文件，此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. deleted: 文件已删除，本地删除，服务器上还没有删除. renamed: 文件名称被改变  如果发现无意中编辑了某一个文件，但实际上并不想改变它，这里可以使用git checkout 文件名来撤销更改\ngit checkout README.md 添加文件到缓存 git add index.php #添加所有使用 git add .\n提交代码 git commit . -m “这是备注信息”\n推送代码 git push\n开发中的提交 git add test1.php test2.log\ngit commit #此刻会打开一个文件, 删除非提交的之后保存 git push origin branch/feature/1 #推送到指定分支\nnotice  git add -A更好。因为git add .不会提交删除操作 git add abc.py报错‘fatal: pathspec \u0026lsquo;phase1.py\u0026rsquo; did not match any files’， 应该是这个文件，在于.gitignore文件的忽略规则里，所以Git不让你动，你可以首先把这个文件从.gitignore文件里移除，然后将.gitigore文件提交(或者将文件提交)，再次去处理abc.py文件就正常了~ 建议在修改代码前先执行 git pull命令，避免在commit并且push时候提示远程的版本比本地新 如果出现远程比本地版本更新的情况下，直接执行git pull命令有可能会自动进行合并，也有可能出现代码冲突的问题； 同理如果出现远程比本地版本更新的情况下，执行 git rebase 命令在不出现代码冲突的情况下会拉去远程的版本到本地，并且把本地的修改放在拉去下来版本的后方，但如果有冲突同样需要解决冲突问题 在GitHub上新建版本库后，你可以得到一个仓库地址，这个时候回到本地Git仓库，然后将本地仓库和远程仓库进行关联，再执行推送即可：参考命令如下~ git remote add origin https://github.com/xxxxx/project_name.git git push -u origin master  "});index.add({'id':137,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.3.%E5%BD%A2%E5%AE%B9%E8%AF%8D/','title':"1.3.形容词",'content':"1.3.形容词 "});index.add({'id':138,'href':'/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.3.while/','title':"1.4.3.while",'content':"1.4.3.while while  "});index.add({'id':139,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.3.%E5%B8%B8%E9%87%8F/','title':"2.1.3.常量",'content':"2.1.3.常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。\nconst pi = 3.1415 const e = 2.7182 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。\n多个常量也可以一起声明：\nconst ( pi = 3.1415 e = 2.7182 ) const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：\nconst ( n1 = 100 n2 n3 ) 上面示例中，常量n1、n2、n3的值都是100。\niota iota是go语言的常量计数器，只能在常量的表达式中使用。\niota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。\n举个例子：\nconst ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) 使用_跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) iota声明中间插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 定义数量级 （这里的\u0026laquo;表示左移操作，1\u0026laquo;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2\u0026laquo;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）\nconst ( _ = iota KB = 1 \u0026lt;\u0026lt; (10 * iota) MB = 1 \u0026lt;\u0026lt; (10 * iota) GB = 1 \u0026lt;\u0026lt; (10 * iota) TB = 1 \u0026lt;\u0026lt; (10 * iota) PB = 1 \u0026lt;\u0026lt; (10 * iota) ) 多个iota定义在一行 const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) "});index.add({'id':140,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.3.%E7%BB%A7%E6%89%BF/','title':"2.1.3.继承",'content':"2.1.3.继承 语法规则 class 子类 extends 父类 例: class Dog extends Animal {\n}\n方法重写 子类不满父类的类, 子类重写方法\nfinal关键字 使用final关键字做标识有\u0026quot;最终的\u0026quot;含义\nfinal可以修饰类、方法、属性、变量\n 修饰类, 则该类不允许被继承 修饰方法, 则该方法不允许被覆盖 修饰属性 则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)\n或在构造方法中赋值(但只能选其一) 修饰变量, 则该变量的值只能赋一次值,即变为常量  super关键字 在对象内部使用,可以代表父类对象\n1.访问父类的属性: super.age\n2.访问父类的方法: super.eat()\nObject类 Object类是所有类的父类,如果一个类没有使用extends关键字明确标识继承另外一个类, 那么这个类默认继承Object类\nObject类中的方法,适合所有子类\ntoString()方法 转换为字符串，所有类可以重写\nequals() 方法 比较的是对象的引用是否指向同一块内存地址\n"});index.add({'id':141,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.3.json%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/','title':"2.10.3.json与结构体",'content':"2.10.3.json与结构体 "});index.add({'id':142,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.3.reflect%E5%8C%85/','title':"2.13.3.reflect包",'content':"2.13.3.reflect包 在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type。\nTypeOf 在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; ) func reflectType(x interface{}) { v := reflect.TypeOf(x) fmt.Printf(\u0026quot;type:%v\\n\u0026quot;, v) } func main() { var a float32 = 3.14 reflectType(a) // type:float32 var b int64 = 100 reflectType(b) // type:int64 } type name和type kind 在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; ) type myInt int64 func reflectType(x interface{}) { t := reflect.TypeOf(x) fmt.Printf(\u0026quot;type:%v kind:%v\\n\u0026quot;, t.Name(), t.Kind()) } func main() { var a *float32 // 指针 var b myInt // 自定义类型 var c rune // 类型别名 reflectType(a) // type: kind:ptr reflectType(b) // type:myInt kind:int64 reflectType(c) // type:int32 kind:int32 type person struct { name string age int } type book struct{ title string } var d = person{ name: \u0026quot;沙河小王子\u0026quot;, age: 18, } var e = book{title: \u0026quot;《跟小王子学Go语言》\u0026quot;} reflectType(d) // type:person kind:struct reflectType(e) // type:book kind:struct } Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。\n在reflect包中定义的Kind类型如下：\ntype Kind uint const ( Invalid Kind = iota // 非法类型 Bool // 布尔型 Int // 有符号整型 Int8 // 有符号8位整型 Int16 // 有符号16位整型 Int32 // 有符号32位整型 Int64 // 有符号64位整型 Uint // 无符号整型 Uint8 // 无符号8位整型 Uint16 // 无符号16位整型 Uint32 // 无符号32位整型 Uint64 // 无符号64位整型 Uintptr // 指针 Float32 // 单精度浮点数 Float64 // 双精度浮点数 Complex64 // 64位复数类型 Complex128 // 128位复数类型 Array // 数组 Chan // 通道 Func // 函数 Interface // 接口 Map // 映射 Ptr // 指针 Slice // 切片 String // 字符串 Struct // 结构体 UnsafePointer // 底层指针 ) ValueOf reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。\nreflect.Value类型提供的获取原始值的方法如下：\n   方法 说明     Interface() interface {} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型   Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回   Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回   Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回   Bool() bool 将值以 bool 类型返回   Bytes() []bytes 将值以字节数组 []bytes 类型返回   String() string 将值以字符串类型返回    通过反射获取值 func reflectValue(x interface{}) { v := reflect.ValueOf(x) k := v.Kind() switch k { case reflect.Int64: // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换 fmt.Printf(\u0026quot;type is int64, value is %d\\n\u0026quot;, int64(v.Int())) case reflect.Float32: // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换 fmt.Printf(\u0026quot;type is float32, value is %f\\n\u0026quot;, float32(v.Float())) case reflect.Float64: // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换 fmt.Printf(\u0026quot;type is float64, value is %f\\n\u0026quot;, float64(v.Float())) } } func main() { var a float32 = 3.14 var b int64 = 100 reflectValue(a) // type is float32, value is 3.140000 reflectValue(b) // type is int64, value is 100 // 将int类型的原始值转换为reflect.Value类型 c := reflect.ValueOf(10) fmt.Printf(\u0026quot;type c :%T\\n\u0026quot;, c) // type c :reflect.Value } 通过反射设置变量的值 想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; ) func reflectSetValue1(x interface{}) { v := reflect.ValueOf(x) if v.Kind() == reflect.Int64 { v.SetInt(200) //修改的是副本，reflect包会引发panic } } func reflectSetValue2(x interface{}) { v := reflect.ValueOf(x) // 反射中使用 Elem()方法获取指针对应的值 if v.Elem().Kind() == reflect.Int64 { v.Elem().SetInt(200) } } func main() { var a int64 = 100 // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value reflectSetValue2(\u0026amp;a) fmt.Println(a) } isNil()和isValid() isNil() func (v Value) IsNil() bool IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。\nisValid() func (v Value) IsValid() bool IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。\n举个例子 IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。\nfunc main() { // *int类型空指针 var a *int fmt.Println(\u0026quot;var a *int IsNil:\u0026quot;, reflect.ValueOf(a).IsNil()) // nil值 fmt.Println(\u0026quot;nil IsValid:\u0026quot;, reflect.ValueOf(nil).IsValid()) // 实例化一个匿名结构体 b := struct{}{} // 尝试从结构体中查找\u0026quot;abc\u0026quot;字段 fmt.Println(\u0026quot;不存在的结构体成员:\u0026quot;, reflect.ValueOf(b).FieldByName(\u0026quot;abc\u0026quot;).IsValid()) // 尝试从结构体中查找\u0026quot;abc\u0026quot;方法 fmt.Println(\u0026quot;不存在的结构体方法:\u0026quot;, reflect.ValueOf(b).MethodByName(\u0026quot;abc\u0026quot;).IsValid()) // map c := map[string]int{} // 尝试从map中查找一个不存在的键 fmt.Println(\u0026quot;map中不存在的键：\u0026quot;, reflect.ValueOf(c).MapIndex(reflect.ValueOf(\u0026quot;娜扎\u0026quot;)).IsValid()) } "});index.add({'id':143,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.3.goroutine%E4%B8%8E%E7%BA%BF%E7%A8%8B/','title':"2.14.3.goroutine与线程",'content':"2.14.3.goroutine与线程 可增长的栈 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的goroutine也是可以的。\ngoroutine调度 GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。\n G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；  P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。\nP的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。\n单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。\nGOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。\nGo语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。\nGo1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。\n我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：\nfunc a() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026quot;A:\u0026quot;, i) } } func b() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026quot;B:\u0026quot;, i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second) } 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。\nfunc a() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026quot;A:\u0026quot;, i) } } func b() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026quot;B:\u0026quot;, i) } } func main() { runtime.GOMAXPROCS(2) go a() go b() time.Sleep(time.Second) } Go语言中的操作系统线程和goroutine的关系：\n 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。  "});index.add({'id':144,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.3.%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/','title':"2.16.3.基准测试",'content':"2.16.3.基准测试 基准测试函数格式 基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：\nfunc BenchmarkName(b *testing.B){ // ... } 基准测试以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下：\nfunc (c *B) Error(args ...interface{}) func (c *B) Errorf(format string, args ...interface{}) func (c *B) Fail() func (c *B) FailNow() func (c *B) Failed() bool func (c *B) Fatal(args ...interface{}) func (c *B) Fatalf(format string, args ...interface{}) func (c *B) Log(args ...interface{}) func (c *B) Logf(format string, args ...interface{}) func (c *B) Name() string func (b *B) ReportAllocs() func (b *B) ResetTimer() func (b *B) Run(name string, f func(b *B)) bool func (b *B) RunParallel(body func(*PB)) func (b *B) SetBytes(n int64) func (b *B) SetParallelism(p int) func (c *B) Skip(args ...interface{}) func (c *B) SkipNow() func (c *B) Skipf(format string, args ...interface{}) func (c *B) Skipped() bool func (b *B) StartTimer() func (b *B) StopTimer() 基准测试示例 我们为split包中的Split函数编写基准测试如下：\nfunc BenchmarkSplit(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { Split(\u0026quot;沙河有沙又有河\u0026quot;, \u0026quot;沙\u0026quot;) } } 基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=Split命令执行基准测试，输出结果如下：\nsplit $ go test -bench=Split goos: darwin goarch: amd64 pkg: github.com/Q1mi/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 203 ns/op PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 2.255s 其中BenchmarkSplit-8表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。\n我们还可以为基准测试添加-benchmem参数，来获得内存分配的统计数据。\nsplit $ go test -bench=Split -benchmem goos: darwin goarch: amd64 pkg: github.com/Q1mi/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 215 ns/op 112 B/op 3 allocs/op PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 2.394s 其中，112 B/op表示每次操作内存分配了112字节，3 allocs/op则表示每次操作进行了3次内存分配。 我们将我们的Split函数优化如下：\nfunc Split(s, sep string) (result []string) { result = make([]string, 0, strings.Count(s, sep)+1) i := strings.Index(s, sep) for i \u0026gt; -1 { result = append(result, s[:i]) s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度 i = strings.Index(s, sep) } result = append(result, s) return } 这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：\nsplit $ go test -bench=Split -benchmem goos: darwin goarch: amd64 pkg: github.com/Q1mi/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 127 ns/op 48 B/op 1 allocs/op PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 1.423s 这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。\n性能比较函数 上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。\n性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：\nfunc benchmark(b *testing.B, size int){/* ... */} func Benchmark10(b *testing.B){ benchmark(b, 10) } func Benchmark100(b *testing.B){ benchmark(b, 100) } func Benchmark1000(b *testing.B){ benchmark(b, 1000) } 例如我们编写了一个计算斐波那契数列的函数如下：\n// fib.go // Fib 是一个计算第n个斐波那契数的函数 func Fib(n int) int { if n \u0026lt; 2 { return n } return Fib(n-1) + Fib(n-2) } 我们编写的性能比较函数如下：\n// fib_test.go func benchmarkFib(b *testing.B, n int) { for i := 0; i \u0026lt; b.N; i++ { Fib(n) } } func BenchmarkFib1(b *testing.B) { benchmarkFib(b, 1) } func BenchmarkFib2(b *testing.B) { benchmarkFib(b, 2) } func BenchmarkFib3(b *testing.B) { benchmarkFib(b, 3) } func BenchmarkFib10(b *testing.B) { benchmarkFib(b, 10) } func BenchmarkFib20(b *testing.B) { benchmarkFib(b, 20) } func BenchmarkFib40(b *testing.B) { benchmarkFib(b, 40) } 运行基准测试：\nsplit $ go test -bench=. goos: darwin goarch: amd64 pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib BenchmarkFib1-8 1000000000 2.03 ns/op BenchmarkFib2-8 300000000 5.39 ns/op BenchmarkFib3-8 200000000 9.71 ns/op BenchmarkFib10-8 5000000 325 ns/op BenchmarkFib20-8 30000 42460 ns/op BenchmarkFib40-8 2 638524980 ns/op PASS ok github.com/Q1mi/studygo/code_demo/test_demo/fib 12.944s 这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。\n最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用-benchtime标志增加最小基准时间，以产生更准确的结果。例如：\nsplit $ go test -bench=Fib40 -benchtime=20s goos: darwin goarch: amd64 pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib BenchmarkFib40-8 50 663205114 ns/op PASS ok github.com/Q1mi/studygo/code_demo/test_demo/fib 33.849s 这一次BenchmarkFib40函数运行了50次，结果就会更准确一些了。\n使用性能比较函数做测试的时候一个容易犯的错误就是把b.N作为输入的大小，例如以下两个例子都是错误的示范：\n// 错误示范1 func BenchmarkFibWrong(b *testing.B) { for n := 0; n \u0026lt; b.N; n++ { Fib(n) } } // 错误示范2 func BenchmarkFibWrong2(b *testing.B) { Fib(b.N) } 重置时间 b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：\nfunc BenchmarkSplit(b *testing.B) { time.Sleep(5 * time.Second) // 假设需要做一些耗时的无关操作 b.ResetTimer() // 重置计时器 for i := 0; i \u0026lt; b.N; i++ { Split(\u0026quot;沙河有沙又有河\u0026quot;, \u0026quot;沙\u0026quot;) } } 并行测试 func (b *B) RunParallel(body func(*PB))会以并行的方式执行给定的基准测试。\nRunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。\nfunc BenchmarkSplitParallel(b *testing.B) { // b.SetParallelism(1) // 设置使用的CPU数 b.RunParallel(func(pb *testing.PB) { for pb.Next() { Split(\u0026quot;沙河有沙又有河\u0026quot;, \u0026quot;沙\u0026quot;) } }) } 执行一下基准测试：\nsplit $ go test -bench=. goos: darwin goarch: amd64 pkg: github.com/Q1mi/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 131 ns/op BenchmarkSplitParallel-8 50000000 36.1 ns/op PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 3.308s 还可以通过在测试命令后添加-cpu参数如go test -bench=. -cpu 1来指定使用的CPU数量。\n"});index.add({'id':145,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.3.list%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/','title':"2.2.3.List接口和实现类",'content':"2.2.3.List接口和实现类  特点: 有序、有下标、元素可以重复 方法  void add(int index, Object o) // 在index位置插入对象o boolean addAll(int index, Collection c) //将一个集合中的元素添加到此集合中的index位置 Object get(int index) // 返回集合中指定位置的元素 List subList(int fromIndex, int toIndex) // 返回fromIndex和toIndex之间的集合元素    public class demo { public static void main(String[] args) { // 先创建集合对象 List list = new ArrayList(); // 添加元素 list.add(\u0026quot;苹果\u0026quot;); list.add(\u0026quot;小米\u0026quot;); list.add(0, \u0026quot;华为\u0026quot;); System.out.println(\u0026quot;元素个数:\u0026quot; + list.size()); System.out.println(list.toString()); // 删除元素 list.remove(\u0026quot;苹果\u0026quot;); System.out.println(\u0026quot;删除之后:\u0026quot; + list.size()); System.out.println(list.toString()); // 遍历 for (int i = 0; i \u0026lt; list.size(); i++) { System.out.println(list.get(i)); } for (Object object: list) { System.out.println(object); } // 迭代器 Iterator it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } // 列表迭代器 ListIterator lit = list.listIterator(); System.out.println(\u0026quot;列表迭代器,从前往后\u0026quot;); while (lit.hasNext()) { System.out.println(lit.next()); System.out.println(lit.nextIndex()); } System.out.println(\u0026quot;列表迭代器,从后往前\u0026quot;); while (lit.hasPrevious()) { System.out.println(lit.previousIndex()); System.out.println(lit.previous()); } // 判断 System.out.println(list.contains(\u0026quot;苹果\u0026quot;)); System.out.println(list.isEmpty()); // 获取位置 System.out.println(list.indexOf(\u0026quot;华为\u0026quot;)); } } public class demo { public static void main(String[] args) { // 创建集合 List list = new ArrayList(); list.add(20); list.add(30); list.add(40); list.add(50); list.add(60); System.out.println(\u0026quot;元素个数:\u0026quot; + list.size()); System.out.println(list.toString()); // 删除操作 list.remove(0); list.remove(new Integer(20)); System.out.println(\u0026quot;删除元素:\u0026quot; + list.size()); System.out.println(list.toString()); // 补充方法 subList, 含头不含尾 List sublist = list.subList(1, 3); System.out.println(sublist); } } List实现类   ArrayList\n 数组结构实现,查询快,增删慢 运行效率快, 线程不安全  package com.test.demo; import java.util.ArrayList; import java.util.Iterator; import java.util.ListIterator; public class demo4 { public static void main(String[] args) { // 创建结合 ArrayList arrayList = new ArrayList(); // 添加元素 Student s1 = new Student(\u0026quot;刘德华\u0026quot;, 20); Student s2 = new Student(\u0026quot;郭富城\u0026quot;, 30); Student s3 = new Student(\u0026quot;梁朝伟\u0026quot;, 40); arrayList.add(s1); arrayList.add(s2); arrayList.add(s3); System.out.println(\u0026quot;元素个数:\u0026quot; + arrayList.size()); System.out.println(arrayList.toString()); // 删除元素 // arrayList.remove(s1); // 正常new的是删不掉的，需要重写equals arrayList.remove(new Student(\u0026quot;刘德华\u0026quot;, 20)); System.out.println(\u0026quot;元素个数:\u0026quot; + arrayList.size()); System.out.println(arrayList.toString()); // 遍历 Iterator it = arrayList.iterator(); while (it.hasNext()) { Student s = (Student)it.next(); System.out.println(s.toString()); } ListIterator lit = arrayList.listIterator(); while (lit.hasNext()) { Student s = (Student)lit.next(); System.out.println(s.toString()); } while (lit.hasPrevious()) { Student s = (Student)lit.previous(); System.out.println(s.toString()); } // 判断 System.out.println(arrayList.contains(new Student(\u0026quot;梁朝伟\u0026quot;, 40))); System.out.println(arrayList.isEmpty()); // 查询 System.out.println(arrayList.indexOf(s1)); } static class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026quot;Student{\u0026quot; + \u0026quot;name='\u0026quot; + name + '\\'' + \u0026quot;, age=\u0026quot; + age + '}'; } @Override public boolean equals(Object obj) { // 1.判断是不是同一个对象 if (this == obj) { return true; } // 2.判断是否为空 if (obj == null) { return false; } // 3.判断是否是Student类型 if (obj instanceof Student) { Student s = (Student)obj; // 4.比较属性 if (this.name.equals(s.getName()) \u0026amp;\u0026amp; this.age == s.getAge()) { return true; } } return false; } } }  源码 DEFAULT_CAPACITY = 10; 默认容量 注意:如果没有向集合中添加任何元素时,size为0，容量为0 elementData 存放元素的数组 size 实际元素个数 add() 添加元素 //todo::待补充       Vector\n 数组结构实现,查询快,增删慢 效率快, 线程安全  public class demo { public static void main(String[] args) { // 创建集合 Vector vector = new Vector(); vector.add(\u0026quot;草莓\u0026quot;); vector.add(\u0026quot;芒果\u0026quot;); vector.add(\u0026quot;西瓜\u0026quot;); System.out.println(\u0026quot;元素个数:\u0026quot; + vector.size()); // 删除 vector.remove(0); vector.remove(\u0026quot;西瓜\u0026quot;); vector.clear(); // 使用枚举器 Enumeration en = vector.elements(); while (en.hasMoreElements()) { String o = (String)en.nextElement(); System.out.println(o); } // 判断 vector.contains(\u0026quot;西瓜\u0026quot;); vector.isEmpty(); // vector其它方法 vector.lastElement(); } }   LinkedList\n 链表结构实现,增删快,查询慢   public class demo { public static void main(String[] args) { // 创建结合 LinkedList linkedList = new LinkedList(); // 添加 Student s1 = new Student(\u0026quot;刘德华\u0026quot;, 20); Student s2 = new Student(\u0026quot;郭富城\u0026quot;, 20); Student s3 = new Student(\u0026quot;梁朝伟\u0026quot;, 20); linkedList.add(s1); linkedList.add(s2); linkedList.add(s3); System.out.println(\u0026quot;元素个数\u0026quot; + linkedList.size()); System.out.println(linkedList); // 删除 linkedList.remove(s1); linkedList.remove(new Student(\u0026quot;郭富城\u0026quot;, 20)); System.out.println(linkedList.size()); // linkedList.clear(); // 遍历 for (int i = 0; i \u0026lt; linkedList.size(); i++) { System.out.println(linkedList.get(i)); } for (Object object: linkedList) { Student s = (Student)object; System.out.println(s.toString()); } Iterator it = linkedList.iterator(); while (it.hasNext()) { Student s = (Student) it.next(); System.out.println(s.toString()); } ListIterator lit = linkedList.listIterator(); while (lit.hasNext()) { Student s = (Student) lit.next(); System.out.println(s.toString()); } // 判断 System.out.println(linkedList.contains(s1)); System.out.println(linkedList.isEmpty()); // 获取 System.out.println(linkedList.indexOf(s2)); System.out.println(linkedList.indexOf(s3)); } }   "});index.add({'id':146,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.3.%E5%A4%8D%E6%95%B0/','title':"2.2.3.复数",'content':"2.2.3.复数 complex64和complex128\npackage main import \u0026quot;fmt\u0026quot; func main() { var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) } 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。\n"});index.add({'id':147,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.3.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"2.3.3.逻辑运算符",'content':"2.3.3.逻辑运算符    运算符 描述     \u0026amp;\u0026amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。   || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。   ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。    "});index.add({'id':148,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.3.%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%87%E4%BB%BD/','title':"2.3.迁移与备份",'content':"2.3.迁移与备份 容器保存为镜像 语法: docker commit 容器名称|容器id 镜像 docker commit redis myredis 镜像备份 我们可以通过以下命令将镜像保存为tar文件\ndocker save -o myredis.tar myredis 镜像恢复与迁移 首先我们先删除掉myredis镜像,然后执行此命令恢复\ndocker load -i myredis.tar  -i 输入的文件\n执行后再次查看镜像,可以看到镜像已经恢复  "});index.add({'id':149,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.3.switch/','title':"2.4.2.switch",'content':"2.4.3.switch 使用switch语句可方便地对大量的值进行条件判断。\nfunc switchDemo1() { finger := 3 switch finger { case 1: fmt.Println(\u0026quot;大拇指\u0026quot;) case 2: fmt.Println(\u0026quot;食指\u0026quot;) case 3: fmt.Println(\u0026quot;中指\u0026quot;) case 4: fmt.Println(\u0026quot;无名指\u0026quot;) case 5: fmt.Println(\u0026quot;小拇指\u0026quot;) default: fmt.Println(\u0026quot;无效的输入！\u0026quot;) } } Go语言规定每个switch只能有一个default分支。\n一个分支可以有多个值，多个case值中间使用英文逗号分隔。\nfunc testSwitch3() { switch n := 7; n { case 1, 3, 5, 7, 9: fmt.Println(\u0026quot;奇数\u0026quot;) case 2, 4, 6, 8: fmt.Println(\u0026quot;偶数\u0026quot;) default: fmt.Println(n) } } 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：\nfunc switchDemo4() { age := 30 switch { case age \u0026lt; 25: fmt.Println(\u0026quot;好好学习吧\u0026quot;) case age \u0026gt; 25 \u0026amp;\u0026amp; age \u0026lt; 35: fmt.Println(\u0026quot;好好工作吧\u0026quot;) case age \u0026gt; 60: fmt.Println(\u0026quot;好好享受吧\u0026quot;) default: fmt.Println(\u0026quot;活着真好\u0026quot;) } } fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。\nfunc switchDemo5() { s := \u0026quot;a\u0026quot; switch { case s == \u0026quot;a\u0026quot;: fmt.Println(\u0026quot;a\u0026quot;) fallthrough case s == \u0026quot;b\u0026quot;: fmt.Println(\u0026quot;b\u0026quot;) case s == \u0026quot;c\u0026quot;: fmt.Println(\u0026quot;c\u0026quot;) default: fmt.Println(\u0026quot;...\u0026quot;) } } 输出：\na b "});index.add({'id':150,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.3.%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/','title':"2.8.3.内置函数",'content':"2.8.3.内置函数    内置函数 介绍     close 主要用来关闭channel   len 用来求长度,比如string、array、slice、map、channel   new 用来分配内存,主要用来分配值类型,比如int、struct. 返回的是指针   make 用来分配内存,主要用来分配应用类型, 比如chan、map、slice   append 用来追加元素到数组、slice中   panic和recover 用来做错误处理    panic/recover Go语言中目前（Go1.12）是没有异常机制，但是使用panic/recover模式来处理错误。 panic可以在任何地方引发，但recover只有在defer调用的函数中有效。 首先来看一个例子：\nfunc funcA() { fmt.Println(\u0026quot;func A\u0026quot;) } func funcB() { panic(\u0026quot;panic in B\u0026quot;) } func funcC() { fmt.Println(\u0026quot;func C\u0026quot;) } func main() { funcA() funcB() funcC() } 输出:\nfunc A panic: panic in B goroutine 1 [running]: main.funcB(...) .../code/func/main.go:12 main.main() .../code/func/main.go:20 +0x98 程序运行期间funcB中引发了panic导致程序崩溃，异常退出了。这个时候我们就可以通过recover将程序恢复回来，继续往后执行。\nfunc funcA() { fmt.Println(\u0026quot;func A\u0026quot;) } func funcB() { defer func() { err := recover() //如果程序出出现了panic错误,可以通过recover恢复过来 if err != nil { fmt.Println(\u0026quot;recover in B\u0026quot;) } }() panic(\u0026quot;panic in B\u0026quot;) } func funcC() { fmt.Println(\u0026quot;func C\u0026quot;) } func main() { funcA() funcB() funcC() } 注意:\n recover()必须搭配defer使用。 defer一定要在可能引发panic的语句之前定义。  "});index.add({'id':151,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E5%89%8D%E7%BC%80%E6%A0%91/','title':"3.前缀树",'content':"3.前缀树 "});index.add({'id':152,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%88/','title':"3.栈",'content':"3.栈 特点： 栈的最大特点就是后进先出（LIFO）。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。\n实现： 利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。\n应用场景： 在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。\n如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。\n注意：栈是许多 LeetCode 中等难度偏上的题目里面经常需要用到的数据结构，掌握好它是十分必要的。\n"});index.add({'id':153,'href':'/docs/shell/shell%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"shell运算符",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':154,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/','title':"切片操作",'content':"切片操作 "});index.add({'id':155,'href':'/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/','title':"可靠的性能测试",'content':"可靠的性能测试 主要内容  可靠的测试环境 benchstat 例子与实践  对代码进行性能调优 Benchmark的正确性分析 其他的影响因素   假设检验的原理 局限与应对措施 总结  性能测试方法论 1、搜索需求\n2、编写测试用例\n3、自动化性能测试用例\n4、执行性能测试用例\n5、分析性能测试结果\n6、性能调优\n7、性能基准测试(Performance Benchmarking)\n8、向客户推荐合适的配合\n影响测试环境的软硬件因素  硬件: CPU型号、温度、IO等 软件: 操作系统版本、当前系统调度的负载等  性能基准测试的两个基本目标 可重复性: 在其他外在的条件不变的情况下, 性能度量结果是稳定、可重复的(能复现的才叫bug)\n可比较性: 总是存在一个可以比较的基本线(有比较才有伤害)\nbenchstat go get golang.org/x/perf/cmd/benchstat benchstat --help usage: benchstat [options] old.txt [new.txt] [more.txt ...] options: -alpha α consider change significant if p \u0026lt; α (default 0.05) -csv print results in CSV form -delta-test test significance test to apply to delta: utest, ttest, or none (default \u0026quot;utest\u0026quot;) -geomean print the geometric mean of each file -html print results as an HTML table -norange suppress range columns (CSV only) -sort order sort by order: [-]delta, [-]name, none (default \u0026quot;none\u0026quot;) -split labels split benchmarks by labels (default \u0026quot;pkg,goos,goarch\u0026quot;) "});index.add({'id':156,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E5%85%B8vs%E9%9B%86%E5%90%88/','title':"字典vs集合",'content':"字典vs集合 字典 字典是一种用来存放若干键值对的数据类型。\n一、创建字典 1.创建空的字典 字典 = {} 2.创建包含键值对的字典 字典 = {键1:值1, 键2:值2, ..., 键N:值N} 二、字典键值对的添加 1.向字典中增加键值对 字典[键] = 值 三、键值对的获取 1.通过键获取值 值 = 字典[键] 2.通过键获取值(get方法) 值 = 字典.get(键) 3.判断字典中是否包含某个键 布尔值 = 键 in 字典 4.获取所有键 键的列表 = 字典.keys() 5.获取所有值 值的列表 = 字典.values() 6.获取所有键值对的列表 值的列表 = 字典.items() 四、字典键值对的删除 1.通过键删除键值对 值 = 字典.pop(键) 2.通过键删除键值对（del 方法） del 字典[键] 3.随机删除一个键值对 键值二元组 = 字典.popitem() 4.清空所有键值对 键值二元组 = 字典.clear() 五、字典中键值对修改 1.修改键对应的值 字典[键] = 值 2.用字典批量更新键值对 字典.update(另一字典) 六、什么时候用字典 字典的显著优势是可以通过键快速地查询数据。字典中的元素以键值对的形式存在，使用时通过键来获取和修改值，由于字典内部的特殊实现，字典通过键获取值的效率非常高。\n集合 集合是一个用于存放批量元素的数据类型，它不是有序的，其中的元素没有顺序关系。集合中的元素没有重复，重复的元素将被自动剔除最终只留下一个。\n一、创建集合 1.创建包含元素的集合 集合 = {元素1, 元素2, 元素N} 2.创建空集合 集合 = set() 二、集合元素的添加 1.向集合中添加一个元素 集合.add(元素) 2.从另一集合中批量添加元素 集合.update(另一集合) 三、集合元素的获取 1.查看元素是否存在于集合中 布尔值 = 元素 in 集合 四、集合元素的删除 1.随机删除一个元素，并返回这个元素 元素 = 集合.pop() 2.删除一个指定的元素 集合.remove(元素) 3.删除一个指定的元素，且不抛出 KeyError 异常 集合.discard(元素) 4.清空所有元素 集合.clear() 五、集合的运算 1.求交集 交集 = 集合1.intersection(集合2, 集合3, 集合N) 或 交集 = 集合1 \u0026amp; 集合2 \u0026amp; 集合N 2.求并集 并集 = 集合1.union(集合2, 集合3, 集合N) 3.求差集 差集 = 集合1.difference(集合2, 集合3, 集合N) 4.判断是否为子集 布尔值 = 集合1.issubset(集合2) 5.判断是否为超集 布尔值 = 集合1.issuperset(集合2) 六、什么时候用集合 集合非常重要的一个特性是元素无重复，每个元素都是唯一的，重复的元素将被自动剔除（去重）。\n获取字典和集合中的元素数量 使用len函数\n"});index.add({'id':157,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/','title':"数据类型",'content':"#数据类型\n一、基本数据类型 Go 语言内置七类基本数据类型\n1.布尔类型  True False //不初始化默认为false  2.整型 byte int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr  3.浮点型 float32 float64  4.复数 complex64 complex128 // real返回复数的实部, image返回复数的虚部  5.字符 rune //rune是uint类型的别名  6.字符串: string 赋值: a := \u0026quot;hello\u0026quot; a := \u0026quot;hello world\u0026quot; b := []byte(a) c := []rune(a) b和c的结果都是:[104 101 108 108 111 44 32 119 111 114 108 100]  7.错误类型: error 8.注意 Go内置两种字符类型: 一种是byte的字节类类型(byte是unit的别名), 另一种是表示unicode编码的字符rune. rune在go内部是int32类型的别名,占用4个字节.  二、复合数据类型 复合数据类型就是由其他类型组合而成的类型.\n1.指针 *pointerType //指针类型使用*后面跟其指向的类型名 *T声明指针 **T 声明多级指针 *T 出现在\u0026quot;=\u0026quot; 左边表示指针声明, 右边表示取指针指向的值 结构体指针访问结构体字段仍然使用\u0026quot;.\u0026quot;点操作符,Go语言没有\u0026quot;-\u0026gt;\u0026quot;操作符 Go不支持指针的运算 函数中允许返回局部变量的地址  2.数组 [n]elementType //数组类型使用[n]后面跟数据元素类型来表示 var arr [2]int 数组初始化: a := [3]int{1,2,3} a := [...]int{1,2,3} a := [3]int{1:1, 2:3} // 指定总长度,并通过索引值进行初始化,没有初始化元素时使用类型默认值 a := [...]int{1:1, 2:3} //不指定总长度,通过索引值进行初始化,数组长度由最后一个索引值确定，没有指定索引的元素被初始化为类型的零值 数组的特点: 1. 数组创建完长度就固定了,不可以再追加元素 2. 数组是值类型的,数组复制或作为函数参数都是值拷贝 数组相关操作: 1. 数组元素的访问 b := a[0] for i, v := range a { } 2. 数据的长度 len()  3.切片 Go 为切片维护三个元素一一指向底层数组的指针、切片的元素数量和底层数组的容量 []elementType //切片类型使用[]后面跟切片元素类型来表示 切片的相关操作 1. 切片的创建 var array = [...]int{0,1,2,3,4,5,6,7} s1 := array[0:4] a := make([]int, 10) 或 a := make([]int, 10, 15) 2.切片支持的操作 内置函数len()返回切片长度 内置函数cap()返回切片底层数组容量 内置函数append()对切片追加元素 内置函数copy()用于复制一个切片 3.字符串和切片的相互转换 str := \u0026quot;hello,世界\u0026quot; a := []byte(str) // 将字符串转换为[]byte类型切片 b := []rune(str) // 将字符串转换为[]rune类型切片  4.字典 Go语言内置的字典类型叫map.map的类型格式是: map[K]T, 其中K可以是任意可进行比较的类型,T是值类型. map[keyType]valueType //map类型使用map[键类型]值类型来表示 字典的相关操作 1.map的创建 ma :=map[string]int{\u0026quot;a\u0026quot;:1, \u0026quot;b\u0026quot;:2} make(map[K]T) 或者 make(map[K]T, len) 2.map支持的操作 map的单个键值访问方式是: mapName[key] 可以使用range遍历一个map类型变量,但是不保证每次迭代元素的顺序 for k, v := range mp { fmt.Println(\u0026quot;key=\u0026quot;, k, \u0026quot;value=\u0026quot;, v) } 删除map中的某个键值,使用如下语法:delete(mapName, key) 可以使用内置的len()函数返回map中的键值对数量 注意: Go内置的map不是并发安全的,并发安全的map可以使用标准包sync中的map。 不要直接修改map value内某个元素的值, 如果想修改map的某个键值,则必须整体复制。 type User struct { name string age int } ma := make(map[int]User) andes := User{ name: \u0026quot;andes\u0026quot;, age: 18, } ma[1] = andes ma[1].age = 19 //Error 不能通过map引用直接修改andes.age=19 andes.age = 19 ma[1] = andes //必须整体替换value  5.通道 chan valueType //通道使用chan后面跟通道元素类型来表示  6.结构和接口  struct { feildType feildType feildType feildType ... } // 结构类型使用struct{} 将各个结构字段扩起来表示 struct类型字面量 struct { FeildName FeildType FeildName FeildType FeildName FeildType } 自定义struct类型 type TypeName struct { FeildName FeildType FeildName FeildType FeildName FeildType } struct类型变量的初始化 type Persion struct { Name string Age int } type Student struct { *Persion Number int } // 按照类型声明顺序,逐个赋值 a := Persion{\u0026quot;Tom\u0026quot;, 21} //不推荐这种初始化方式 // 推荐下面这种赋值方式 p := \u0026amp;Persion { Name: \u0026quot;tata\u0026quot;, Age: 12 } s := Strudent { Persion: p, Number: 110, } "});index.add({'id':158,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/','title':"网络命令",'content':"网络命令 网络环境查看命令 1. ifconfig 查看与配置网络状态命令\n2. 关闭与启动网卡 ifdown 网卡设备名 # 禁用该网卡设备\nifup 网卡设备名 # 启用该网卡设备\n3. 查询网络状态 netstat 选项:\n-t 列出TCP协议端口\n-u 列出UDP协议端口\n-n 不适用域名与服务名, 而使用IP地址和端口号\n-l 仅列出在监听状态网络服务\n-a 列出所有的网络连接\n4. route命令 route -n # 查看路由列表(可以看到网关)\nroute add default gw 192.168.1.1 # 临时设定网关\n在一台服务器里, 连内网的网卡是不能设置网关的\n5. 域名解析命令 nslookup [主机名或IP] # 进行域名或IP地址解析\nnslookup # 查看本机DNS服务器\n网络测试命令 1. ping 命令 ping -c 10 192.168.1.1 # ping 10次\n2. telnet 命令 telnet [域名或IP] 【端口】# 远程管理与端口探测命令(明文传输)\n3. traceroute traceroute [选项] IP或域名 #路由跟踪命令\n选项:\n-n 使用IP，不使用域名,速度更快\n4. wget 命令 5. tcpdump tcpdump -i eth0 -nnX port 21\n选项:\n-i 指定网卡接口\n-nn 将数据包中的域名和服务转为IP和端口\n-X 以十六进制和ASCII码显示数据包内容\nport 指定监听的端口\n"});index.add({'id':159,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/','title':"逃逸分析",'content':"逃逸分析 例子 /* * 闭包引用了x变量, a,b可以看做2个不同的实例,实例之间互不影响,实例内部,x变量是同一个地址,因此具有\u0026quot;累加效应\u0026quot; */ package main import \u0026quot;fmt\u0026quot; func main() { var a = acc() fmt.Printf(\u0026quot;%d\\n\u0026quot;, a(1)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, a(10)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, a(100)) fmt.Println(\u0026quot;-------------------\u0026quot;) var b = acc() fmt.Printf(\u0026quot;%d\\n\u0026quot;, b(1)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, b(10)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, b(100)) } func acc() func(int) int { var x int return func(delta int) int { fmt.Printf(\u0026quot;%+v, %+v\u0026quot;, \u0026amp;x, x) x += delta return x } } 结果: 0xc000016070, 01 0xc000016070, 111 0xc000016070, 11111 ------------------- 0xc0000160b0, 01 0xc0000160b0, 111 0xc0000160b0, 11111 "});index.add({'id':160,'href':'/docs/datas_tructure/%E5%9B%BE/','title':"图",'content':"线 "});index.add({'id':161,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/','title':"2.4.流程控制",'content':"2.4.流程控制  2.4.1.if(分支结构) 2.4.2.for(循环结构) 2.4.3.switch 2.4.4.goto(跳转到指定标签) 2.4.5.break(跳出循环) 2.4.6.continue(继续下次循环)  "});index.add({'id':162,'href':'/docs/go/4.web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/','title':"4. Web开发相关",'content':"4.Web开发相关 "});index.add({'id':163,'href':'/docs/go/readgo/%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AF%87/','title':"工具链篇",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':164,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/4.%E6%A0%88.%E9%98%9F%E5%88%97.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/','title':"4.栈.队列.优先队列.双端队列",'content':"4.栈.队列.优先队列.双端队列 "});index.add({'id':165,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.4.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/','title':"1.2.4 数据类型",'content':"1.2.4 数据类型 Java 语言是一种强类型语言。\n  基本数据类型变量存的是数据本身 引用类型变量存的是保存数据的空间地址  说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。\n常用的基本数据类型有：  你可能已经注意到了：   String 是一种常见的引用数据类型，用来表示字符串。  自动类型转换 int score1=82; double score2=score1 System.out.println(score2) 运行结果: 82.0\n自动类型转换需要满足的条件:\n   目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型    目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了    强制类型转换 语法：( 数据类型 ) 数值\ndouble avg1 = 75.8 int avg2=(int)avg1 强制类型转换可能会造成数据的丢失哦\n"});index.add({'id':166,'href':'/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.4.dowhile/','title':"1.4.4 do while",'content':"1.4.4 do while do while  "});index.add({'id':167,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.4.%E4%BD%BF%E7%94%A8diff%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81/','title':"1.4.使用diff查看修改了哪些代码",'content':"1.4.使用diff查看修改了哪些代码 名词定义 工作区 工作区，指的是当前正在编辑的文件，将还没有修改的内容通过git add命令暂存起来\n暂存区 暂存区，指的是文件修改之后并且通过git add命令临时存储到版本记录里了，但还没有正式通过git commit提交的阶段\n比较改动 git diff [文件]\n与指定记录比较 你可以先通过git log命令，找到历史提交记录的一个 hash 值。 将要比较的 hash 值复制下来，然后执行如下所示命令：git diff hash值\n与最新版本比较 git diff HEAD\n比较两个历史记录 git diff hash值1 hash值2\n查看暂存区的额外参数 \u0026ndash;cached "});index.add({'id':168,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.4.%E6%95%B0%E8%AF%8D/','title':"1.4.数词",'content':"1.4.数词 "});index.add({'id':169,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.4.%E5%A4%9A%E6%80%81/','title':"2.1.4.多台",'content':"2.1.4.多台 对象的多种形态 引用多台 父类的引用可以指向本类的对象 父类的引用可以指向子类的对象  方法多台 创建本类对象时, 调用的方法为本类的方法 创建子类对象时, 调用的方法为子类重写的方法或继承的方法  多态中的引用类型转换  向上类型的转换(隐式/自动类型转换),是小类型到大类型的转换 向下类型转换(强制类型转换), 是大类型到小类型 instanceof运算符, 来解决引用对象的类型,避免类型转换的安全性问题 它的作用是测试它左边的对象是否是它右边的类的实例  "});index.add({'id':170,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.4.%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8D%E5%B0%84/','title':"2.13.4.结构体反射",'content':"2.13.4.结构体反射 与结构体相关的方法 任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。\nreflect.Type中与获取结构体成员相关的的方法如下表所示。\n   方法 说明     Field(i int) StructField 根据索引，返回索引对应的结构体字段的信息。   NumField() int 返回结构体成员字段数量。   FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。   FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。   FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。   NumMethod() int 返回该类型的方法集中方法的数目   Method(int) Method 返回该类型方法集中的第i个方法   MethodByName(string)(Method, bool) 根据方法名返回该类型方法集中的方法    StructField类型 StructField类型用来描述结构体中的一个字段的信息。\nStructField的定义如下：\ntype StructField struct { // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为\u0026quot;\u0026quot;。 // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // 字段的类型 Tag StructTag // 字段的标签 Offset uintptr // 字段在结构体中的字节偏移量 Index []int // 用于Type.FieldByIndex时的索引切片 Anonymous bool // 是否匿名字段 } 结构体反射示例 当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。\ntype student struct { Name string `json:\u0026quot;name\u0026quot;` Score int `json:\u0026quot;score\u0026quot;` } func main() { stu1 := student{ Name: \u0026quot;小王子\u0026quot;, Score: 90, } t := reflect.TypeOf(stu1) fmt.Println(t.Name(), t.Kind()) // student struct // 通过for循环遍历结构体的所有字段信息 for i := 0; i \u0026lt; t.NumField(); i++ { field := t.Field(i) fmt.Printf(\u0026quot;name:%s index:%d type:%v json tag:%v\\n\u0026quot;, field.Name, field.Index, field.Type, field.Tag.Get(\u0026quot;json\u0026quot;)) } // 通过字段名获取指定结构体字段信息 if scoreField, ok := t.FieldByName(\u0026quot;Score\u0026quot;); ok { fmt.Printf(\u0026quot;name:%s index:%d type:%v json tag:%v\\n\u0026quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(\u0026quot;json\u0026quot;)) } } 接下来编写一个函数printMethod(s interface{})来遍历打印s包含的方法。\n// 给student添加两个方法 Study和Sleep(注意首字母大写) func (s student) Study() string { msg := \u0026quot;好好学习，天天向上。\u0026quot; fmt.Println(msg) return msg } func (s student) Sleep() string { msg := \u0026quot;好好睡觉，快快长大。\u0026quot; fmt.Println(msg) return msg } func printMethod(x interface{}) { t := reflect.TypeOf(x) v := reflect.ValueOf(x) fmt.Println(t.NumMethod()) for i := 0; i \u0026lt; v.NumMethod(); i++ { methodType := v.Method(i).Type() fmt.Printf(\u0026quot;method name:%s\\n\u0026quot;, t.Method(i).Name) fmt.Printf(\u0026quot;method:%s\\n\u0026quot;, methodType) // 通过反射调用方法传递的参数必须是 []reflect.Value 类型 var args = []reflect.Value{} v.Method(i).Call(args) } } 反射是把双刃剑 反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。\n 基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。 大量使用反射的代码通常难以理解。 反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。  "});index.add({'id':171,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.4.channel/','title':"2.14.4.channel",'content':"2.14.4.channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。\nGo语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。\n如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\nchannel类型 channel是一种类型，一种引用类型。声明通道类型的格式如下： 举几个例子：\nvar ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 创建channel 通道是引用类型，通道类型的空值是nil。\nvar ch chan int fmt.Println(ch) // \u0026lt;nil\u0026gt; 声明的通道后需要使用make函数初始化之后才能使用。\n创建channel的格式如下：\nmake(chan 元素类型, [缓冲大小]) channel的缓冲大小是可选的。\n举几个例子：\nch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) channel操作 通道有发送（send）、接收(receive）和关闭（close）三种操作。\n发送和接收都使用\u0026lt;-符号。\n现在我们先使用以下语句定义一个通道：\nch := make(chan int) 发送 将一个值发送到通道中。\nch \u0026lt;- 10 // 把10发送到ch中 接收 从一个通道中接收值。\nx := \u0026lt;- ch // 从ch中接收值并赋值给变量x \u0026lt;-ch // 从ch中接收值，忽略结果 关闭 我们通过调用内置的close函数来关闭通道。\nclose(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n关闭后的通道有以下特点：\n 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。  无缓冲的通道 无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：\nfunc main() { ch := make(chan int) ch \u0026lt;- 10 fmt.Println(\u0026quot;发送成功\u0026quot;) } 上面这段代码能够通过编译，但是执行的时候会出现以下错误：\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54 为什么会出现deadlock错误呢？\n因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。\n上面的代码会阻塞在ch \u0026lt;- 10这一行代码形成死锁，那如何解决这个问题呢？\n一种方法是启用一个goroutine去接收值，例如：\nfunc recv(c chan int) { ret := \u0026lt;-c fmt.Println(\u0026quot;接收成功\u0026quot;, ret) } func main() { ch := make(chan int) go recv(ch) // 启用goroutine从通道接收值 ch \u0026lt;- 10 fmt.Println(\u0026quot;发送成功\u0026quot;) } 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。\n使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。\n有缓冲的通道 解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：\nfunc main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 ch \u0026lt;- 10 fmt.Println(\u0026quot;发送成功\u0026quot;) } 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。\nfor range从通道循环取值 当向通道中发送完数据时，我们可以通过close函数来关闭通道。\n当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？\n我们来看下面这个例子：\n// channel 练习 func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() { for i := 0; i \u0026lt; 100; i++ { ch1 \u0026lt;- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 go func() { for { i, ok := \u0026lt;-ch1 // 通道关闭后再取值ok=false if !ok { break } ch2 \u0026lt;- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 for i := range ch2 { // 通道关闭后会退出for range循环 fmt.Println(i) } } 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range。 i, ok := \u0026lt;-ch1 和 for i := range ch2 {}\n单向通道 有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。\nGo语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：\nfunc counter(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 100; i++ { out \u0026lt;- i } close(out) } func squarer(out chan\u0026lt;- int, in \u0026lt;-chan int) { for i := range in { out \u0026lt;- i * i } close(out) } func printer(in \u0026lt;-chan int) { for i := range in { fmt.Println(i) } } func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) } 其中，\n chan\u0026lt;- int是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作； \u0026lt;-chan int是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。  在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。\n通道总结 channel常见的异常总结，如下图：  关闭已经关闭的channel也会引发panic。\n"});index.add({'id':172,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.4.setup%E4%B8%8Eteardown/','title':"2.16.4.Setup与TearDown",'content':"2.16.4.Setup与TearDown 测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。\nTestMain 通过在*_test.go文件中定义TestMain函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。\n如果测试文件包含函数:func TestMain(m *testing.M)那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 m.Run前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用os.Exit。\n一个使用TestMain来设置Setup和TearDown的示例如下：\nfunc TestMain(m *testing.M) { fmt.Println(\u0026quot;write setup code here...\u0026quot;) // 测试之前的做一些设置 // 如果 TestMain 使用了 flags，这里应该加上flag.Parse() retCode := m.Run() // 执行测试 fmt.Println(\u0026quot;write teardown code here...\u0026quot;) // 测试之后做一些拆卸工作 os.Exit(retCode) // 退出测试 } 需要注意的是：在调用TestMain时, flag.Parse并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用flag.Parse。\n子测试的Setup与Teardown 有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：\n// 测试集的Setup与Teardown func setupTestCase(t *testing.T) func(t *testing.T) { t.Log(\u0026quot;如有需要在此执行:测试之前的setup\u0026quot;) return func(t *testing.T) { t.Log(\u0026quot;如有需要在此执行:测试之后的teardown\u0026quot;) } } // 子测试的Setup与Teardown func setupSubTest(t *testing.T) func(t *testing.T) { t.Log(\u0026quot;如有需要在此执行:子测试之前的setup\u0026quot;) return func(t *testing.T) { t.Log(\u0026quot;如有需要在此执行:子测试之后的teardown\u0026quot;) } } 使用方式如下：\nfunc TestSplit(t *testing.T) { type test struct { // 定义test结构体 input string sep string want []string } tests := map[string]test{ // 测试用例使用map存储 \u0026quot;simple\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;:\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;}}, \u0026quot;wrong sep\u0026quot;: {input: \u0026quot;a:b:c\u0026quot;, sep: \u0026quot;,\u0026quot;, want: []string{\u0026quot;a:b:c\u0026quot;}}, \u0026quot;more sep\u0026quot;: {input: \u0026quot;abcd\u0026quot;, sep: \u0026quot;bc\u0026quot;, want: []string{\u0026quot;a\u0026quot;, \u0026quot;d\u0026quot;}}, \u0026quot;leading sep\u0026quot;: {input: \u0026quot;沙河有沙又有河\u0026quot;, sep: \u0026quot;沙\u0026quot;, want: []string{\u0026quot;\u0026quot;, \u0026quot;河有\u0026quot;, \u0026quot;又有河\u0026quot;}}, } teardownTestCase := setupTestCase(t) // 测试之前执行setup操作 defer teardownTestCase(t) // 测试之后执行testdoen操作 for name, tc := range tests { t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试 teardownSubTest := setupSubTest(t) // 子测试之前执行setup操作 defer teardownSubTest(t) // 测试之后执行testdoen操作 got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\u0026quot;excepted:%#v, got:%#v\u0026quot;, tc.want, got) } }) } } 测试结果如下：\nsplit $ go test -v === RUN TestSplit === RUN TestSplit/simple === RUN TestSplit/wrong_sep === RUN TestSplit/more_sep === RUN TestSplit/leading_sep --- PASS: TestSplit (0.00s) split_test.go:71: 如有需要在此执行:测试之前的setup --- PASS: TestSplit/simple (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown --- PASS: TestSplit/wrong_sep (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown --- PASS: TestSplit/more_sep (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown --- PASS: TestSplit/leading_sep (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown split_test.go:73: 如有需要在此执行:测试之后的teardown === RUN ExampleSplit --- PASS: ExampleSplit (0.00s) PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s "});index.add({'id':173,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.4.%E5%B8%83%E5%B0%94%E5%80%BC/','title':"2.2.4.布尔值",'content':"2.2.4.布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。\n注意:\n 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。  "});index.add({'id':174,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.4.%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%B7%A5%E5%85%B7%E7%B1%BB/','title':"2.2.4.泛型和工具类",'content':"2.2.4.泛型和工具类 "});index.add({'id':175,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.4.%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"2.3.4.位运算符",'content':"2.3.4.位运算符 位运算符对整数在内存中的二进制位进行操作。\n   运算符 描述     \u0026amp; 参与运算的两数各对应的二进位相与。（两位均为1才为1）   | 参与运算的两数各对应的二进位相或。（两位有一个为1就为1）   ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）   \u0026laquo; 左移n位就是乘以2的n次方。“a\u0026laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。   \u0026gt;\u0026gt; 右移n位就是除以2的n次方。“a\u0026raquo;b”是把a的各二进位全部右移b位。    "});index.add({'id':176,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.4.goto/','title':"2.4.4.goto",'content':"2.4.4.goto(跳转到指定标签) goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：\nfunc gotoDemo1() { var breakFlag bool for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 breakFlag = true break } fmt.Printf(\u0026quot;%v-%v\\n\u0026quot;, i, j) } // 外层for循环判断 if breakFlag { break } } } 使用goto语句能简化代码：\nfunc gotoDemo2() { for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 goto breakTag } fmt.Printf(\u0026quot;%v-%v\\n\u0026quot;, i, j) } } return // 标签 breakTag: fmt.Println(\u0026quot;结束for循环\u0026quot;) } "});index.add({'id':177,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.4.dockerfile/','title':"2.4.Dockerfile",'content':"2.4.Dockerfile Dockerfile是由一系列命令和参数构成的脚本,这些命令应用于基础镜像并最终创建一个新的镜像\n   命令 作用     FROM image_name:tag 定义了使用哪个基础镜像启动构建流程   MAINTAINER user_name 声明镜像的创建者   ENV key value 设置环境变量(可以写多条)   RUN command 是Dockfile的核心部分(可以写多条)   ADD source_dir/file_dest_dir/file 将宿主机的文件复制到容器内, 如果是一个压缩文件，将会在复制后自动解压   COPY source_dir/file_desc_dir/file 和ADD相似, 但是如果有压缩文件并不能解压   WORKDIR path_dir 设置工作目录    构建命令 docker build -t='jdk1.8' #构建名为jdk1.8 "});index.add({'id':178,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E7%BA%BF%E6%AE%B5%E6%A0%91/','title':"4.线段树",'content':"4.线段树 "});index.add({'id':179,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E9%98%9F%E5%88%97/','title':"4.队列",'content':"4.队列 特点： 和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。\n实现： 可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。\n应用场景： 直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。\n"});index.add({'id':180,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/map%E6%93%8D%E4%BD%9C/','title':"MAP操作",'content':"MAP操作 "});index.add({'id':181,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/','title':"控制结构",'content':"控制结构 1.if语句 if err, file := os.Open(\u0026quot;xxx\u0026quot;); err == nil { //do smoething } else { return nil, err } if score \u0026gt;= 90 { } else if score \u0026gt;= 80 { } else { }  2.switch语句 switch 语句会根据传入的参数检测并执行符合条件的分支. switch 的语法特点如下: switch 和 if 语句一样, switch后面可以带一个可选的简单的初始化语句 switch 后面的表达式也是可选的, 如果没有表达式, 则case子句是一个布尔表达式. 而不是一个值, 此时就相当于多重if else语句 switch 条件表达式的值不像c语言那样必须限制为整数, 可以是任意支持相等比较运算的类型变量 通过fallthough语句来强制执行下一个case子句(不再判断下一个case子句的条件是否满足) switch支持default语句, 当所有的case分支都不符合时,执行default语句,并且default语句可以放到任意位置,并不影响switch的逻辑判断 swith和.(type)结合可以进行类型的查询， （//todo::） switch i := \u0026quot;y\u0026quot;; i { //switch后面可以带上一个初始化语句 case \u0026quot;y\u0026quot;, \u0026quot;Y\u0026quot;: //多个case值使用逗号分隔 fmt.Println(\u0026quot;yes\u0026quot;) fallthrough //fallthrough会跳过接下来的case条件， // 直接执行下一个case语句 case \u0026quot;n\u0026quot;, \u0026quot;N\u0026quot;: fmt.Println(\u0026quot;no\u0026quot;) } switch { case score \u0026gt;= 90: grade = \u0026quot;A\u0026quot; case score \u0026gt;= 80: grade = \u0026quot;B\u0026quot; default: grade = \u0026quot;F\u0026quot; }  3.for语句 Go 语言仅支持一种循环语句,即for语句 for init; condition; post {} //类似c里面的for循环语句 for condition {} // 类似c里面的while循环语句 for {} // 类似c里面的while(1)死循环语句 // 访问map for key, value := range map {} for key := range map{} // 访问数据 for index, value := range array {} for index := range array {} for _, value := range array{} // 访问切片 for index, value := range slice {} for index := range slice {} for _, value := range slice{} // 访问通道 for value := range channel {}  4.标签和跳转 Go 语言使用标签(Lable)来标识一个语句的位置, 用于goto, break, continue语句的跳转， 标签的语法是: Lable: Statement 标签的具体作用和使用见下面的goto、break、continue goto goto 语句用于函数的内部的跳转，需要配合标签一起使用，具体的格式如下： goto Lable //goto Lable 的语义是跳转到标签名后的语句处执行， goto语句有以下几个特点: goto 语句只能在函数内跳转。 goto 语句不能跳过内部变量声明语句，这些变量在goto语句 的标签语句处又是可见的。 例如: goto L //BAD, 跳过了v := 3这条语句是不允许的 v := 3 L: goto语句只能跳到同级作用域或者上层作用域内，不能跳到内部作用域内。 例如 ： if n%2 == 1 { goto L1 } for n \u0026gt; 0 { f() n-- L1: f() n-- } break break 用于函数内跳出 for、 switch、 select 语句的执行，有两种使用格式： 单独使用，用于跳出 break 当前所在的 for、 switch、 select 语句的执行。 和标签一起使用，用于跳出标签所标识的 for、 switch、 select 语句的执行，可用于跳出多重循环，但标签和 break 必须在同一个函数内。 例如： L1: for i := 0; ; i++ { for j := 0; ; j++ { if i \u0026gt;= 5 { break L1 // 跳出L1标签所在的for循环 } if j \u0026gt; 10 { break // 默认仅跳出离break最近的内层循环 } } } continue continue 用于跳出 for 循环的本次选代，跳到 for 循环的下一次选代的 post 语句处执行，也有两种使用格式: 单独使用，用于跳出 continue 当前所在的 for 循环的本次迭代 。 和标签一起使用，用于跳出标签所标识的 for 语句的本次选代，但标签和 continue 必须 在同一个函数内。 例如 ： L1: for i := 0; ; i++ { for j := 0; ; j++ { if i \u0026gt;= 5 { continue L1 // 跳出L1标签所在处的for循环 } if j \u0026gt; 10 { continue // 继续下次循环 } } }  5.return和函数调用 re阳m i吾句也能引 发控制流程的跳转，用于函数和方法的退出。 函数和方法的调用也能引 发程序控制流的跳转，这些在后续章节中会详细介绍。 "});index.add({'id':182,'href':'/docs/shell/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/','title':"环境变量配置文件",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':183,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%B7%A5%E5%85%B7/','title':"远程登录工具",'content':"远程登录工具 SSH协议原理 对称加密算法: 采用单秘钥密码系统的加密方法\n ssh 用户名@ip scp [-r]  "});index.add({'id':184,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/','title':"迭代器和生成器",'content':"迭代器和生成器 迭代器 什么是迭代呢？在编程中，迭代指的是通过重复执行某个操作，不断获取被迭代对象中的数据。这样的每一次操作就是就是一次迭代。\n迭代器是具有迭代功能的对象。我们使用迭代器来进行迭代操作。\n迭代器 = iter(容器)\n\u0026gt;\u0026gt;\u0026gt; numbers=[1,2,3,4,5] \u0026gt;\u0026gt;\u0026gt; it = iter(numbers) \u0026gt;\u0026gt;\u0026gt; it \u0026lt;listiterator object at 0x1007e6950\u0026gt; \u0026gt;\u0026gt;\u0026gt; for 循环的迭代过程 for 循环的迭代就是通过使用迭代器来完成的。它在背后所做的事情是：\n 对一个容器调用 iter() 函数，获取到该容器的迭代器 每次循环时对迭代器调用 next() 函数，以获取一个值 若捕获到 StopIteration 异常则结束循环  可迭代（Iterable）对象 并不是所有的对象都可以被 iter() 函数使用。\n什么是可迭代(的)？\n1、从表面来看，所有可用于 for 循环的对象是可迭代的，如列表、元组、字符串、集合、字典等容器\n2、从深层来看，定义了 iter() 方法的类对象就是可迭代的。当这个类对象被 iter() 函数使用时，将返回一个迭代器对象。如果对象具有__iter__() 方法，则可以说它支持迭代协议。\n判断一个已有的对象是否是可迭代的 1、 \u0026lsquo;iter\u0026rsquo; in dir(list)\n2、 isinstance(对象, Iterable)\n自定义迭代器 class MyIterator: def __next__(self): 代码块 def __iter__(self): return self 生成器 刚才我们自定义了迭代器，其实创建迭代器还有另一种方式，就是使用生成器。\n生成器是一个函数，这个函数的特殊之处在于它的 return 语句被 yield 语句替代。\ndef power_of_two(): for exponent in range(11):\t# range(11) 表示左闭右开区间 [0, 11)，不包含 11 yield 2 ** exponent\t# 以 2 为底数求指数幂 生成器使用方法： p = power_of_two()\t# 以函数调用的方式创建生成器对象 next(p)\t# 同样使用 next() 来取值 生成器的关键在于 yield 语句。yield 语句的作用和 return 语句有几分相似，都可以将结果返回。不同在于，生成器函数执行至 yield 语句，返回结果的同时记录下函数内的状态，下次执行这个生成器函数，将从上次退出的位置（yield 的下一句代码）继续执行。当生成器函数中的所有代码被执行完毕时，自动抛出 StopIteration 异常。\n我们可以看到，生成器的用法和迭代器相似，都使用 next() 来进行迭代。这是因为生成器其实就是创建迭代器的便捷方法，生产器会在背后自动定义 iter() 和 next() 方法。\n生成器表达式（Generator Expression） 可以用一种非常简便的方式来创建生成器，就是通过生成器表达式。生成器的写法非常简单，但是灵活性也有限，所能表达的内容相对简单。\n生成器表达式的写法如下：\n生成器 = (针对项的操作 for 项 in 可迭代对象)\n\u0026gt;\u0026gt;\u0026gt; letters = (item for item in 'abc') \u0026gt;\u0026gt;\u0026gt; letters \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x1007d4960\u0026gt; \u0026gt;\u0026gt;\u0026gt; next(letters) 'a' \u0026gt;\u0026gt;\u0026gt; next(letters) 'b' \u0026gt;\u0026gt;\u0026gt; 列表生成式 [对项的操作 for 项 in 可迭代对象]\n"});index.add({'id':185,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.5.%E6%95%B0%E7%BB%84/','title':"2.5.数组",'content':"2.5.数组  2.5.数组  "});index.add({'id':186,'href':'/docs/go/5.golang%E9%AB%98%E7%BA%A7/','title':"5. Golang高级",'content':"5.Golang高级 "});index.add({'id':187,'href':'/docs/go/readgo/go%E9%98%85%E8%AF%BB/','title':"Go阅读",'content':"go夜读 "});index.add({'id':188,'href':'/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/','title':"单元测试",'content':"单元测试  Go Test 单元测试简明教程 Go Mock (gomock)简明教程  "});index.add({'id':189,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/5.%E5%93%88%E5%B8%8C%E8%A1%A8.%E6%98%A0%E5%B0%84.%E9%9B%86%E5%90%88/','title':"5.哈希表.映射.集合",'content':"5.哈希表.映射.集合 "});index.add({'id':190,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.5.%E5%B8%B8%E9%87%8F/','title':"1.2.5 常量",'content':"1.2.5 常量 语法：final 常量名 = 值;\n 常量名一般使用大写字符\n"});index.add({'id':191,'href':'/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.5.for/','title':"1.4.5.for",'content':"1.4.5 for for  "});index.add({'id':192,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.5.%E5%8A%A8%E8%AF%8D/','title':"1.5.动词",'content':"1.5.动词 "});index.add({'id':193,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.5.%E8%A7%A3%E5%86%B3%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A2%AB%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/','title':"1.5.解决提示文件权限被修改问题",'content':"1.5.解决提示文件权限被修改问题 当执行git diff 命令时出现:\ndiff --git a/index.php b/index.php old mode 100644 new mode 100755 表示文件权限被修改了， 这时候我们git pull拉取下代码,会提示文件冲突: 例如:\ngit pull eror: Your local changes to the following files would be overwritten by merge: index.php Please commit your changes or stash them before you merge. Aborting 解决方法 在Git进行代码管理时,如果不想让 Git 记录文件权限，可以通过 Git 配置让其忽略文件权限的信息，参考命令如下：\n#当前版本库 git config core.filemode false #所有版本库 git config --global core.fileMode false 当上面的命令被执行之后，就设置了忽略文件权限，此时通过cat查看配置文件.git/config，参考命令如下：\ncat .git/config 在配置文件中，如果看到fileMode false则代表配置成功.\n这时候再次使用git pull命令更新代码就不会再提示有冲突.\n"});index.add({'id':194,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.5.%E5%8C%85/','title':"2.1.5.包",'content':"2.1.5.包 包的作用 管理Java文件 解决同名文件冲突  定义包:package包名 注: 必须放在Java源程序的第一行, 包名间可以使用\u0026quot;.\u0026quot;号隔开 eg: com.imooc.MyClass  系统中的包 java.(功能).(类) java.lang.(类) 包含java语言基础的类 java.util.(类) 包含java语言中的各种工具类 java.io.(类) 包含输入、输出相关功能的类\n包的使用 (1) 可以通过import关键字,在某个文件使用其它文件中的类。\nimport com.immoc.music.MyClass\n(2) java中, 包的命名规范是全小写字母拼写\n(3) 使用的时候不但可以加载某个包下的所有文件 eg: com.immoc.*\n也可以加载某个具体子包下的所有文件\neg: com.immoc.music.*\n"});index.add({'id':195,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.5.worker_pool/','title':"2.14.5.worker pool（goroutine池）",'content':"2.14.5.worker pool（goroutine池） 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。\n一个简易的work pool示例代码如下：\nfunc worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for j := range jobs { fmt.Printf(\u0026quot;worker:%d start job:%d\\n\u0026quot;, id, j) time.Sleep(time.Second) fmt.Printf(\u0026quot;worker:%d end job:%d\\n\u0026quot;, id, j) results \u0026lt;- j * 2 } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) // 开启3个goroutine for w := 1; w \u0026lt;= 3; w++ { go worker(w, jobs, results) } // 5个任务 for j := 1; j \u0026lt;= 5; j++ { jobs \u0026lt;- j } close(jobs) // 输出结果 for a := 1; a \u0026lt;= 5; a++ { \u0026lt;-results } } "});index.add({'id':196,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.5.%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0/','title':"2.16.5.示例函数",'content':"2.16.5.示例函数 示例函数的格式 被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下：\nfunc ExampleName() { // ... } 示例函数示例 下面的代码是我们为Split函数编写的一个示例函数：\nfunc ExampleSplit() { fmt.Println(split.Split(\u0026quot;a:b:c\u0026quot;, \u0026quot;:\u0026quot;)) fmt.Println(split.Split(\u0026quot;沙河有沙又有河\u0026quot;, \u0026quot;沙\u0026quot;)) // Output: // [a b c] // [ 河有 又有河] } 为你的代码编写示例代码有如下三个用处：\n  示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。\n  示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。\n  split $ go test -run Example PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s  示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果。   "});index.add({'id':197,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.5.set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/','title':"2.2.5.Set接口和实现类",'content':"2.2.5.Set接口和实现类 "});index.add({'id':198,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.5.%E5%AD%97%E7%AC%A6%E4%B8%B2/','title':"2.2.5.字符串",'content':"2.2.5.字符串 Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(\u0026quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：\ns1 := \u0026quot;hello\u0026quot; s2 := \u0026quot;你好\u0026quot; 字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。\n   转义符 含义     \\r 回车符(返回行首)   \\n hua换行符(直接跳到下一行的同列位置)   \\t 制表符   \\\u0026rsquo; 单引号   \\\u0026rdquo; 双引号   \\\\ 反斜杠    举个例子，我们要打印一个Windows平台下的一个文件路径：\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { fmt.Println(\u0026quot;str := \\\u0026quot;c:\\\\Code\\\\lesson1\\\\go.exe\\\u0026quot;\u0026quot;) } 多行字符串 Go语言中要定义一个多行字符串时，就必须使用反引号字符：\ns1 := `第一行 第二行 第三行 ` fmt.Println(s1) 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。\n字符串的常用操作    方法 介绍     len(str) 求长度   +或fmt.Sprintf 拼接字符串   strings.Split 分割   strings.contains 判断是否包含   strings.HasPrefix, strings.Hassuffix 前缀/后缀判断   strings.Index(), strings.LastIndex() 子串出现的位置   strings.Join(a []string, sep string) json操作    "});index.add({'id':199,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.5.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"2.3.5.赋值运算符",'content':"2.3.5.赋值运算符    运算符 描述     = 简单的赋值运算符，将一个表达式的值赋给一个左值   += 相加后再赋值   -= 相减后再赋值   *= 相乘后再赋值   /= 相除后再赋值   %= 求余后再赋值   \u0026laquo;= 左移后赋值   \u0026raquo;= 右移后赋值   \u0026amp;= 按位与后赋值   |= 按位或后赋值   ^= 按位异或后赋值    "});index.add({'id':200,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.5.break/','title':"2.4.5.break",'content':"2.4.5.break(跳出循环) break语句可以结束for、switch和select的代码块。\nbreak语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子：\nfunc breakDemo1() { BREAKDEMO1: for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { break BREAKDEMO1 } fmt.Printf(\u0026quot;%v-%v\\n\u0026quot;, i, j) } } fmt.Println(\u0026quot;...\u0026quot;) } "});index.add({'id':201,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.5.docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/','title':"2.5.Docker私有仓库",'content':"2.5.Docker私有仓库 私有仓库搭建与配置 拉取私有仓库镜像\ndocker pull registry 启动私有仓库容器\ndocker run -di --name=registry -p 5000:5000 registry 打开终端输入: curl http://127.0.0.1:5000/v2/_catalog 看到{\u0026ldquo;repositories\u0026rdquo;:[]}表示私有仓库搭建成功并且内容为空\n修改daemon.json\nvim /etc/docker/daemon.json 添加以下内容,保存退出\n{ \u0026quot;insecure-registries\u0026quot;: [\u0026quot;127.0.0.1:5000\u0026quot;] } 此步用于docker信任私有仓库地址\n重启docker服务\nsystemctl restart docker 私有仓库镜像上传 docker tag 镜像名称 # docker tag centosofme 127.0.0.1:5000/centosofme # docker images REPOSITORY TAG IMAGE ID CREATED SIZE 127.0.0.1:5000/centosofme latest 30615ec12063 5 hours ago 204MB centosofme latest 30615ec12063 5 hours ago 204MB centos 7 8652b9f0cb4c # docker push 127.0.0.1:5000/centosofme # curl http://127.0.0.1:5000/v2/_catalog {\u0026quot;repositories\u0026quot;:[\u0026quot;centosofme\u0026quot;]} "});index.add({'id':202,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.5.net.http/','title':"3.5.net/http",'content':"3.5.net/http Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现。\nnet/http介绍 Go语言内置的net/http包提供了HTTP客户端和服务端的实现。\nHTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\nHTTP客户端 基本的HTTP/HTTPS请求 Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。\nresp, err := http.Get(\u0026quot;http://example.com/\u0026quot;) ... resp, err := http.Post(\u0026quot;http://example.com/upload\u0026quot;, \u0026quot;image/jpeg\u0026quot;, \u0026amp;buf) ... resp, err := http.PostForm(\u0026quot;http://example.com/form\u0026quot;, url.Values{\u0026quot;key\u0026quot;: {\u0026quot;Value\u0026quot;}, \u0026quot;id\u0026quot;: {\u0026quot;123\u0026quot;}}) 程序在使用完response后必须关闭回复的主体。\nresp, err := http.Get(\u0026quot;http://example.com/\u0026quot;) if err != nil { // handle error } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... GET请求示例 使用net/http包编写一个简单的发送HTTP请求的Client端，代码如下：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;net/http\u0026quot; ) func main() { resp, err := http.Get(\u0026quot;https://www.liwenzhou.com/\u0026quot;) if err != nil { fmt.Printf(\u0026quot;get failed, err:%v\\n\u0026quot;, err) return } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf(\u0026quot;read from resp.Body failed, err:%v\\n\u0026quot;, err) return } fmt.Print(string(body)) } 将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印liwenzhou.com网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。\n带参数的GET请求示例 关于GET请求的参数需要使用Go语言内置的net/url这个标准库来处理。\nfunc main() { apiUrl := \u0026quot;http://127.0.0.1:9090/get\u0026quot; // URL param data := url.Values{} data.Set(\u0026quot;name\u0026quot;, \u0026quot;小王子\u0026quot;) data.Set(\u0026quot;age\u0026quot;, \u0026quot;18\u0026quot;) u, err := url.ParseRequestURI(apiUrl) if err != nil { fmt.Printf(\u0026quot;parse url requestUrl failed, err:%v\\n\u0026quot;, err) } u.RawQuery = data.Encode() // URL encode fmt.Println(u.String()) resp, err := http.Get(u.String()) if err != nil { fmt.Printf(\u0026quot;post failed, err:%v\\n\u0026quot;, err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf(\u0026quot;get resp failed, err:%v\\n\u0026quot;, err) return } fmt.Println(string(b)) } 对应的Server端HandlerFunc如下：\nfunc getHandler(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() data := r.URL.Query() fmt.Println(data.Get(\u0026quot;name\u0026quot;)) fmt.Println(data.Get(\u0026quot;age\u0026quot;)) answer := `{\u0026quot;status\u0026quot;: \u0026quot;ok\u0026quot;}` w.Write([]byte(answer)) } Post请求示例 上面演示了使用net/http包发送GET请求的示例，发送POST请求的示例代码如下：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;strings\u0026quot; ) // net/http post demo func main() { url := \u0026quot;http://127.0.0.1:9090/post\u0026quot; // 表单数据 //contentType := \u0026quot;application/x-www-form-urlencoded\u0026quot; //data := \u0026quot;name=小王子\u0026amp;age=18\u0026quot; // json contentType := \u0026quot;application/json\u0026quot; data := `{\u0026quot;name\u0026quot;:\u0026quot;小王子\u0026quot;,\u0026quot;age\u0026quot;:18}` resp, err := http.Post(url, contentType, strings.NewReader(data)) if err != nil { fmt.Printf(\u0026quot;post failed, err:%v\\n\u0026quot;, err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf(\u0026quot;get resp failed, err:%v\\n\u0026quot;, err) return } fmt.Println(string(b)) } 对应的Server端HandlerFunc如下：\nfunc postHandler(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() // 1. 请求类型是application/x-www-form-urlencoded时解析form数据 r.ParseForm() fmt.Println(r.PostForm) // 打印form数据 fmt.Println(r.PostForm.Get(\u0026quot;name\u0026quot;), r.PostForm.Get(\u0026quot;age\u0026quot;)) // 2. 请求类型是application/json时从r.Body读取数据 b, err := ioutil.ReadAll(r.Body) if err != nil { fmt.Printf(\u0026quot;read request.Body failed, err:%v\\n\u0026quot;, err) return } fmt.Println(string(b)) answer := `{\u0026quot;status\u0026quot;: \u0026quot;ok\u0026quot;}` w.Write([]byte(answer)) } 自定义Client 要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：\nclient := \u0026amp;http.Client{ CheckRedirect: redirectPolicyFunc, } resp, err := client.Get(\u0026quot;http://example.com\u0026quot;) // ... req, err := http.NewRequest(\u0026quot;GET\u0026quot;, \u0026quot;http://example.com\u0026quot;, nil) // ... req.Header.Add(\u0026quot;If-None-Match\u0026quot;, `W/\u0026quot;wyzzy\u0026quot;`) resp, err := client.Do(req) // ... 自定义Transport 要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：\ntr := \u0026amp;http.Transport{ TLSClientConfig: \u0026amp;tls.Config{RootCAs: pool}, DisableCompression: true, } client := \u0026amp;http.Client{Transport: tr} resp, err := client.Get(\u0026quot;https://example.com\u0026quot;) Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。\n服务端 默认的Server ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。\nHandle和HandleFunc函数可以向DefaultServeMux添加处理器。\nhttp.Handle(\u0026quot;/foo\u0026quot;, fooHandler) http.HandleFunc(\u0026quot;/bar\u0026quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026quot;Hello, %q\u0026quot;, html.EscapeString(r.URL.Path)) }) log.Fatal(http.ListenAndServe(\u0026quot;:8080\u0026quot;, nil)) 默认的Server示例 使用Go语言中的net/http包来编写一个简单的接收HTTP请求的Server端示例，net/http包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：\n// http server func sayHello(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \u0026quot;Hello 沙河！\u0026quot;) } func main() { http.HandleFunc(\u0026quot;/\u0026quot;, sayHello) err := http.ListenAndServe(\u0026quot;:9090\u0026quot;, nil) if err != nil { fmt.Printf(\u0026quot;http server failed, err:%v\\n\u0026quot;, err) return } } 将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入127.0.0.1:9090回车，此时就能够看到如下页面了。\n自定义Server 要管理服务端的行为，可以创建一个自定义的Server：\ns := \u0026amp;http.Server{ Addr: \u0026quot;:8080\u0026quot;, Handler: myHandler, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u0026lt;\u0026lt; 20, } log.Fatal(s.ListenAndServe()) "});index.add({'id':203,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/','title':"5.双端队列",'content':"5.双端队列 特点： 双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。\n实现： 与队列相似，我们可以利用一个双链表实现双端队列。\n应用场景： 双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。\n"});index.add({'id':204,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/','title':"5.树状数组",'content':"5.树状数组 "});index.add({'id':205,'href':'/docs/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/','title':"帮助命令",'content':"帮助命令 帮助命令man man 命令 man的级别 1: 查看命令帮助 2: 查看可被内核调用的函数的帮助 3: 查看函数和函数库的帮助 4: 查看特殊文件的帮助(主要是/dev目录下的文件) 5: 查看配置文件的帮助 6: 查看游戏的帮助 7: 查看其他杂项的帮助 8: 查看系统管理员可用命令的帮助 9: 查看和内核相关文件的帮助 查看命令拥有哪个级别的帮助 man -f 命令 或者 whatis 命令 举例: man -5 passwd man -4 null man -8 ifconfig 查看和命令相关的所有帮助 man -k 命令 或者 apropos 命令 举例: man -k passwd  其他帮助命令 * 选项帮助: 命令 --help #获取命令选项的帮助 例如: ls --help * shell内部命令帮助 help shell内部命令 #获取shell内部命令的帮助 例如: whereis cd #确定是否是shell内部命令 只要找不到执行文件都是内部命令 help cd #获取内部命令帮助 * 详细命令帮助info - 回车: 进入子帮助页面(带有*号标记) - u: 进入上层页面 - n: 进入下一个帮助小节 - p: 进入上一个帮助小节 - q: 退出  "});index.add({'id':206,'href':'/docs/shell/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/','title':"正则表达式",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':207,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/','title':"生成器表达式和列表生成式",'content':"生成器表达式和列表生成式 列表生成式 nums = [2 ** i for i in range(1, 11)] 这行代码就是我们这个章节要所讲的列表生成式。顾名思义，列表生成式最终生成的是一个列表，它是用已有的可迭代对象来构造新列表的便捷方法。\n列表生成式的写法 列表生成式的语法如下： [对项的操作 for 项 in 可迭代对象]\n列表生成式中使用 if 在列表生成式的中，每次迭代的 项 是可以被筛选过滤的，使用 if 关键字。如： [对项的操作 for 项 in 可迭代对象 if 对项的判断]\n列表生成式中嵌套 for 列表生成式中的 for 中还可以再嵌套 for。如：[对项1和(或)项2的操作 for 项1 in 可迭代对象1 for 项2 in 可迭代对象2]\n字典生成式 便捷地构造列表可以使用列表生成式，同样的，想要通过已有的可迭代对象来便捷地构造字典，可以使用字典生成式。\n字典生成式的写法是：{键: 值 for 项 in 可迭代对象}\n集合生成式 你可能已经猜到了，只需要将列表生成式的方括号（[]）替换为花括号（{}）即可：{对项的操作 for 项 in 可迭代对象}\n生成器表达式 Python 中并没有「元组生成式」！虽然 Python 中确实有类似的圆括号的写法：(对项的操作 for 项 in 可迭代对象)\n但这可不是什么「元组生成式」，而是我们上一章节学习过的生成器表达式。\n生成器表达式是一种创建生成器的便捷方法。虽然写法上和列表生成式、字典生成式、集合生成式相似，却有着本质的不同，因为它创建出来的是生成器，而不是列表、字典、集合这类容器。 (char.lower() for char in \u0026lsquo;ABCDEF\u0026rsquo;)\n\u0026gt;\u0026gt;\u0026gt; g = (char.lower() for char in ‘ABCDEF’) \u0026gt;\u0026gt;\u0026gt; g \u0026lt;generator object at 0x103da6c78\u0026gt; \u0026gt;\u0026gt;\u0026gt; next(g) ‘a’ \u0026gt;\u0026gt;\u0026gt; next(g) ‘b’ 生成器表达式中同样可以使用 if 和嵌套 for，使用方法和列表生成式相同。\n"});index.add({'id':208,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E7%BB%93%E6%9E%84%E4%BD%93%E6%93%8D%E4%BD%9C/','title':"结构体操作",'content':"结构体操作 类型转换 比较对比 搜索 查找 统计 替换 删除过滤 大小写转换 前缀后缀 字符串分割 拼接 "});index.add({'id':209,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/','title':"2.6.切片",'content':"2.6.切片  2.6.切片  "});index.add({'id':210,'href':'/docs/go/6.golang%E6%BA%90%E7%A0%81/','title':"6. Golang源码",'content':"6.Golang源码 "});index.add({'id':211,'href':'/docs/go/7.%E5%BA%94%E7%94%A8/','title':"7.应用",'content':"7.应用 "});index.add({'id':212,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/','title':"6.树.二叉树.二叉搜索树",'content':"6.树.二叉树.二叉搜索树 树 树的3种遍历  前序: 根-\u0026gt;左-\u0026gt;右 中序: 左-\u0026gt;根-\u0026gt;右 后序: 左-\u0026gt;右-\u0026gt;根  树的3种遍历.go\n二叉搜索树 Binary Search Tree 二叉搜索树, 也称二叉查找树、有序二叉树、排序二叉树，是指一颗空树或者具有下列性质的二叉树\n 左子树上所有节点的值均小于它的根节点的值; 右子树上所有节点的值均大于它的根节点的值; 以此类推: 左右子树也分别为二叉查找树  中序遍历: 升序排列\n二叉搜索树的操作\n"});index.add({'id':213,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.6.%E6%B3%A8%E9%87%8A/','title':"1.2.6 注释",'content':"1.2.6 注释 注释有三种类型：单行注释、多行注释、文档\n PS：使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息：\n @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明  "});index.add({'id':214,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.6.%E5%89%AF%E8%AF%8D/','title':"1.6.副词",'content':"1.6.副词 "});index.add({'id':215,'href':'/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.6.%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/','title':"1.6.忽略指定文件或目录",'content':"1.6.忽略指定文件或目录 我们可以在在Git工作区的根目录下创建一个.gitignore文件，把想忽略的文件名或者目录填进去，Git 就会自动忽略这些文件。\nvi .gitignore .DS_Store .idea 常见问题   无法添加.gitignore windows系统会出现\n  添加忽略文件 .gitignore 文件支持通配符，当你在文件中添加一些忽略规则之后，可能匹配过于宽松，导致某一个文件无法提交到 git ;这个时候你有两种方式来处理，\n  或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：\n$ git check-ignore -v 文件名 .gitignore:1:.DS_Store .DS_Store Git 会告诉我们，.gitignore 的第 1 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。\n除了修改 .gitignore 文件的规则之外还可以使用强制添加的方式:\ngit add -f .DS_Store "});index.add({'id':216,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.6.%E6%8A%BD%E8%B1%A1%E7%B1%BB/','title':"2.1.6.抽象类",'content':"2.1.6.抽象类 使用规则  abstract定义抽象类 abstract定义抽象方法,只有声明,不需要实现 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法, 也可以没有抽象方法 抽象类不能直接创建, 可以定义引用变量  public abstract class Telphone { public abstract void call() } "});index.add({'id':217,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.6.select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/','title':"2.14.6.select多路复用",'content':"2.14.6.select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：\nfor{ // 尝试从ch1接收值 data, ok := \u0026lt;-ch1 // 尝试从ch2接收值 data, ok := \u0026lt;-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。\nselect的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：\nselect{ case \u0026lt;-ch1: ... case data := \u0026lt;-ch2: ... case ch3\u0026lt;-data: ... default: 默认操作 } 举个小例子来演示下select的使用：\nfunc main() { ch := make(chan int, 1) for i := 0; i \u0026lt; 10; i++ { select { case x := \u0026lt;-ch: fmt.Println(x) case ch \u0026lt;- i: } } } 使用select语句能提高代码的可读性。\n 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select{}会一直等待，可用于阻塞main函数。  "});index.add({'id':218,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.6.byte%E5%92%8Crune%E7%B1%BB%E5%9E%8B/','title':"2.2.6.byte和rune类型",'content':"2.2.6.byte和rune类型 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：\nvar a := '中' var b := 'x' Go 语言的字符有以下两种：\n uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。  Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。\n// 遍历字符串 func traversalString() { s := \u0026quot;hello沙河\u0026quot; for i := 0; i \u0026lt; len(s); i++ { //byte fmt.Printf(\u0026quot;%v(%c) \u0026quot;, s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(\u0026quot;%v(%c) \u0026quot;, r, r) } fmt.Println() } 输出:\n104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。\n字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。\n修改字符串 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。\nfunc changeString() { s1 := \u0026quot;big\u0026quot; // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = 'p' fmt.Println(string(byteS1)) s2 := \u0026quot;白萝卜\u0026quot; runeS2 := []rune(s2) runeS2[0] = '红' fmt.Println(string(runeS2)) } "});index.add({'id':219,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.6.map%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/','title':"2.2.6.Map接口和实现类",'content':"2.2.6.Map接口和实现类 "});index.add({'id':220,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.6.continue/','title':"2.4.6.continue",'content':"2.4.6.continue(继续下次循环) continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。\n在 continue语句后添加标签时，表示开始标签对应的循环。例如：\nfunc continueDemo() { forloop1: for i := 0; i \u0026lt; 5; i++ { // forloop2: for j := 0; j \u0026lt; 5; j++ { if i == 2 \u0026amp;\u0026amp; j == 2 { continue forloop1 } fmt.Printf(\u0026quot;%v-%v\\n\u0026quot;, i, j) } } } "});index.add({'id':221,'href':'/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.6.dockermaven%E6%8F%92%E4%BB%B6/','title':"2.6.DockerMaven插件",'content':"2.6.DockerMaven插件 微服务部署有两种方法:\n 手动部署: 首先基于源码打包生成jar包, (或war包), 将jar包上传至虚拟机并拷贝到JDK容器 通过Maven插件自动部署  修改宿主机的docker配置,让其可以远程访问 vim /lib/systemd/system/docker.service 修改以ExecStart开头的行\nExecStart= ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 刷新一下配置\nsystemctl daemon-reload systemctl restart docker docker start registry "});index.add({'id':222,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.6.context/','title':"3.6.context",'content':"3.6.context 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。\n为什么需要Context 基本示例 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var wg sync.WaitGroup // 初始的例子 func worker() { for { fmt.Println(\u0026quot;worker\u0026quot;) time.Sleep(time.Second) } // 如何接收外部命令实现退出？？？ wg.Done() } func main() { wg.Add(1) go worker() // 如何优雅的实现结束子goroutine？？？ wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } 全局变量方式 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var wg sync.WaitGroup var exit bool // 全局变量方式存在的问题： // 1. 使用全局变量在跨包调用时不容易统一 // 2. 如果worker中再启动goroutine，就不太好控制了。 func worker() { for { fmt.Println(\u0026quot;worker\u0026quot;) time.Sleep(time.Second) if exit { break } } wg.Done() } func main() { wg.Add(1) go worker() time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出 exit = true // 修改全局变量实现子goroutine的退出 wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } 通道方式 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var wg sync.WaitGroup // 管道方式存在的问题： // 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel func worker(exitChan chan struct{}) { LOOP: for { fmt.Println(\u0026quot;worker\u0026quot;) time.Sleep(time.Second) select { case \u0026lt;-exitChan: // 等待接收上级通知 break LOOP default: } } wg.Done() } func main() { var exitChan = make(chan struct{}) wg.Add(1) go worker(exitChan) time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出 exitChan \u0026lt;- struct{}{} // 给子goroutine发送退出信号 close(exitChan) wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } 官方版的方案 package main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var wg sync.WaitGroup func worker(ctx context.Context) { LOOP: for { fmt.Println(\u0026quot;worker\u0026quot;) time.Sleep(time.Second) select { case \u0026lt;-ctx.Done(): // 等待上级通知 break LOOP default: } } wg.Done() } func main() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } 当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可：\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var wg sync.WaitGroup func worker(ctx context.Context) { go worker2(ctx) LOOP: for { fmt.Println(\u0026quot;worker\u0026quot;) time.Sleep(time.Second) select { case \u0026lt;-ctx.Done(): // 等待上级通知 break LOOP default: } } wg.Done() } func worker2(ctx context.Context) { LOOP: for { fmt.Println(\u0026quot;worker2\u0026quot;) time.Sleep(time.Second) select { case \u0026lt;-ctx.Done(): // 等待上级通知 break LOOP default: } } } func main() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } Context初识 Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。\n对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。\nContext接口 context.Context是一个接口，该接口定义了四个需要实现的方法。具体签名如下：\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} } 其中:\n Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）； Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel； Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值；  如果当前Context被取消就会返回Canceled错误； 如果当前Context超时就会返回DeadlineExceeded错误；   Value方法会从Context中返回键对应的值，对于同一个上下文来说，多次调用Value 并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；  Background()和TODO() Go内置两个函数：Background()和TODO()，这两个函数分别返回一个实现了Context接口的background和todo。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的partent context，衍生出更多的子上下文对象。\nBackground()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。\nTODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。\nbackground和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。\nWith系列函数 此外，context包中还定义了四个With系列函数。\nWithCancel WithCancel的函数签名如下：\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) WithCancel返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。\n取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。\nfunc gen(ctx context.Context) \u0026lt;-chan int { dst := make(chan int) n := 1 go func() { for { select { case \u0026lt;-ctx.Done(): return // return结束该goroutine，防止泄露 case dst \u0026lt;- n: n++ } } }() return dst } func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 当我们取完需要的整数后调用cancel for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } } } 上面的示例代码中，gen函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免gen启动的内部goroutine发生泄漏。\nWithDeadline WithDeadline的函数签名如下：\nfunc WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) 返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。\n取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。\nfunc main() { d := time.Now().Add(50 * time.Millisecond) ctx, cancel := context.WithDeadline(context.Background(), d) // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。 // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。 defer cancel() select { case \u0026lt;-time.After(1 * time.Second): fmt.Println(\u0026quot;overslept\u0026quot;) case \u0026lt;-ctx.Done(): fmt.Println(ctx.Err()) } } 上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用context.WithDeadline(context.Background(), d)得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印overslept退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以ctx.Done()会先接收到值，上面的代码会打印ctx.Err()取消原因。\nWithTimeout WithTimeout的函数签名如下：\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) WithTimeout返回WithDeadline(parent, time.Now().Add(timeout))。\n取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) // context.WithTimeout var wg sync.WaitGroup func worker(ctx context.Context) { LOOP: for { fmt.Println(\u0026quot;db connecting ...\u0026quot;) time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case \u0026lt;-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\u0026quot;worker done!\u0026quot;) wg.Done() } func main() { // 设置一个50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } WithValue WithValue函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：\nfunc WithValue(parent Context, key, val interface{}) Context WithValue返回父节点的副本，其中与key关联的值为val。\n仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。\n所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口。\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) // context.WithValue type TraceCode string var wg sync.WaitGroup func worker(ctx context.Context) { key := TraceCode(\u0026quot;TRACE_CODE\u0026quot;) traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code if !ok { fmt.Println(\u0026quot;invalid trace code\u0026quot;) } LOOP: for { fmt.Printf(\u0026quot;worker, trace code:%s\\n\u0026quot;, traceCode) time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case \u0026lt;-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\u0026quot;worker done!\u0026quot;) wg.Done() } func main() { // 设置一个50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) // 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合 ctx = context.WithValue(ctx, TraceCode(\u0026quot;TRACE_CODE\u0026quot;), \u0026quot;12512312234\u0026quot;) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\u0026quot;over\u0026quot;) } 使用Context的注意事项  推荐以参数的方式显示传递Context 以Context作为参数的函数方法，应该把Context作为第一个参数。 给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO() Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数 Context是线程安全的，可以放心的在多个goroutine中传递  客户端超时取消示例 server端 // context_timeout/server/main.go package main import ( \u0026quot;fmt\u0026quot; \u0026quot;math/rand\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;time\u0026quot; ) // server端，随机出现慢响应 func indexHandler(w http.ResponseWriter, r *http.Request) { number := rand.Intn(2) if number == 0 { time.Sleep(time.Second * 10) // 耗时10秒的慢响应 fmt.Fprintf(w, \u0026quot;slow response\u0026quot;) return } fmt.Fprint(w, \u0026quot;quick response\u0026quot;) } func main() { http.HandleFunc(\u0026quot;/\u0026quot;, indexHandler) err := http.ListenAndServe(\u0026quot;:8000\u0026quot;, nil) if err != nil { panic(err) } } client端 // context_timeout/client/main.go package main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) // 客户端 type respData struct { resp *http.Response err error } func doCall(ctx context.Context) { transport := http.Transport{ // 请求频繁可定义全局的client对象并启用长链接 // 请求不频繁使用短链接 DisableKeepAlives: true, } client := http.Client{ Transport: \u0026amp;transport, } respChan := make(chan *respData, 1) req, err := http.NewRequest(\u0026quot;GET\u0026quot;, \u0026quot;http://127.0.0.1:8000/\u0026quot;, nil) if err != nil { fmt.Printf(\u0026quot;new requestg failed, err:%v\\n\u0026quot;, err) return } req = req.WithContext(ctx) // 使用带超时的ctx创建一个新的client request var wg sync.WaitGroup wg.Add(1) defer wg.Wait() go func() { resp, err := client.Do(req) fmt.Printf(\u0026quot;client.do resp:%v, err:%v\\n\u0026quot;, resp, err) rd := \u0026amp;respData{ resp: resp, err: err, } respChan \u0026lt;- rd wg.Done() }() select { case \u0026lt;-ctx.Done(): //transport.CancelRequest(req) fmt.Println(\u0026quot;call api timeout\u0026quot;) case result := \u0026lt;-respChan: fmt.Println(\u0026quot;call server api success\u0026quot;) if result.err != nil { fmt.Printf(\u0026quot;call server api failed, err:%v\\n\u0026quot;, result.err) return } defer result.resp.Body.Close() data, _ := ioutil.ReadAll(result.resp.Body) fmt.Printf(\u0026quot;resp:%v\\n\u0026quot;, string(data)) } } func main() { // 定义一个100毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100) defer cancel() // 调用cancel释放子goroutine资源 doCall(ctx) } "});index.add({'id':223,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%A0%91/','title':"6.树",'content':"6.树 树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。\n正因为树有这样的性质，大部分关于树的面试题都与递归有关，换句话说，面试官希望通过一道关于树的问题来考察你对于递归算法掌握的熟练程度。\n树的形状 在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。\n对于一些特殊的树，例如红黑树（Red-Black Tree）、自平衡二叉搜索树（AVL Tree），一般在面试中不会被问到，除非你所涉及的研究领域跟它们相关或者你十分感兴趣，否则不需要特别着重准备。\n关于树的考题，无非就是要考查树的遍历以及序列化（serialization)。\n树的遍历 1. 前序遍历（Preorder Traversal） 方法：先访问根节点，然后访问左子树，最后访问右子树。在访问左、右子树的时候，同样，先访问子树的根节点，再访问子树根节点的左子树和右子树，这是一个不断递归的过程。  应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。\n2. 中序遍历（Inorder Traversal） 方法：先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边。  应用场景：最常见的是二叉搜索树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。\n3. 后序遍历（Postorder Traversal） 方法：先访问左子树，然后访问右子树，最后访问根节点。  应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。\n注意： 掌握好这三种遍历的递归写法和非递归写法是非常重要的，懂得分析各种写法的时间复杂度和空间复杂度同样重要。\n无论是前端工程师，还是后端工程师，在准备面试的时候，树这个数据结构都是最应该花时间学习的，既能证明你对递归有很好的认识，又能帮助你学习图论（关于图论，我们将在下一节课一起讨论）。树的许多性质都是面试的热门考点，尤其是二叉搜索树（BST）。\n"});index.add({'id':224,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/','title':"函数进阶",'content':"函数进阶 位置参数 位置参数这个东西我们并不陌生，之前所编写的函数使用的就是位置参数。位置参数，顾名思义，传入函数时每个参数都是通过位置来作区分的。函数调用时，传入的值需按照位置与参数一一对应。\ndef overspeed_rate(current, max, min): if current \u0026gt; max: return (current - max) / max # 超过最大时速，结果为正 elif current \u0026lt; min: return (current - min) / min # 超过最小时速，结果为负 else: return 0 # 不超速，结果为 0 参数默认值 def 函数(参数1, 参数2=默认值): pass 关键字参数 我们还可以在函数调用时，以 参数名=值 的形式来向指定的参数传入值。\noverspeed_rate(100, min=80) 任意参数列表 定义函数时，在参数列表中使用 **参数名，可以接收一切关键字参数。类似的，参数列表中使用 *参数名，就可以接受任意数量的非关键字参数，也就是可变参数。 如，计算任意个数的乘积：\ndef multiply(*nums): result = 1 for n in nums: result *= n return result \u0026gt;\u0026gt;\u0026gt; multiply(1,3,5,7) 105 这个函数能接收任意个参数，这正是 *nums 所发挥的作用。函数所有接收到的非关键字参数组装成一个元组，并绑定到 nums 上。来试验一下：\n\u0026gt;\u0026gt;\u0026gt; def multiply(*nums): … print(nums) … \u0026gt;\u0026gt;\u0026gt; multiply(1, 2, 3, 4, 5) (1, 2, 3, 4, 5) 多返回值 典型情况下，函数只有一个返回值，但是 Python 也支持函数返回多个返回值。\n要返回多个返回值，只需在 return 关键字后跟多个值（依次用逗号分隔）。\ndef date(): import datetime d = datetime.date.today() return d.year, d.month, d.day "});index.add({'id':225,'href':'/docs/shell/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/','title':"流量控制语句",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':226,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.7.map/','title':"2.7.map",'content':"2.7.map  2.7.map  "});index.add({'id':227,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/','title':"2.8.函数",'content':"2.8.函数  2.8.1.函数 2.8.2.函数进阶 2.8.3.内置函数  "});index.add({'id':228,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/7.%E6%B3%9B%E5%9E%8B%E9%80%92%E5%BD%92.%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92/','title':"7.泛型递归.树的递归",'content':"7.泛型递归.树的递归 "});index.add({'id':229,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.7.%E5%86%A0%E8%AF%8D/','title':"1.7.冠词",'content':"1.7.冠词 "});index.add({'id':230,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.7.%E6%8E%A5%E5%8F%A3/','title':"2.1.7.接口",'content':"2.1.7.接口 接口定义的基本语法 [修饰符] interface 接口名 [extends 父接口1, 父接口2\u0026hellip;] { 零个到多个常量定义 零个到的讴歌抽象方法的定义 }\n接口定义 常量:\n接口中的属性是常量,即使定义时不添加public static final 修饰符, 系统也会自动加上\n方法:\n接口中的方法只能是抽象方法,总是使用, 即使定义时不添加public abstract修饰符,系统也会自动加上。\n使用接口 一个类可以实现一个或多个接口, 实现接口使用implements关键字. java中一个类只能继承一个父类,是不够灵活的，通过 实现多个接口可以做补充\n继承父类实现接口的语法为: [修饰符] class 类名 extends 父类 implements 接口1, 接口2\u0026hellip; { 类体部分 //如果继承了抽象类，需要实现继承的抽象方法;要实现接口中的抽象方法 }\n如果要继承父类,继承父类必须在实现接口之前\n"});index.add({'id':231,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.7.%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/','title':"2.14.7.并发安全和锁",'content':"2.14.7.并发安全和锁 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。\n举个例子：\nvar x int64 var wg sync.WaitGroup func add() { for i := 0; i \u0026lt; 5000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。\n互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：\nvar x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i \u0026lt; 5000; i++ { lock.Lock() // 加锁 x = x + 1 lock.Unlock() // 解锁 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。\n读写互斥锁 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。\n读写锁示例：\nvar ( x int64 wg sync.WaitGroup rwlock sync.RWMutex ) func write() { // lock.Lock() // 加互斥锁 rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设写操作耗时10毫秒 rwlock.Unlock() // 解写锁 // lock.Unlock() // 解互斥锁 wg.Done() } func read() { // lock.Lock() // 加互斥锁 rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 // lock.Unlock() // 解互斥锁 wg.Done() } func main() { start := time.Now() for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go write() } for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go read() } wg.Wait() end := time.Now() fmt.Println(end.Sub(start)) } 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。\nsync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：\n   方法名 功能     (wg * WaitGroup) Add(delta int) 计数器+delta   (wg *WaitGroup) Done() 计数器-1   (wg *WaitGroup) Wait() 阻塞直到计数器变为0    sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。\n我们利用sync.WaitGroup将上面的代码优化一下：\nvar wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\u0026quot;Hello Goroutine!\u0026quot;) } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\u0026quot;main goroutine done!\u0026quot;) wg.Wait() } 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。\nsync.Once 说在前面的话：这是一个进阶知识点。\n在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。\nsync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) {} 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用。\n加载配置文件示例 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\nvar icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \u0026quot;left\u0026quot;: loadIcon(\u0026quot;left.png\u0026quot;), \u0026quot;up\u0026quot;: loadIcon(\u0026quot;up.png\u0026quot;), \u0026quot;right\u0026quot;: loadIcon(\u0026quot;right.png\u0026quot;), \u0026quot;down\u0026quot;: loadIcon(\u0026quot;down.png\u0026quot;), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\nfunc loadIcons() { icons = make(map[string]image.Image) icons[\u0026quot;left\u0026quot;] = loadIcon(\u0026quot;left.png\u0026quot;) icons[\u0026quot;up\u0026quot;] = loadIcon(\u0026quot;up.png\u0026quot;) icons[\u0026quot;right\u0026quot;] = loadIcon(\u0026quot;right.png\u0026quot;) icons[\u0026quot;down\u0026quot;] = loadIcon(\u0026quot;down.png\u0026quot;) } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。\n使用sync.Once改造的示例代码如下：\nvar icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \u0026quot;left\u0026quot;: loadIcon(\u0026quot;left.png\u0026quot;), \u0026quot;up\u0026quot;: loadIcon(\u0026quot;up.png\u0026quot;), \u0026quot;right\u0026quot;: loadIcon(\u0026quot;right.png\u0026quot;), \u0026quot;down\u0026quot;: loadIcon(\u0026quot;down.png\u0026quot;), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 并发安全的单例模式 下面是借助sync.Once实现的并发安全的单例模式：\npackage singleton import ( \u0026quot;sync\u0026quot; ) type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\nsync.Map Go语言中内置的map不是并发安全的。请看下面的示例：\nvar m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\u0026quot;k=:%v,v:=%v\\n\u0026quot;, key, get(key)) wg.Done() }(i) } wg.Wait() } 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。\n像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。\nvar m = sync.Map{} func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(\u0026quot;k=:%v,v:=%v\\n\u0026quot;, key, value) wg.Done() }(i) } wg.Wait() } "});index.add({'id':232,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.7.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/','title':"2.2.7.类型转换",'content':"2.2.7.类型转换 类型强转 Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。\n强制类型转换的基本语法如下：\nT(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.\n比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。\nfunc sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } 使用sprintf 把其它类型转换string类型 int:%d, float:%f, bool:%t, byte:%c\n类型使用 %T\n通过strconv 把其它类型转换string类型 strconv.FormatInt()\nstring类型转成整型 "});index.add({'id':233,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%87%BD%E6%95%B0/','title':"函数",'content':"函数  函数是一种类型,函数类型变量可以像其他类型变量一样使用,可以作为其他函数的参数或返回值,也可以直接调用执行。 函数支持多值返回 支持闭包 函数支持可变参数  基本概念 函数定义 func funcName(param-list) (result-list) { function-body }  函数的特点 1、函数可以没有输入, 也可以没有返回值(默认返回0) 2、多个相邻的相同类型的参数可以使用简写模式: func add(a, b int) int { //a int, b int 简写为 a,b int return a + b } 3、支持有名的返回值,参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化为类型零值， 最后的return可以不带参数名直接返回 func add(a, b int) (sum int) { sum = a + b return //return sum的简写模式 // sum := a + b // 如果是 sum:=a + b, 则相当于新声明一个sum变量命名返回变量sum覆盖 // return sum //最后需要显示的调用return sum } 4、不支持默认值参数 5、不支持函数重载 6、不支持函数嵌套，严格地说是不支持命名函数的嵌套定义，但支持嵌套匿名函数 func add(a, b int) (sum int) { anonymouse := function(x, y int) int { return x + y } return anonymouse(a, b) }  多值返回 func swap(a, b int) (int, int) { return b, a }  实参到形参的传递 package main import \u0026quot;fmt\u0026quot; func chvalue(a int) int { a = a + 1 return a } func chpointer(a *int) { *a = *a + 1 return } func main() { a := 10 chvalue(a) //实参传递给形参是值拷贝 fmt.Println(a) chpointer(\u0026amp;a) // 实参传递给形参仍然是值拷贝,只不过复制的是a的地址值 fmt.Println(a) }  不定参数 go 函数支持不定数目的形式参数, 不定参数声明使用param ...type的语法形式 函数的不定参数有如下几个特点: 1、所有的不定参数类型必须是相同的 2、不定参数必须是函数的最后一个参数 3、不定参数名在函数体内相当于切片，对切片的操作同同样适合对不定参数的操作: 例如: func sum(arr ...int) (sum int) { for _, v := range arr { //此时arr就相当于切片,可以使用range访问 sum += v } return } 4、切片可以作为参数传递给不定参数,切片名后要加上\u0026quot;...\u0026quot;。 例如: func sum(arr ...int) (sum int) { sum += v } func main() { slice := []int{1,2,3,4} array := [...]int{1,2,3,4} sum(slice...) } 5、形参不定参数的函数和形参为切片的函数类型不相同. 例如: func suma(arr ...int) (sum int) { for v := range arr { sum += v } return } func sumb(arr []int) (sum int) { for v := range arr { sum += v } return } // suma和sumb的类型并不一样 fmt.Printf(\u0026quot;%T\\n\u0026quot;, suma) //func(...int) fmt.Printf(\u0026quot;%T\\n\u0026quot;, sumb) //func([]int)  函数签名和匿名函数 函数签名 函数类型又叫函数签名,一个函数的类型就是函数定义首行去掉函数名,参数名和{, 可以使用fmt.Printf的%T 格式化参数打印函数的类型。 package main import \u0026quot;fmt\u0026quot; func add(a, b int) int { return a + b } func main() { fmt.Printf(\u0026quot;%T\\n\u0026quot;, add) // func(int, int) int } 两个函数类型相同的条件是: 拥有相同的形参列表和返回值列表(列表元素的次序、个数和类型都相同), 形参名可以不同。 以下2个函数的参数类型完全一样. func add(a, b int) int {return a + b} func sub(x int, y int) (c int) {c = x -y; return c} 可以使用type定义函数类型, 函数类型变量可以作为函数的参数或返回值. package main import \u0026quot;fmt\u0026quot; func add(a, b int) int { return a + b } func sub(a, b int) int { return a - b } type Op func(int, int) int // 定义一个函数类型,输入的是两个int类型,返回值是一个int类型 func do(f Op, a, b int) int { // 定义一个函数,第一个参数是函数类型Op return f(a, b)\t//函数类型变量可以直接用来进行函数调用 } func main() { a := do(add, 1, 2) // 函数名add可以当做相同函数类型形象,不需要强制类型转换 fmt.Println(a) // 3 s := do(sub, 1, 3) fmt.Println(s) // -1 } 函数类型和map, slice, chan一样, 实际函数类型变量和函数名都可以当做指针变量,该指针执行函数代码的 开始位置. 通常说函数类型变量是一种引用类型，未初始化的函数类型的变量默认值是nil Go中函数是\u0026quot;第一公民\u0026quot;, 有名函数的函数名可以看做函数类型的常量，可以直接使用函数名调用函数，也可以直接 赋值给函数类型变量, 后续通过该变量来调用该函数. package main func sum(a, b int) int { return a + b } func main() { sum(3, 4) // 直接调用 f := sum //有名函数可以直接赋值给变量 f(1, 3) }  匿名函数 package main import \u0026quot;fmt\u0026quot; // 匿名函数被直接复制函数变量 var sum = func(a, b int) int { return a + b } func doinput(f func(int, int) int, a, b int) int { return f(a, b) } // 匿名函数作为返回值 func wrap(op string) func(int, int) int { switch op { case \u0026quot;add\u0026quot;: return func(a, b int) int { return a + b } case \u0026quot;sub\u0026quot;: return func(a int, b int) int { return a - b } default: return nil } } func main() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() sum(1, 2) // 匿名函数作为实参 doinput(func(x int, y int) int { return x + y }, 1, 2) opFunc := wrap(\u0026quot;add\u0026quot;) re := opFunc(2, 3) fmt.Printf(\u0026quot;%d\\n\u0026quot;, re) }  defer defer关键字, 可以注册多个延迟调用 package main func main() { // 先进后出 defer func() { println(\u0026quot;firts\u0026quot;) }() defer func() { println(\u0026quot;second\u0026quot;) }() println(\u0026quot;function body\u0026quot;) } defer后面必须是函数或方法, 不能是语句。 defer函数的实参在注册时通过值拷贝传递进去. 主动调用os.Exit(int)退出进程时,defer将不再被执行(即使defer已经提前注册) package main import \u0026quot;os\u0026quot; func main() { defer func() { println(\u0026quot;defer\u0026quot;) //这种情况 不执行 }() println(\u0026quot;func body\u0026quot;) os.Exit(1) } defer的好处是可以在一定程度上避免资源泄露, 特定是在有很多return语句, 有多个资源需要关闭的场景中，很 容易漏掉资源的关闭操作. defer语句的位置不当, 有可能导致panic, 一般defer语句放在错误检查语句之后 defer也有明显的副作用; defer会推迟资源的释放，defer尽量不要放到循环语句里面, 将大函数内部的defer 语句单独拆分成一个小函数是一种很好的实践方式. 另外，defer相当于普通的函数调用需要间接的数据结构的支持。 相对于普通函数调用有一定的性能耗损。 defer中最好不要对有名返回值参数进行操作，否则会引发匪夷所思的结果  闭包 闭包是由函数及其相关引用环境组合而成的实体, 一般通过在匿名函数中引用外部函数的局部变量或包全局变量构成。 闭包 = 函数 + 引用环境 闭包对闭包外的环境引入是直接引用,编译器检测到闭包，会将闭包引用的外部变量分配到堆上。 如果函数返回的闭包引用了该函数的局部变量(参数或函数内部变量) (1) 多次调用该函数，返回的多个闭包所引用的外部变量是多个副本，原因是每个调用函数都会为局部变量分配内存。 (2) 用一个闭包函数多次, 如果该闭包修改了其引用的外部变量。则每一次调用该闭包对该外部变量都有影响，因为闭包函数共享外部引用。 package main func fa(a int) func(i int) int { return func(i int) int { println(\u0026amp;a, a) a = a + i return a } } func main() { f := fa(1) // f引用的外部的闭包环境包括本次函数调用的形参a的值1 g := fa(1) //g引用的外部的闭包环境包括本次函数调用的形参a的值1 println(f(1)) //多次调用f引用的是同一个副本a println(f(1)) // g中a的值仍然是1 println(g(1)) println(g(1)) } f和g引用的是不同的a 如果一个函数调用返回的闭包引用修改了全局变量,则每次调用都会影响全局变量。 如果函数返回的闭包引用的是全局变量a, 则多次调用该函数返回的多个闭包引用的都是同一个a。同理,调用一个闭包 多次引用的也是同一个a。此时如果闭包中修改了a值的逻辑,则每次闭包调用都会影响全局变量a的值。 使用闭包是为了减少全局变量,所以闭包引用全局变量不是好的编程方式。  "});index.add({'id':234,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/8.%E5%88%86%E6%B2%BB.%E5%9B%9E%E6%BA%AF/','title':"8.分治.回溯",'content':"8.分治.回溯 "});index.add({'id':235,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.8.%E4%BB%8B%E8%AF%8D/','title':"1.8.介词",'content':"1.8.介词 "});index.add({'id':236,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.8.%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/','title':"2.14.8.原子操作",'content':"2.14.8.原子操作 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。\natomic包    方法 解释     func LoadInt32(addr *int32) (val int32) 读取操作   func LoadInt64(addr *int64) (val int64)    func LoadUint32(addr *uint32) (val uint32)    func LoadUint64(addr *uint64) (val uint64)    func LoadUintptr(addr *uintptr) (val uintptr)    func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)    func StoreInt32(addr *int32, val int32) 写入操作   func StoreInt64(addr *int64, val int64)    func StoreUint32(addr *uint32, val uint32)    func StoreUint64(addr *uint64, val uint64)    func StoreUintptr(addr *uintptr, val uintptr)    func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)    func AddInt32(addr *int32, delta int32) (new int32) 修改操作   func AddInt64(addr *int64, delta int64) (new int64)    func AddUint32(addr *uint32, delta uint32) (new uint32)    func AddUint64(addr *uint64, delta uint64) (new uint64)    func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)    func SwapInt32(addr *int32, new int32) (old int32) 交换操作   func SwapInt64(addr *int64, new int64) (old int64)    func SwapUint32(addr *uint32, new uint32) (old uint32)    func SwapUint64(addr *uint64, new uint64) (old uint64)    func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)    func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)    func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 比较并交换操作   func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)    func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)    func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)    func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)    func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)     示例 我们填写一个示例来比较下互斥锁和原子操作的性能。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;sync/atomic\u0026quot; \u0026quot;time\u0026quot; ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(\u0026amp;a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(\u0026amp;a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { c.Inc() wg.Done() }() } wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start)) } func main() { c1 := CommonCounter{} // 非并发安全 test(c1) c2 := MutexCounter{} // 使用互斥锁实现并发安全 test(\u0026amp;c2) c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高 test(\u0026amp;c3) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。\n"});index.add({'id':237,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A5%E5%8F%A3/','title':"接口",'content':"接口 语法 type Traversal interface { Traverse() }  duck typing 定义 使用者-\u0026gt;实现者\n接口由使用者定义\n接口的实现: 接口的实现是隐式的\n只要实现接口里的方法\n接口的值类型 fmt.printf(\u0026quot;%T, %v\u0026quot;, 接口变量, 接口变量) #打印接口类型和值 // r.(type) r的类型 switch v := r.(type) { case mock.Retriever: case *real.Retrieve: } // type assertion r.(*real.Retruever) 或 r, ok := r.(mock.Retruever) if ok != nil { fmt.Printf(\u0026quot;Err: %s\u0026quot;, ok) } 接口变量里面有什么: * 接口变量自带指针 * 接口变量同样采用值传递, 几乎不需要使用接口的指针 * 指针接收者实现只能以指针方式使用； 值接收者都可以  接口的组合 // 把Retriever和poster接口组合成一个接口 type RetrieverPoster interface { Retriever Poster }  常用接口 string reader writer  "});index.add({'id':238,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.9.%E6%8C%87%E9%92%88/','title':"2.9.指针",'content':"2.9.指针  2.9.1.指针  "});index.add({'id':239,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/9.%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/','title':"9.深度优先搜索和广度优先搜索",'content':"9.深度优先搜索和广度优先搜索 "});index.add({'id':240,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.9.%E8%BF%9E%E8%AF%8D/','title':"1.9.连词",'content':"1.9.连词 "});index.add({'id':241,'href':'/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E5%8F%91/','title':"并发",'content':"并发 进程、线程、协程   进程:\n 进程是什么? 一种系统运行行动 进程的定位是什么? 程序的执行实体 进程长什么样子? 在terminal中查看 进程怎么使用? [一般情况]一个程序一个进程, [多进程]一个程序多个进程    线程:\n 线程是什么? 运算调度的最小单元 线程的作用是什么? 同时运算多个任务 和进程有什么区别? 大哥和小弟的关系 线程内存大小?\n怎么\u0026quot;切\u0026rdquo;? 内核控制\n\u0026ldquo;切多大\u0026rdquo;? 缓存+内核控制\n\u0026ldquo;等长吗\u0026rdquo;? 不等长 线程观摩  回到我们的terminal 输入命令ps -M [pid] 查看对应pid的线程      协程\n 协程(Coroutine)是什么? 轻量级的线程 协程的定位是什么? 用户控制的函数 有什么样的优势? 协程优势  协程的内存消耗更小  一个线程可以包含多个协程 线程大约8MB的内存申请量 协程大概2kb的内存申请量   上下文切换更快  协程少一道手续 线程申请内存, 需要走过内核 协程申请内存，不需要走过内核        灵魂Goroutine\n Goroutine是什么? 一种协程(Coroutine) Goroutine和协程有怎样的关系? 一种优化 为什么使用Goroutine?  去掉了冗余的协程声明周期管理  协程创建 协程完成 协程重用   降低额外的延迟和开销  由于协程简频繁交互导致的   降低加锁/解锁的频率 a. 降低一部分额外的开销   Goroutine如何使用    多协程的核心机理 什么是多协程?  官方定义: 一段时间内协程的并行 实际应用: 某个任务使用多个协程同时进行处理  多协程的相对性  同时处理非同一道菜的食材 不算多协程 同时处理同一道菜的食材 算多协程 同时处理同一道菜的同一种食材 算多协程  多协程的使用场景  运算比较多的流程上 协程间依赖性比较弱  channel阻塞 阻塞条件:\n输入channel的数据量不等于channel能接受的量\nchannel阻塞的严重后果 程序位置: 非主流程 channel下游获取不到结果， 造成数据丢失\n程序位置: 主流课 主流程卡带，整个程序沉睡，股中昂级别P0级别\nchannel解决办法 设定channel缓冲:\nmake(chan int, 10) 10=channel的大小,即可以放多少个元素 channel的大小如何设定: 一般根据业务场景需求来\n如何利用channel阻塞 实现资源争抢\n实现多协程锁, 变相的\u0026quot;锁\u0026rdquo;\n实现消息定额消费\n"});index.add({'id':242,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/','title':"2.10.结构体",'content':"2.10.结构体  2.10.1.结构体  "});index.add({'id':243,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/10.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/','title':"10.贪心算法",'content':"10.贪心算法Greedy 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最优利)的选择,从而希望导致结果是全局最好或最优的算法\n贪心算法与动态规范不同点 贪心算法对每个子问题的解决方案都做出选择，不能回退 动态规划则会保存以前的运算结果,并根据以前的结果对当前进行选择，有回退功能\n贪心法可以解决一些最优化问题, 如: 求图中的最小生成树、求哈夫曼编码等，然而对于功能和生活中的问题, 贪心法一般不能得到我们所要求的答案。\n一旦一个问题可以通过贪心算法来解决, 那么贪心算法一般是解决这个问题的最好办法. 由于贪心法的高效性以及其所求得的答案比较接近最优结果,贪心法也可以用作辅助算法 或者直接解决一些要求结果不特别精确的问题。\n"});index.add({'id':244,'href':'/docs/english/1.%E8%AF%8D%E7%B1%BB/1.10.%E6%84%9F%E5%8F%B9%E8%AF%8D/','title':"1.10.感叹词",'content':"1.10.感叹词 "});index.add({'id':245,'href':'/docs/chart/','title':"Chart",'content':"图 "});index.add({'id':246,'href':'/docs/git/','title':"git",'content':"Git 目录 "});index.add({'id':247,'href':'/docs/linux/','title':"Linux",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':248,'href':'/docs/nginx/','title':"Nginx",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':249,'href':'/docs/shell/','title':"Shell",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':250,'href':'/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/','title':"数据结构\u0026算法",'content':"数据结构\u0026amp;算法 数据结构\n算法\n"});index.add({'id':251,'href':'/docs/suanfa/','title':"算法",'content':"算法 "});index.add({'id':252,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.11.%E5%8C%85/','title':"2.11.包",'content':"2.11.包  2.11.1.包  "});index.add({'id':253,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/11.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/','title':"11.二分查找",'content':"11.二分查找 二分查找的前提  目标函数单调性(单调递增或者递减) 存在上下界（bounded） 能够通过索引访问 (index)  代码模板 left, right = 0, len(array) - 1 while left \u0026lt;= right: mid = (left + right)/ 2 if array[mid] == target: # find the target!! break or return result elif array[mid] \u0026lt; target: left = mid + 1 else: right = mid - 1 "});index.add({'id':254,'href':'/docs/java/1.1.java%E5%88%9D%E4%BD%93%E9%AA%8C/','title':"1.1.java初体验",'content':"1.1.java初体验 "});index.add({'id':255,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.12.%E6%8E%A5%E5%8F%A3/','title':"2.12.接口",'content':"2.12.接口  2.12.1.接口  "});index.add({'id':256,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/','title':"12.动态规划",'content':"12.动态规划 "});index.add({'id':257,'href':'/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/','title':"1.2.变量和常量",'content':"1.2.变量与常量 "});index.add({'id':258,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/','title':"2.13.反射",'content':"2.13.反射  2.13.1.变量的内在机制 2.13.2.反射介绍 2.13.3.reflect包 2.13.4.结构体反射  "});index.add({'id':259,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/13.%E5%AD%97%E5%85%B8%E6%A0%91%E5%92%8C%E5%B9%B6%E6%9F%A5%E9%9B%86/','title':"13.字典树和并查集",'content':"13.字典树和并查集 "});index.add({'id':260,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/','title':"2.14.并发",'content':"2.14.并发  2.14.1.并发与并行 2.14.2.goroutine 2.14.3.goroutine与线程 2.14.4.channel 2.14.5.worker pool (goroutine池) 2.14.6.select多路复用 2.14.7.并发安全和锁 2.14.8.原子操作  "});index.add({'id':261,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/14.%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/','title':"14.高级搜索",'content':"14.高级搜索 "});index.add({'id':262,'href':'/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/','title':"1.4.流程控制语句",'content':"1.4.流程控制语句 "});index.add({'id':263,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/15.%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8Cavl%E6%A0%91/','title':"15.红黑树和 a v L树",'content':"15.红黑树和AVL树 "});index.add({'id':264,'href':'/docs/java/1.5.%E6%95%B0%E7%BB%84/','title':"1.5.数组",'content':"1.5.数组 "});index.add({'id':265,'href':'/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/','title':"2.16.单元测试",'content':"2.16.单元测试  2.16.1.gotest工具 2.16.2.测试函数 2.16.3.基准测试 2.16.4.Setup与TearDown  "});index.add({'id':266,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/16.%E4%BD%8D%E8%BF%90%E7%AE%97/','title':"16.位运算",'content':"16.位运算 "});index.add({'id':267,'href':'/docs/java/1.6.%E5%A4%9A%E7%BA%BF%E7%A8%8B/','title':"1.6.多线程",'content':"1.5.多线程  线程就是独立的执行路径 在程序运行时,即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程 main()称之为主线程，为系统的入口，用于执行整个程序 在一个进程中,如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的 ，  线程简介 线程实现(重点) 线程状态 线程同步(重点) 线程通信问题 高级主题 "});index.add({'id':268,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/17.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Clru%E7%BC%93%E5%AD%98/','title':"17.布隆过滤器和 L R U缓存",'content':"17.布隆过滤器和LRU缓存 "});index.add({'id':269,'href':'/docs/java/1.7.%E6%B3%A8%E8%A7%A3/','title':"1.7.注解",'content':"1.7.注解  Java中的常见注解 注解分类 自定义注解  "});index.add({'id':270,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/18.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/','title':"18.排序算法",'content':"18.排序算法 "});index.add({'id':271,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/19.%E9%AB%98%E7%BA%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/','title':"19.高级动态规划",'content':"19.高级动态规划 "});index.add({'id':272,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/20.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/','title':"20.字符串算法",'content':"20.字符串算法 "});index.add({'id':273,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/','title':"算法系列",'content':"算法系列 "});index.add({'id':274,'href':'/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/','title':"2.1.类和对象",'content':"2.1.类和对象 "});index.add({'id':275,'href':'/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/','title':"2.2.集合框架",'content':"2.2.集合框架  2.2.1.集合的概念 2.2.2.Collection接口 2.2.3.List接口和实现类 2.2.4.泛型和工具类 2.2.5.Set接口和实现类 2.2.6.Map接口和实现类  "});index.add({'id':276,'href':'/docs/java/3.1.%E5%BC%82%E5%B8%B8/3.1.1.%E5%BC%82%E5%B8%B8/','title':"3.1.1.异常",'content':"异常 Error Exception 继承 Throwable\ntry { // 一些会抛出异常的方法 } catch(Exception e) { // 处理该异常的代码块 } try { } catch (InputMismatchException e) { } catch (ArithmeticException e) { } try { } catch (Exception e) { } catch (Exception2 e) { } ...(n个catch块)... { } finally { // 最终将要执行的一些代码 } "});index.add({'id':277,'href':'/docs/java/4.1.maven/','title':"4.1.maven",'content':"4.1.maven 学习视频: https://www.bilibili.com/video/BV1kK411A7GW?p=1\n"});index.add({'id':278,'href':'/docs/java/4.2.spring/','title':"4.2.spring",'content':"4.2.spring 教程: https://www.bilibili.com/video/BV1Wv41167TU?from=search\u0026amp;seid=15736291704501694534\n"});index.add({'id':279,'href':'/docs/java/4.3.sprintboot/','title':"4.3.spring boot",'content':"4.3.spring boot 教程: https://www.imooc.com/video/16350\n"});index.add({'id':280,'href':'/docs/java/4.4.mybatis/','title':"4.4.Mybatis",'content':"4.4.Mybatis 教程: https://www.bilibili.com/video/BV1mE411X7yp?p=5\n"});index.add({'id':281,'href':'/docs/java/4.5.springcloud/','title':"4.5.Spring Cloud",'content':"4.5.Spring Cloud 教程: https://www.bilibili.com/video/BV1mE411X7yp?p=5\nsprint cloud netflix : https://www.springcloud.cc/spring-cloud-netflix.html 中文api文档: https://springcloud.cc/spring-cloud-dalston.html springCloud中国社区 http://springcloud.cn springCloud中文网: https://springcloud.cc\n"});index.add({'id':282,'href':'/docs/%E4%BA%94%E7%AC%94/','title':"五笔",'content':"五笔教程 转载: https://www.bilibili.com/video/BV1Dc41187B3?p=1\n1.汉字结构(五笔) 左右、上下、杂合型\n2.汉字有五种基本笔画 横 竖 撇 捺 折  3.五笔基本概念 3.1 键名汉字  3.2 一级简码  3.3 单笔画  3.4 成字字根  3.5 二级简码、三级简码、全码  3.6 重码(即:重复的编码)  4.字根详解 4.1 横区 4.1.1.G  4.1.2.F  4.1.3.D  4.1.4.S  4.1.5.A  4.2 竖区 4.2.1.H  4.2.1.J  4.2.1.K  4.2.1.L  4.2.1.M  4.3 撇区 4.3.1.T  4.3.2.R  4.3.3.E    4.3.4.W    4.3.5.Q  4.4 捺区 4.4.1.Y    4.4.2.U    4.4.3.I  4.4.4.O  4.4.5.P  4.5 折区 4.5.1.N    4.5.2.B    4.5.3.V  4.5.4.C  4.5.5.X  5. 拆分原则  书写顺序 取大优先 兼顾直观 能散不连 能连不交  6.取码规则 汉字的取码规则:\n 键名汉字 成字字根 单笔画 一级简码 二级简码、三级简码、全码    7.末笔交叉识别码  7.1 识别码的特殊情况    8.词组取码规则      "});index.add({'id':283,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/','title':"架构师",'content':"架构师 "});index.add({'id':284,'href':'/docs/java/1.7.%E6%B3%A8%E8%A7%A3/1.7.1.java%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/','title':"1.7.1.java中的常见注解",'content':"1.7.1.java中的常见注解 JDK自带注解  @Override 覆盖父类的方法 @Deprecated 表示已经过时 @Suppvisewarnings @SuppressWarning(\u0026ldquo;deprecation\u0026rdquo;) 忽略deprecation警告  java第三方注解 Spring  @Autowired @Service @Repository  Mybatis  @InsertProvider @UpdateProvider @Options  "});index.add({'id':285,'href':'/docs/java/1.7.%E6%B3%A8%E8%A7%A3/1.7.2.%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%88%86%E7%B1%BB/','title':"1.7.2.注解的分类",'content':"1.7.2.注解的分类 按照运行机制分  源码注解: 注解只在源码中存在,编译成.class文件就不存在了 编译时注解: 注解在源码和.class文件中都存在 (包括: @OVerride @Deprecated, @Suppvi 运行时注解: 在运行阶段还起作用,甚至会影响运行逻辑的注解 (ps: @Autowired)  按照来源分  来自JDK的注解 来自第三方的注解 我们自己定义的注解  自定义注解 TODO::\n"});index.add({'id':286,'href':'/docs/git/git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6/','title':"Git移除已经add的文件",'content':"git 移除已经add的文件 使用 git rm 命令即可，有两种选择,  一种是 git rm \u0026ndash;cached “文件路径”，不删除物理文件，仅将该文件从缓存中删除； 一种是 git rm \u0026ndash;f “文件路径”，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。  请问 git rm \u0026ndash;cache 和 git reset HEAD 的区别到底在哪里呢？ 如果要删除文件，最好用 git rm file_name，而不应该直接在工作区直接 rm file_name。\n如果一个文件已经add到暂存区，还没有 commit，此时如果不想要这个文件了 有两种方法：\n 1，用版本库内容清空暂存区，git reset HEAD 但要慎重使用 2，只把特定文件从暂存区删除，git rm \u0026ndash;cached xxx  "});index.add({'id':287,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.3.log/','title':"3.3.log",'content':""});index.add({'id':288,'href':'/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.4.strconv/','title':"3.4.strconv",'content':""});index.add({'id':289,'href':'/docs/go/5.golang%E9%AB%98%E7%BA%A7/%E5%9C%A8-go-%E4%B8%AD%E6%81%B0%E5%88%B0%E5%A5%BD%E5%A4%84%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/','title':"在 Go 中恰到好处的内存对齐",'content':"https://segmentfault.com/a/1190000017527311\n"});index.add({'id':290,'href':'/docs/go/5.golang%E9%AB%98%E7%BA%A7/%E6%B7%B1%E5%85%A5golang%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8Bgmp%E6%A8%A1%E5%9E%8B/','title':"深入 Golang调度器之 G M P模型",'content':"https://www.cnblogs.com/sunsky303/p/9705727.html\n"});index.add({'id':291,'href':'/docs/go/readgo/go%E9%98%85%E8%AF%BB/100.%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BBgo%E4%BB%A3%E7%A0%81/','title':"100.如何高效阅读go代码",'content':""});index.add({'id':292,'href':'/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E4%B8%8D%E8%83%BD%E5%8F%96%E5%9C%B0%E5%9D%80/','title':"不能取地址",'content':"cannot take address of temporary variables\n"});index.add({'id':293,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/yum/','title':"Yum",'content':""});index.add({'id':294,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E6%BA%90%E7%A0%81%E5%8C%85%E7%AE%A1%E7%90%86/','title':"源码包管理",'content':""});index.add({'id':295,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85/','title':"脚本安装包",'content':""});index.add({'id':296,'href':'/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/1.helloworld/','title':"1.helloworld",'content':""});index.add({'id':297,'href':'/docs/%E6%95%B0%E6%8D%AE%E5%92%8C%E7%AE%97%E5%95%8A/1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/','title':"1.基本概念",'content':"基本概念 数据 是能输入计算机且能被计算机处理的各种符号的集合\n数据元素 是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理。也简称为元素，或记录、节点或顶点。\n数据项 构成数据元素的不可分割的最小单位\n数据对象 是性质相同的数据元素的结合,是数据的一个子集。\n例如: 整数数据对象是集合N={0,1,-1,\u0026hellip;}\n数据结构  数据元素不是孤立存在的,他们之间存在着某种关系,数据元素相互之间的关机称为结构 是指相互之间存在一种或多种特定关系的数据元素集合  数据结构两个层次: 逻辑结构，物理结构\n逻辑结构的种类1: 线性结构: 有且仅有一个开始和一个终端节点,并且所有节点都最多只有一个直接前驱和一个直接后继。  非线性结构: 一个节点可能有多个直接前驱和直接后继  逻辑结构的种类2:  集合结构 结构中的数据元素之间除了同属于一个集合的关系外,无任何其它关系 线性结构 结构中的数据元素之间存在着一对一的线性关系 树形结构 结构中的数据元素之间存在着一对多的层次关系 图状结构或网状结构 结构中的数据元素之间存在着多对多的任意关系  存储结构的种类 顺序存储结构  用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示 c语言中用数组来实现顺序存储结构  链式存储结构  用一组任意的存储单元存储数据元素,数据元素之间的逻辑用指针来表示 c语言中用指针来实现链式存储表示  索引存储结构  在存储节点信息的同时，还建立附加的索引表  散列存储结构  根据节点的关键字直接计算出该节点的存储地址  数据类型和抽象数据类型  在使用高级程序设计语言编写程序时,必须对程序中出现的每个变量、常量或表达式,明确说明他们所属的数据类型  例如: C语言中  提供int,char, float, double等基本数据类型 数组、结构、共用体、枚举等构造数据类型 还有指针,空(void)类型 用户也可用typedef自己定义数据类型     一些最基本数据结构可以用数据类型来实现,如数组、字符串等 而另一些常用的数据结构,如栈、队列、树、图等,不能直接用数据类型来表示 高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围,以及 在这些数值范围上所允许进行的操作  "});index.add({'id':298,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/restapi%E8%A7%84%E8%8C%83/','title':"Restapi规范",'content':"restapi规范 规范 URI 设计原则  资源必须使用复数名词表示集合，如果该词语没有合适的复数形式，则应该使用单数形式  例如： GET /employees GET /weather 必须使用正斜杠（/）表示层次关系 正斜杠（/）字符用于URI的路径部分，以指示资源之间的层次关系。 例如： GET /employees/56   不应该在URI中使用尾部正斜杠（/）\n  应该使用连字符（ - ）来提高URI的可读性，不应该使用下划线（ _ ）\n  必须在URI中使用小写字母\n  资源包含父子嵌套关系必须遵循以下原则\n  如果该资源脱离父资源后没有意义，则如下设计，例如：文件的某行与文件的关系 GET /file/1000/line/20 如果该资源可以独立访问或可以从属于多个父资源，则不用嵌套显示， 例如：专辑和歌曲的关系 GET /albums/151 GET /songs/10 版本控制 由于一个API服务可以提供多个API接口，如果有不兼容和破坏性的更改，版本号将让你能更容易的发布API。版本控制格式约定为：vN（N=1,2,3\u0026hellip;）\n例如: GET /api/v1/employees/123 GET /api/v2/employees/123 资源操作 HTTP方法 资源操作必须尽可能使用正确的HTTP方法，并且必须遵守操作幂等性。HTTP方法通常被称为HTTP动词。\n   方法 安全 幂等     GET 是 是   POST 否 否   PUT 否 是   DELETE 否 是   PATCH 否 否   OPTIONS 是 是   HEAD 是 是    关于以上方法的说明：\n GET 用于从服务器获取某个资源的信息  完成请求后返回状态码 200 OK 完成请求后需要返回被请求的资源详细信息   POST 用于创建新资源  创建完成后返回状态码 201 Created 完成请求后需要返回被创建的资源详细信息   PUT 用于完整的替换资源，比如修改 id 为 123 的某个资源  如果是替换了资源，则返回 200 OK 完成请求后需要返回被修改的资源详细信息   PATCH 用于局部更新资源  完成请求后返回状态码 200 OK 完成请求后需要返回被修改的资源详细信息   DELETE 用于删除某个资源  完成请求后返回状态码 204 No Content   OPTIONS 用于获取资源支持的所有 HTTP 方法 HEAD 用于只获取请求某个资源返回的头信息  自定义动词 实际业务场景中，对资源对象的控制，如升级、上传、移动等操作，用以上规范约束并不能保证API语义的唯一性、可理解性、易用性，因此，允许使用自定义动词去显示表达API的语义，统一格式为：\n/{prefix}/{version}/{resources}:{action} 动词命名请参照自定义动词命名规范 例如，文件导入导出：\n/v1/some/resource:import /v1/some/resource:export 除此之外，撤销操作则使用cancel关键字与该动词用英文连字符-相连。\n例如，停止导入：\n/v1/some/resource/name:import-cancel 请求约束 请求约束  GET, DELETE, HEAD 方法，参数风格必须为标准的 GET 风格的参数，如 ?a=1\u0026amp;b=2 POST, PUT, PATCH, OPTIONS 方法 默认情况下请求实体会被视作标准 json 字符串进行处理，应该设置头信息的 Content-Type 为 application/json，在一些特殊接口中，可以允许 Content-Type 为 application/x-www-form-urlencoded 或者 multipart/form-data ，此时请求实体会被视作标准 POST 风格的参数进行处理 在特殊场景下，例如查询参数长度超过浏览器限制、不允许使用DELETE方法等，可以使用POST方法代替 使用过滤查询时，基本查询和高级查询必须不能同时使用  参数命名  参数定义必须使用 lower_case_underscore_separated_names 格式 参数名称必须是英文或英文和数字的组合 参数名称不应该包含介词（例如for、during、at）  reason_for_error 应该改成 error_reason cpu_usage_at_time_of_failure 应该改成 failure_time_cpu_usage  参数名称不应该使用后置形容词（名词后面的修饰符  例如： items_collected 应该改成 collected_items objects_imported 应该改成 imported_objects 响应约束 响应约束 客户端请求头如果没有提供Accept，默认的响应结果格式应该是application/json，否则应该使用请求头中Accept指定的格式响应。\n响应结果必须使用HTTP标准响应码\n 成功，响应数据为资源本身的描述 失败，响应数据为错误描述，且必须包含error对象 响应示例  调用成功 HTTP/1.1 200 OK Content-Type: application/json { \u0026quot;total\u0026quot;: 910, \u0026quot;items\u0026quot;:[{}, {} ...] } 调用失败，详见错误示例\n错误 如果是一个不支持的请求或者请求失败，服务必须提供一个错误响应结果，这个错误响应结果必须是一个标准的HTTP 错误码。\n响应示例 错误响应信息必须使用 error 字段，例如： 数据类型 安全 特殊场景 分页 过滤 排序 跨域 "});index.add({'id':299,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/','title':"二叉搜索树的操作",'content':"二叉搜索树的操作 添加\n修改\n查找\n删除\n"});index.add({'id':300,'href':'/docs/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E6%A0%91%E7%9A%843%E7%A7%8D%E9%81%8D%E5%8E%86/','title':"树的3种遍历",'content':"代码:树的3种遍历 package main import ( \u0026quot;fmt\u0026quot; ) type node struct { Val string Left *node Right *node } type bst struct { root *node } /* m k l h i j a b c d e f */ func (tree *bst) buildTree() { m := \u0026amp;node{Val: \u0026quot;m\u0026quot;} tree.root = m k := \u0026amp;node{Val: \u0026quot;k\u0026quot;} l := \u0026amp;node{Val: \u0026quot;l\u0026quot;} m.Left = k m.Right = l h := \u0026amp;node{Val: \u0026quot;h\u0026quot;} i := \u0026amp;node{Val: \u0026quot;i\u0026quot;} k.Left = h k.Right = i a := \u0026amp;node{Val: \u0026quot;a\u0026quot;} b := \u0026amp;node{Val: \u0026quot;b\u0026quot;} h.Left = a h.Right = b c := \u0026amp;node{Val: \u0026quot;c\u0026quot;} d := \u0026amp;node{Val: \u0026quot;d\u0026quot;} i.Left = c i.Right = d j := \u0026amp;node{Val: \u0026quot;j\u0026quot;} l.Right = j e := \u0026amp;node{Val: \u0026quot;e\u0026quot;} f := \u0026amp;node{Val: \u0026quot;f\u0026quot;} j.Left = e j.Right = f } // 先序遍历（根左右）：m k h a b i c d l j e f func (tree *bst) inOrder() []string { res := make([]string, 0) var inner func(n *node) inner = func(n *node) { if n == nil { return } res = append(res, n.Val) inner(n.Left) inner(n.Right) } inner(tree.root) return res } // 中序遍历（左根右）：a h b k c i d m l e j f func (tree *bst) midOrder() []string { res := make([]string, 0) var inner func(n *node) inner = func(n *node) { if n == nil { return } inner(n.Left) res = append(res, n.Val) inner(n.Right) } inner(tree.root) return res } // 后序遍历（左右根）：a b h c d i k e f j l m func (tree *bst) lastOrder() []string { res := make([]string, 0) var inner func(n *node) inner = func(n *node) { if n == nil { return } inner(n.Left) inner(n.Right) res = append(res, n.Val) } inner(tree.root) return res } func main() { tree := \u0026amp;bst{} tree.buildTree() fmt.Println(tree.inOrder()) fmt.Println(tree.midOrder()) fmt.Println(tree.lastOrder()) } 结果: /private/var/folders/fw/md_z65fd6sb4jsxc2sjy358h0000gn/T/___go_build_go_english_a [m k h a b i c d l j e f] [a h b k c i d m l e j f] [a b h c d i k e f j l m] "});index.add({'id':301,'href':'/posts/','title':"Posts",'content':""});index.add({'id':302,'href':'/docs/','title':"Docs",'content':""});index.add({'id':303,'href':'/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E5%A0%86%E6%A0%88/','title':"堆栈",'content':"堆栈 "});})();