<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on 坚持:多读书</title>
    <link>https://ruichengm1987.github.io/</link>
    <description>Recent content in Introduction on 坚持:多读书</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://ruichengm1987.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1.1.1 java的特性与版本</title>
      <link>https://ruichengm1987.github.io/docs/java/1.1.java%E5%88%9D%E4%BD%93%E9%AA%8C/1.1.1.java%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E7%89%88%E6%9C%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.1.java%E5%88%9D%E4%BD%93%E9%AA%8C/1.1.1.java%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E7%89%88%E6%9C%AC/</guid>
      <description>1.2.1 关键字 java的特性 开源、跨平台
java的版本 j2se 1.8</description>
    </item>
    
    <item>
      <title>1.1.名词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.1.%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.1.%E5%90%8D%E8%AF%8D/</guid>
      <description>1.1.名词 1️⃣ 名词分类 1.1.1.专有名词  专有名词是个别的人、地、物、团体、机构等的专用名称 专有名词中实词的第一个字母要大写
Beijing, Tom, the People&amp;rsquo;s Republic of China 专有名词如含有普通名词的短语,必须用定冠词the the Great Wall 长城 姓氏名采用复数形式
the Greens 格林一家人  1.1.2.普通名词  普通名词: 是许多人或事物的共有名称 pupil, family, man, foot  1.2.1.可数名词  可数名词是可以用数词进行计算的名词  box, child, orange
1.2.2.不可数名词  不可数名词是不可以数词进行计数的名词  water, news, oil
2️⃣ 单数-复数 规则  +s map-&amp;gt;maps, boy-&amp;gt;bodys, horse-&amp;gt;horses, table-&amp;gt;tables s, o, x, sh, ch 结尾的词加es class-&amp;gt;classes, box-&amp;gt;boxes, hero-&amp;gt;heroes, dish-&amp;gt;dishes bench-&amp;gt;benches
【注】:少数以o结尾的词,变复数时只加s photo-&amp;gt;photos, piano-&amp;gt;pianos 以辅音字母加y结尾的名词,变y为i,再加es family-&amp;gt;families, city-&amp;gt;cities, party-&amp;gt;parties 以f或fe结尾的名词,变f或fe为v,再加es shelf-&amp;gt;shelves, wolf-&amp;gt;wolves, life-&amp;gt;lives, knife-&amp;gt;knives  不规则 man-&amp;gt;men</description>
    </item>
    
    <item>
      <title>1.1.安装</title>
      <link>https://ruichengm1987.github.io/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.1.%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.1.%E5%AE%89%E8%A3%85/</guid>
      <description>1.1.安装 linux 下安装  wget https://dl.google.com/go/go1.x.x.linux-amd64.tar.gz 下载安装包 tar -C /usr/local -zxvf go1.x.x.linux-amd64.tar.gz 添加/usr/loacl/go/bin目录到PATH变量中。添加到/etc/profile 或$HOME/.profile都可以  vim /etc/profile export GOROOT=/usr/local/go #设置为go安装的路径,有些安装包会自动设置默认的goroot export GOPATH=/usr/local/goprojects/ #GO项目路径多个用&amp;rsquo;,&amp;lsquo;分开 export PATH=$PATH:$GOROOT/bin:$GOPATH/bin #加载 source /etc/profile   执行go version，如果现实版本号，则Go环境安装成功.  </description>
    </item>
    
    <item>
      <title>1.1.本地创建一个Git仓库</title>
      <link>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.1.%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgit%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.1.%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgit%E4%BB%93%E5%BA%93/</guid>
      <description>1.1.本地创建一个Git仓库 ~ mkdir test ~ cd test ~/test git init 已初始化空的 Git 仓库于 /Users/ruichengm/test/.git/ ~/test(master) ls -al total 0 drwxr-xr-x 3 ruichengm staff 96 7 18 08:46 . drwxr-xr-x+ 107 ruichengm staff 3424 7 18 08:47 .. drwxr-xr-x 9 ruichengm staff 288 7 18 08:46 .git 认识.git ➜ .git git:(master) ls -al total 24 drwxr-xr-x 10 song staff 320 6 25 22:11 . drwxr-xr-x 3 song staff 96 6 25 22:11 .</description>
    </item>
    
    <item>
      <title>1.2.1 关键字</title>
      <link>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.1.%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.1.%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>1.2.1 关键字 Java 中常用关键字：
 Java 关键字是区分大小写的哦！所以 void 是关键字，但 Void 就不是了~~</description>
    </item>
    
    <item>
      <title>1.4.1 if</title>
      <link>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.1.if/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.1.if/</guid>
      <description>1.4.1 if if  if else  多重if  嵌套if  </description>
    </item>
    
    <item>
      <title>1.5.1.数组</title>
      <link>https://ruichengm1987.github.io/docs/java/1.5.%E6%95%B0%E7%BB%84/1.5.1.%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.5.%E6%95%B0%E7%BB%84/1.5.1.%E6%95%B0%E7%BB%84/</guid>
      <description>1.5.1 数组  声明数组 语法： 数据类型[ ] 数组名；
或者 数据类型 数组名[ ]；
 分配空间 语法： 数组名 = new 数据类型 [ 数组长度 ];
 话说，我们也可以将上面的两个步骤合并，在声明数组的同时为它分配空间，如：
 赋值 分配空间后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 scores 数组中存放学生成绩
scores[0] = 89; 处理数组中数据 在 Java 中还提供了另外一种直接创建数组的方式，它将声明数组、分配空间和赋值合并完成，如  等价于:  使用循环操作 Java 中的数组   其中， 数组名.length 用于获取数组的长度</description>
    </item>
    
    <item>
      <title>1.kafka概述</title>
      <link>https://ruichengm1987.github.io/docs/kafka/1.kafka%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/kafka/1.kafka%E6%A6%82%E8%BF%B0/</guid>
      <description>1.kafka概述 定义 kafka 是一个分布式的基于发布/订阅模式的消息队列, 主要应用于大数据实时处理领域
消息队列的作用 削峰、解耦
消息队列的两种模式 点对点模式、发布/订阅模式 发布/订阅模式:分为消息队列主动推，消费者主动拉，这2种模式， kafka属于后种(但是这种有个缺点需要客户端维护轮训)
kafka基础架构 </description>
    </item>
    
    <item>
      <title>2.1.1.标识符与关键字</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.1.%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.1.%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>2.1.1.标识符与关键字 标识符 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。
关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。
Go语言中有25个关键字：
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，Go语言中还有37个保留字。
Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover </description>
    </item>
    
    <item>
      <title>2.1.1.类和对象</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <description>2.1.1.类和对象 类的定义  类的实例化  局部变量和全局变量  作用域  局部变量: 仅限于定义它的方法 成员变量: 整个类的内部  构造方法    static静态变量  static静态方法  1、静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。如：  如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。如：  2、在普通成员方法中，则可以直接访问同类的非静态变量和静态变量，如下所示：  3、静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。如：  static静态初始化块  在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。
需要特别注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
 </description>
    </item>
    
    <item>
      <title>2.1.主语</title>
      <link>https://ruichengm1987.github.io/docs/english/2.%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/2.1.%E4%B8%BB%E8%AF%AD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/2.%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/2.1.%E4%B8%BB%E8%AF%AD/</guid>
      <description>2.1.主语 </description>
    </item>
    
    <item>
      <title>2.1.常用命令</title>
      <link>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.1.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.1.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>2.1.常用命令 镜像相关命令 查看镜像 docker images 搜索镜像 docker search centos 镜像拉取 docker pull centos:7 删除镜像 # 按镜像id删除镜像 docker rmi 镜像id(imageId) # 删除所有镜像 docker rmi `docker images -q` 容器相关命令 查看容器 # 查看正在运行的容器 docker ps # 查看所有容器 docker ps -a # 查看最后一次运行的容器 docker ps -l # 查看停止的容器 docker ps -f status=exited 创建与启动容器 创建容器常用的参数说明:
创建容器命令:
docker run  -i: 表示运行容器 -t: 表示容器启动后进入其命令行。加入这个两个参数后, 容器创建就能登录进去。即分配一个伪终端 &amp;ndash;name: 为创建的容器命名 -v: 表示目录映射关系(前者是宿主机目录,后者是映射到宿主机上的目录), 可以使用多个v做多个目录或文件映射.注意: 最好做目录映射,在宿主机上做修改,然后共享到容器上。 -d:在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器,如果只加-i-t两个参数，创建后就会自动进去容器)。 -p: 表示端口映射,前者是宿主机端口,后者是容器内的映射端口,可以使用多个-p做多个端口映射 更多参数执行: docker run &amp;ndash;help 查看  1.</description>
    </item>
    
    <item>
      <title>2.10.1.类型别名和自定义类型</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.1.%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.1.%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</guid>
      <description>2.10.1.类型别名和自定义类型 Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。
自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。
自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：
//将MyInt定义为int类型 type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性。
类型别名 类型别名是Go1.9版本添加的新功能。
类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。
type TypeAlias = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下：
type byte = uint8 type rune = int32 类型定义和类型别名的区别 类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。
//类型定义 type NewInt int //类型别名 type MyInt = int func main() { var a NewInt var b MyInt fmt.Printf(&amp;quot;type of a:%T\n&amp;quot;, a) //type of a:main.NewInt fmt.Printf(&amp;quot;type of b:%T\n&amp;quot;, b) //type of b:int } 结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</description>
    </item>
    
    <item>
      <title>2.11.1.包</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.11.%E5%8C%85/2.11.1.%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.11.%E5%8C%85/2.11.1.%E5%8C%85/</guid>
      <description>2.11.1.包 在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。
包介绍 包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、os、io等。
定义包 我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放.go文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。
package 包名 注意事项：
 一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。 包名可以不和文件夹的名字一样，包名不能包含 - 符号。 包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。  可见性 如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。
举个例子， 我们定义一个包名为pkg2的包，代码如下：
package pkg2 import &amp;quot;fmt&amp;quot; // 包变量可见性 var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用 // 首字母大写外部包可见，可在其他包中使用 const Mode = 1 type person struct { // 首字母小写，外部包不可见，只能在当前包内使用 name string } // 首字母大写，外部包可见，可在其他包中使用 func Add(x, y int) int { return x + y } func age() { // 首字母小写，外部包不可见，只能在当前包内使用 var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用 fmt.</description>
    </item>
    
    <item>
      <title>2.12.1.接口</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.12.%E6%8E%A5%E5%8F%A3/2.12.1.%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.12.%E6%8E%A5%E5%8F%A3/2.12.1.%E6%8E%A5%E5%8F%A3/</guid>
      <description>2.12.1.接口 接口类型 在Go语言中接口（interface）是一种类型，一种抽象的类型。
interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。
为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。
为什么要使用接口 type Cat struct{} func (c Cat) Say() string { return &amp;quot;喵喵喵&amp;quot; } type Dog struct{} func (d Dog) Say() string { return &amp;quot;汪汪汪&amp;quot; } func main() { c := Cat{} fmt.Println(&amp;quot;猫:&amp;quot;, c.Say()) d := Dog{} fmt.Println(&amp;quot;狗:&amp;quot;, d.Say()) } 上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？
像类似的例子在我们编程过程中会经常遇到：
比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？
比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？
比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？
Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。
接口的定义 Go语言提倡面向接口编程。
每个接口由数个方法组成，接口的定义格式如下：
type 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 其中:
 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。  举个例子:</description>
    </item>
    
    <item>
      <title>2.13.1.变量的内在机制</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.1.%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%9C%A8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.1.%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%9C%A8%E6%9C%BA%E5%88%B6/</guid>
      <description>2.13.1.变量的内在机制 Go语言中的变量是分为两部分的:
 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。  </description>
    </item>
    
    <item>
      <title>2.14.1.并发与并行</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.1.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.1.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/</guid>
      <description>2.14.1.并发与并行 并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。
并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。
Go语言的并发通过goroutine实现。goroutine类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。
Go语言还提供channel在多个goroutine间进行通信。goroutine和channel是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</description>
    </item>
    
    <item>
      <title>2.16.1.gotest工具</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.1.gotest%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.1.gotest%E5%B7%A5%E5%85%B7/</guid>
      <description>gotest工具 Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。
go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。
在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。
   类型 格式 作用     测试函数 函数名前缀为Test 测试程序的一些逻辑行为是否正确   基准函数 函数名前缀为Benchmark 测试函数的性能   示例函数 函数名前缀为Example 为文档提供示例文档    go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</description>
    </item>
    
    <item>
      <title>2.2.1.整型</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.1.%E6%95%B4%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.1.%E6%95%B4%E5%9E%8B/</guid>
      <description>2.2.1.整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。
   类型 描述     uint8 无符号8位整型   uint16 无符号16位整型   uint32 无符号32位整型   uint64 无符号64位整型   int8 有符号8位整型   int16 有符号16位整型   int32 有符号32位整型   int64 有符号64位整型    特殊整型    类型 描述     uint 32位操作系统上就是uint32, 64位操作系统就是uint64   int 32位操作系统上就是int32， 64位操作系统就是int64   uintptr 无符号整型, 用于存放一个指针    注意: 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。</description>
    </item>
    
    <item>
      <title>2.2.1.集合的概念</title>
      <link>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.1.%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.1.%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>2.2.1.集合的概念   对象的容器,定义了对多个对象进行操作的常用方法。可实现数组的功能。
  和数组的区别
 数组长度固定，集合长度不固定 数组可以存储基本类型和引用类型，集合只能存储引用类型    位置: java.util.*
  </description>
    </item>
    
    <item>
      <title>2.3.1.算术运算符</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.1.%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.1.%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>2.3.1.算术运算符    运算符 描述     + 相加   - 相减   * 相乘   / 相除   % 求余    注意： ++（自增）和&amp;ndash;（自减）在Go语言中是单独的语句，并不是运算符。</description>
    </item>
    
    <item>
      <title>2.4.1.if</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.1.if/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.1.if/</guid>
      <description>2.4.1.if(分支结构).md if条件判断基本写法 Go语言中if条件判断的格式如下：
if 表达式1 { 分支1 } else if 表达式2 { 分支2 } else{ 分支3 } 当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的else if和else都是可选的，可以根据实际需要进行选择。
Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 同理，与else匹配的{也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。
举个例子：
func ifDemo1() { score := 65 if score &amp;gt;= 90 { fmt.Println(&amp;quot;A&amp;quot;) } else if score &amp;gt; 75 { fmt.Println(&amp;quot;B&amp;quot;) } else { fmt.Println(&amp;quot;C&amp;quot;) } } if条件判断特殊写法 if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：
func ifDemo2() { if score := 65; score &amp;gt;= 90 { fmt.Println(&amp;quot;A&amp;quot;) } else if score &amp;gt; 75 { fmt.</description>
    </item>
    
    <item>
      <title>2.5.数组</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.5.%E6%95%B0%E7%BB%84/2.5.%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.5.%E6%95%B0%E7%BB%84/2.5.%E6%95%B0%E7%BB%84/</guid>
      <description>数组 数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：
// 定义一个长度为3元素类型为int的数组a var a [3]int 数组定义 var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。
var a [3]int var b [4]int a = b //不可以这样做，因为此时a和b是不同的类型 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。
数组的初始化 方法一 初始化数组时可以使用初始化列表来设置数组元素的值。
var testArray [3]int //数组会初始化为int类型的零值 var numArray = [3]int{1, 2} //使用指定的初始值完成初始化 方法二 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：
var numArray = [...]int{1, 2} 方法三 我们还可以使用指定索引值的方式来初始化数组，例如:
a := [...]int{1: 1, 3: 5} 数组的遍历 遍历数组a有以下两种方法：
func main() { var a = [...]string{&amp;quot;北京&amp;quot;, &amp;quot;上海&amp;quot;, &amp;quot;深圳&amp;quot;} // 方法1：for循环遍历 for i := 0; i &amp;lt; len(a); i++ { fmt.</description>
    </item>
    
    <item>
      <title>2.6.切片</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/2.6.%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/2.6.%E5%88%87%E7%89%87/</guid>
      <description>切片 引子 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：
func arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum + v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，
a := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。
切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。
切片的定义 声明切片类型的基本语法如下：
var name []T 其中，
 name:表示变量名 T:表示切片中的元素类型 举个例子：  func main() { // 声明切片类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 var d = []bool{false, true} //声明一个布尔切片并初始化 fmt.</description>
    </item>
    
    <item>
      <title>2.7.map</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.7.map/2.7.map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.7.map/2.7.map/</guid>
      <description>2.7.map Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。
map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。
map定义 Go语言中 map的定义语法如下：
map[KeyType]ValueType 其中
 KeyType:表示键的类型。 ValueType:表示键对应的值的类型。 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：  make(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。
map基本使用 map中的数据都是成对出现的，map的基本使用示例代码如下：
func main() { scoreMap := make(map[string]int, 8) scoreMap[&amp;quot;张三&amp;quot;] = 90 scoreMap[&amp;quot;小明&amp;quot;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[&amp;quot;小明&amp;quot;]) fmt.Printf(&amp;quot;type of a:%T\n&amp;quot;, scoreMap) } 输出：
map[小明:100 张三:90] 100 type of a:map[string]int map也支持在声明的时候填充元素，例如：
func main() { userInfo := map[string]string{ &amp;quot;username&amp;quot;: &amp;quot;沙河小王子&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;123456&amp;quot;, } fmt.Println(userInfo) // } 判断某个键是否存在 Go语言中有个判断map中键是否存在的特殊写法，格式如下:
value, ok := map[key] 举个例子：
func main() { scoreMap := make(map[string]int) scoreMap[&amp;quot;张三&amp;quot;] = 90 scoreMap[&amp;quot;小明&amp;quot;] = 100 // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值 v, ok := scoreMap[&amp;quot;张三&amp;quot;] if ok { fmt.</description>
    </item>
    
    <item>
      <title>2.8.1.函数</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.1.%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.1.%E5%87%BD%E6%95%B0/</guid>
      <description>2.8.1.函数 Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。
函数定义 Go语言中定义函数使用func关键字，具体格式如下：
func 函数名(参数)(返回值){ 函数体 } 其中:
 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名 参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔。 函数体：实现指定功能的代码块。  我们先来定义一个求两个数之和的函数：
func intSum(x int, y int) int { return x + y } 函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：
func sayHello() { fmt.Println(&amp;quot;Hello 沙河&amp;quot;) } 函数的调用 定义了函数之后，我们可以通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：
func main() { sayHello() ret := intSum(10, 20) fmt.Println(ret) } 注意，调用有返回值的函数时，可以不接收其返回值。
参数 类型简写 函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：
func intSum(x, y int) int { return x + y } 上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型。
可变参数 可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加&amp;hellip;来标识。
注意：可变参数通常要作为函数的最后一个参数。
举个例子：
func intSum2(x .</description>
    </item>
    
    <item>
      <title>2.9.1.指针</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.9.%E6%8C%87%E9%92%88/2.9.1.%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.9.%E6%8C%87%E9%92%88/2.9.1.%E6%8C%87%E9%92%88/</guid>
      <description>2.9.1.指针 区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。
要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。
任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。
比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭。
Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&amp;amp;（取地址）和*（根据地址取值）。
指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。
取变量指针的语法如下：
ptr := &amp;amp;v // v的类型为T 其中:
 v:代表被取地址的变量，类型为T ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。 举个例子:  func main() { a := 10 b := &amp;amp;a fmt.Printf(&amp;quot;a:%d ptr:%p\n&amp;quot;, a, &amp;amp;a) // a:10 ptr:0xc00001a078 fmt.Printf(&amp;quot;b:%p type:%T\n&amp;quot;, b, b) // b:0xc00001a078 type:*int fmt.Println(&amp;amp;b) // 0xc00000e018 } 我们来看一下b := &amp;amp;a的图示：
 指针取值 在对普通变量使用&amp;amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。
func main() { //指针取值 a := 10 b := &amp;amp;a // 取变量a的地址，将指针保存到b中 fmt.Printf(&amp;quot;type of b:%T\n&amp;quot;, b) c := *b // 指针取值（根据指针去内存取值） fmt.</description>
    </item>
    
    <item>
      <title>3.1.fmt</title>
      <link>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.1.fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.1.fmt/</guid>
      <description>3.1.fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。
向外输出 标准库fmt提供了以下几种输出相关函数。
print Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。
func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) 举个简单的例子：
func main() { fmt.Print(&amp;quot;在终端打印该信息。&amp;quot;) name := &amp;quot;沙河小王子&amp;quot; fmt.Printf(&amp;quot;我是：%s\n&amp;quot;, name) fmt.Println(&amp;quot;在终端打印单独一行显示&amp;quot;) } 执行上面的代码输出：
在终端打印该信息。我是：沙河小王子 在终端打印单独一行显示 Fprint Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。
func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a .</description>
    </item>
    
    <item>
      <title>4.2.1.spring</title>
      <link>https://ruichengm1987.github.io/docs/java/4.2.spring/4.2.1.spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/4.2.spring/4.2.1.spring/</guid>
      <description>4.2.1.spring 核心 Ioc(控制反转)    Di(依赖注入) </description>
    </item>
    
    <item>
      <title>bug规则</title>
      <link>https://ruichengm1987.github.io/docs/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/bug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/bug/</guid>
      <description>bug 规则 研发BUG处理规范  BUG状态及时更新，附BUG状态说明  New - 新创建，该状态P0/P1级别问题不要超过一天，P2不超过2天 Assign - 已分配 Duplicate - 重复bug，通过链接把相关bug link在一起 Invalid - 无效bug Wontfix - 确认是bug，但是无需修复 workaround - 确认是bug，但是可以通过其他方式绕过 Worksforme - 无法复现，需要测试提供更多信息 Fixed - 已修复   BUG及时分配给对应人员，同时写明原因，不是自己处理范围的问题不要挂在自己身上 BUG及时回复，通过文字记录修复过程，避免口口相传  Track过程中阶段性结论 与相关人员沟通的信息   BUG修复，写清楚修复逻辑以及对应build版本号  便于测试理解修复原理 便于后续Review问题    </description>
    </item>
    
    <item>
      <title>Go Test 单元测试简明教程</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/test/</guid>
      <description>Go Test 单元测试简明教程 1.如何写好单元测试 单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。
如何写好单元测试呢？
首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 mock。
然后，写可测试的代码。&amp;ldquo;高内聚,低耦合&amp;rdquo; 是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。
接下来将介绍如何使用 Go 语言的标准库 testing 进行单元测试。
2.一个简单例子 Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。
example/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下:
package main func Add(a int, b int) int { return a + b } func Mul(a int, b int) int { return a * b } 那么 calc_test.go 中的测试用例可以这么写：</description>
    </item>
    
    <item>
      <title>Linux命令行快捷键</title>
      <link>https://ruichengm1987.github.io/docs/linux/1.linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/1.linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>Linux命令行快捷键 涉及在linux命令行下进行快速移动光标、命令编辑、编辑后执行历史命令、Bang(!)命令、控制命令等。让basher更有效率。
常用 ctrl+左右键:在单词之间跳转 * ctrl+a:跳到本行的行首 * ctrl+e:跳到页尾 Ctrl+u：删除当前光标前面的文字 （还有剪切功能） ctrl+k：删除当前光标后面的文字(还有剪切功能) Ctrl+L：进行清屏操作 Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容 Ctrl+w:删除光标前面的单词的字符 Alt – d ：由光标位置开始，往右删除单词。往行尾删 说明 Ctrl – k: 先按住 Ctrl 键，然后再按 k 键； Alt – k: 先按住 Alt 键，然后再按 k 键； M – k：先单击 Esc 键，然后再按 k 键。 移动光标 Ctrl – a ：移到行首 Ctrl – e ：移到行尾 Ctrl – b ：往回(左)移动一个字符 Ctrl – f ：往后(右)移动一个字符 Alt – b ：往回(左)移动一个单词 Alt – f ：往后(右)移动一个单词 Ctrl – xx ：在命令行尾和光标之间移动 M-b ：往回(左)移动一个单词 M-f ：往后(右)移动一个单词 编辑命令 Ctrl – h ：删除光标左方位置的字符 Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端） Ctrl – w ：由光标位置开始，往左删除单词。往行首删 Alt – d ：由光标位置开始，往右删除单词。往行尾删 M – d ：由光标位置开始，删除单词，直到该单词结束。 Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。 Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。 Ctrl – y ：粘贴之前删除的内容到光标后。 ctrl – t ：交换光标处和之前两个字符的位置。 Alt + .</description>
    </item>
    
    <item>
      <title>Linux如何关闭某个占用端口的进程</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/linux%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E6%9F%90%E4%B8%AA%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/linux%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E6%9F%90%E4%B8%AA%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/</guid>
      <description>Linux如何关闭某个占用端口的进程 1）查找被占用的端口: netstat -tln | grep 8000 tcp 0 0 192.168.2.106:8000 0.0.0.0:* LISTEN 2）查看被占用端口的PID： sudo lsof -i:8000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nginx 850 root 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) nginx 851 www-data 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) nginx 852 www-data 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) 3）kill掉该进程
sudo kill -9 850 </description>
    </item>
    
    <item>
      <title>reset命令:将仓库记录和恢复指定历史位置</title>
      <link>https://ruichengm1987.github.io/docs/git/2.%E8%BF%9B%E9%98%B6/0.reset%E5%91%BD%E4%BB%A4%E5%B0%86%E4%BB%93%E5%BA%93%E8%AE%B0%E5%BD%95%E5%92%8C%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E5%8E%86%E5%8F%B2%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/2.%E8%BF%9B%E9%98%B6/0.reset%E5%91%BD%E4%BB%A4%E5%B0%86%E4%BB%93%E5%BA%93%E8%AE%B0%E5%BD%95%E5%92%8C%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E5%8E%86%E5%8F%B2%E4%BD%8D%E7%BD%AE/</guid>
      <description>0.reset命令:将仓库记录和恢复指定历史位置 有时候我们用 git commit 提交代码后发现这一次提交的内容是错误的，需要将代码复原，这个时候常见有两种做法。
第一种是把代码错误内容修改正确，然后重新使用 commit 提交一次； 这种情况会多2条log记录
第二种方法是使用 git reset 命令撤销上一次错误的 commit 记录。 git reset HEAD^ # 撤销我们最近一次提交 git reset 815ac616803fa89c75467618b2be44f85696543d # 指定回滚位置, commitid git reset 815ac616803fa89c75467618b2be44f85696543d filename # 回滚某个文件到某次提交 </description>
    </item>
    
    <item>
      <title>shell基础</title>
      <link>https://ruichengm1987.github.io/docs/shell/shell%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/shell/shell%E5%9F%BA%E7%A1%80/</guid>
      <description>shell基础 shell是命令行解析器 关系: 内存-&amp;gt; shell -&amp;gt; 用户  shell概述 脚本执行方法 Bash的基本功能 </description>
    </item>
    
    <item>
      <title>什么是数据结构</title>
      <link>https://ruichengm1987.github.io/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>什么是数据结构 数据结构，直白地理解，就是研究数据的存储方式。</description>
    </item>
    
    <item>
      <title>变量&amp;常量</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</guid>
      <description>变量&amp;amp;常量 变量 1、显式的完整声明 var varName dataType [ = value] 说明: 关键字var用于变量声明 varName 是变量名称标识符 dataType 数据类型 value 初始化值 例子: var a int = 1 2、短类型声明 varName := value := 声明只能出现在函数内（包括在方法内） 此时Go编译器自动进行数据类型推断 a, b := 1, &amp;quot;hello&amp;quot;  常量 const a = 1 const ( a = iota ) </description>
    </item>
    
    <item>
      <title>垃圾回收算法</title>
      <link>https://ruichengm1987.github.io/docs/datas_tructure/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/datas_tructure/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</guid>
      <description>常见垃圾回收算法   引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。
 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。 代表语言：Python、PHP、Swift    标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为&amp;quot;被引用&amp;rdquo;，没有被标记的进行回收。
 优点：解决了引用计数的缺点。 缺点：需要STW，即要暂时停掉程序运行。 代表语言：Golang(其采用三色标记法)    分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。
 优点：回收性能好 缺点：算法复杂 代表语言： JAVA    </description>
    </item>
    
    <item>
      <title>复杂度</title>
      <link>https://ruichengm1987.github.io/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F/</guid>
      <description>复杂度 复杂度是衡量代码运行效率的重要的度量因素，复杂度通常包括时间复杂度和空间复杂度
复杂度特性:  复杂度与具体的常系数无关 多项式级的复杂度相加的时候，选择高者作为结果 O(1) 也是表示一个特殊复杂度, 与输入数据量n无关  复杂度的经验结论  一个顺序结构的代码，时间复杂度是O(1) 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度是O(logn). 一个简单的for循环，时间复杂度是O(n) 两个顺序执行的for循环,时间复杂度是O(n)+O(n)=O(2n),其实也是O(n) 两个嵌套的for循环, 时间复杂度是O(n2)  总结 时间复杂度与&amp;laquo;代码的结构设计&amp;raquo;高度相关
空间复杂度与&amp;laquo;数据结构的选择&amp;raquo;高度相关</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>字符串 </description>
    </item>
    
    <item>
      <title>字符串操作</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid>
      <description>字符串操作 </description>
    </item>
    
    <item>
      <title>容错，高可用和灾备</title>
      <link>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/%E5%AE%B9%E9%94%99%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E7%81%BE%E5%A4%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/%E5%AE%B9%E9%94%99%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E7%81%BE%E5%A4%87/</guid>
      <description>容错，高可用和灾备 容错 容错（fault tolerance）指的是， 发生故障时，系统还能继续运行。
飞机有四个引擎，如果一个引擎坏了，剩下三个引擎，还能继续飞，这就是&amp;quot;容错&amp;rdquo;。同样的，汽车的一个轮子扎破了，剩下三个轮子，也还是勉强能行驶。
容错的目的是，发生故障时，系统的运行水平可能有所下降，但是依然可用，不会完全失败。
高可用 高可用（high availability）指的是， 系统能够比正常时间更久地保持一定的运行水平。
汽车的备胎就是一个高可用的例子。如果没有备胎，轮胎坏了，车就开不久了。备胎延长了汽车行驶的可用时间。
注意，高可用不是指系统不中断（那是容错能力），而是指一旦中断能够快速恢复，即中断必须是短暂的。如果需要很长时间才能恢复可用性，就不叫高可用了。上面例子中，更换备胎就必须停车，但只要装上去，就能回到行驶状态。
灾备 灾备（又称灾难恢复，disaster recovery）指的是， 发生灾难时恢复业务的能力。
上图中，飞机是你的 IT 基础设施，飞行员是你的业务，飞行员弹射装置就是灾备措施。一旦飞机即将坠毁，你的基础设施就要没了，灾备可以让你的业务幸存下来。
灾备的目的就是，保存系统的核心部分。一个好的灾备方案，就是从失败的基础设施中获取企业最宝贵的数据，然后在新的基础设施上恢复它们。注意，灾备不是为了挽救基础设置，而是为了挽救业务。
总结 上面三个方面可以结合起来，设计一个可靠的系统。
 容错：发生故障时，如何让系统继续运行。 高可用：系统中断时，如何尽快恢复。 灾备：系统毁灭时，如何抢救数据。  </description>
    </item>
    
    <item>
      <title>查找</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%9F%A5%E6%89%BE/</guid>
      <description>查找 find find . -type f -mtime -1 -size +0k -size -1k 查找文件大小在0k到1k之间的文件</description>
    </item>
    
    <item>
      <title>栈逃逸</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E6%A0%88%E9%80%83%E9%80%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E6%A0%88%E9%80%83%E9%80%B8/</guid>
      <description>栈逃逸 </description>
    </item>
    
    <item>
      <title>清理无意义的分支数据</title>
      <link>https://ruichengm1987.github.io/docs/git/2.%E8%BF%9B%E9%98%B6/1.%E6%B8%85%E7%90%86%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%88%86%E6%94%AF%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/2.%E8%BF%9B%E9%98%B6/1.%E6%B8%85%E7%90%86%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%88%86%E6%94%AF%E6%95%B0%E6%8D%AE/</guid>
      <description>清理无意义的分支数据  本地不存在，远程存在该分支，但不需要了 远程不存在，本地存在该分支，也不需要了  清理远程分支 1. 查看分支, 远程分支显示红色 git branch -a remotes/origin/dev 2. 执行命令 git push origin --delete dev 清理本地分支 1. 模拟场景 git checkout -b test6 2. 查看当前版本库的分支 git branch -a 3. 将分支推送到远程服务器中 git push --set-upstream origin test6 4. 查看远程分支的信息 git remote show origin 5. 删除远程分支 git push origin --delete test1 </description>
    </item>
    
    <item>
      <title>环境搭建</title>
      <link>https://ruichengm1987.github.io/docs/mysql/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/mysql/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>环境搭建 Mac版环境搭建 安装 brew install mysql 安装完后启动mysql mysql.server start 执行安全设置 mysql_secure_installation </description>
    </item>
    
    <item>
      <title>环境搭建</title>
      <link>https://ruichengm1987.github.io/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>环境搭建 安装 1、 安装rustup $ curl https://sh.rustup.rs -sSf | sh 2、执行 $ source $HOME/.cargo/env 更新 $ rustup update 卸载Rust和rustup $ rustup self uninstall 故障排除 $ rustc --version # 看到rustc x.y.z (abcabcabc yyyy-mm-dd)表示安装成功 恭喜入坑！ </description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/1.%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/1.%E7%AE%80%E4%BB%8B/</guid>
      <description>简介 软件包分类  源码包  脚本安装包   二进制包(RPM包、系统默认包)  </description>
    </item>
    
    <item>
      <title>类图</title>
      <link>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml/%E7%B1%BB%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml/%E7%B1%BB%E5%9B%BE/</guid>
      <description>类图 1.类图基础属性   +表示public -表示private #表示protected ~表示default,也就是包权限 _下划线表示static 斜体表示抽象  2.类与类之间关系   泛化关系 (is a: Cat is a Animal -&amp;gt; 继承): 类和类、接口和接口的继承    实现关系 (like a: cooker like a foodMenu)    关联关系 (has a: Programmer has a Computer) 聚合、组合 都属于关联关系      聚合关系 聚合关系描述的是整体和部分的关系，聚合关系是比较特殊的关联关系, 比如: 一个教室当中有多个学生，教室和学生之间的关系就是整体和部分的关系。 在聚合关系中，整体的生命周期不会决定部分的生命周期, 例如:教室没了，学生还在，或者说学生走了，教室还在。    组合关系 组合关系可以看做是一种特殊的聚合关系，整体的生命周期决定部分的生命周期，部分是依附在整体上面的，部分离开了整体是无法&amp;quot;存活的&amp;rdquo;. 例如: 人和 四肢的关系。    依赖关系 依赖关系是所有关系中最弱的一种，这种关系通常体现在类和局部变量之间的关系。    </description>
    </item>
    
    <item>
      <title>网络基础</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
      <description>网络基础 1.iso/osi七层模型 7 应用层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-应用层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 应用层 APDU(应用协议数据单元)
6 表示层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-表示层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 表示层 PPDU(表示协议数据单元) 5 会话层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-会话层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 会话层 SPDU(会话协议数据单元) 4 传输层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-传输层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 传输层 TPDU(传输协议数据单元)
3 网络层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-网络层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 网络层 报文 2 数据链路层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-数据链路层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 数据链路层 帧 1 物理层 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-物理层协议&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt; 物理层 比特
MAC地址负责局域网通信
IP地址负责外网通信
物理层: 设备之间的比特流的传输、物理接口、电气特征等
数据链路层: 成帧、用MAC地址访问媒介、错误检测与修正
网络层: 提供逻辑地址、选路
传输层: 可靠与不可靠的传输、传输前的错误检测、流控
会话层: 对应用会话的管理、同步
表示层: 数据的表示形式、特定功能的实现如-加密
应用层: 用户接口
2.Tcp/Ip四层模型  应用层 &amp;mdash;&amp;gt; (应用层, 表示层, 会话层) 传输层 &amp;mdash;&amp;gt; (传输层) 网际互联层 &amp;mdash;-&amp;gt; (网络层) 网络接口层 &amp;mdash;-&amp;gt; (物理层, 数据链路层)  网络接口层: 网络接入层是OSI参数模型中的物理层和数据链路层相对应.</description>
    </item>
    
    <item>
      <title>进程与线程的一个简单解释</title>
      <link>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/02%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/02%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</guid>
      <description>进程与线程的一个简单解释 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。
最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。
 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。
 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。
 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。
 一个车间里，可以有很多工人。他们协同完成一个任务。
 线程就好比车间里的工人。一个进程可以包括多个线程。
 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。
 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&amp;quot;互斥锁&amp;rdquo;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。
 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&amp;quot;信号量&amp;rdquo;（Semaphore），用来保证多个线程不会互相冲突。
不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。
 操作系统的设计，因此可以归结为三点：
（1）以多进程形式，允许多个任务同时运行；
（2）以多线程形式，允许单个任务分成不同的部分运行；
（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</description>
    </item>
    
    <item>
      <title>1.2.2 标识符</title>
      <link>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.2.%E6%A0%87%E8%AF%86%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.2.%E6%A0%87%E8%AF%86%E7%AC%A6/</guid>
      <description>1.2.2 标识符 标识符就是用于给 Java 程序中变量、类、方法等命名的符号
 使用标识符时，需要遵守几条规则：
  标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法滴
  标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以
  标识符是严格区分大小写的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！
  标识符的命名最好能反映出其作用，做到见名知意。
  </description>
    </item>
    
    <item>
      <title>1.2.代词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.2.%E4%BB%A3%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.2.%E4%BB%A3%E8%AF%8D/</guid>
      <description>1.2.代词 代词分类 一、人称代词 人称代词代替任何事物的名词,分为主格和宾格两种形式
 1.主格: 用来作句子的主语,表语 Are they from Brazil?
Where have they gone?
it&amp;rsquo;s he!
2.宾格: 用来作及物动词或者介词的宾语 who teaches you English this year?
who often write letters to her
3.主/宾格 人称代词作表语或放比较状语从句连词than或as之后, 可用主格形式/宾语形式
who is it?
it&amp;rsquo;s I/me
4.顺序 人称代词顺序: &amp;ldquo;you-&amp;gt;he_&amp;gt;I&amp;rdquo;
Both he and i are working at that computer company
who will go there? You and me
5.it 指人/指物
表示&amp;quot;时间、天气、温度、距离、情况&amp;quot;等含义
作形式主语/宾语: 替代作主语或宾语的不定式、动名词或名词性从句
what&amp;rsquo;s the weather like today?
lt&amp;lsquo;s fine</description>
    </item>
    
    <item>
      <title>1.2.使用Git命令下载远程仓库到本地</title>
      <link>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.2.%E4%BD%BF%E7%94%A8git%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%B0%E6%9C%AC%E5%9C%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.2.%E4%BD%BF%E7%94%A8git%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%B0%E6%9C%AC%E5%9C%B0/</guid>
      <description>1.2.使用Git命令下载远程仓库到本地 HTTP(S)获取远程仓库 首次拉取 git clone 版本库地址	[本地文件夹名称]
更新代码 git pull
临时记住密码  git config –-global credential.helper cache #默认缓存15分钟 git config credential.helper &amp;lsquo;cache –timeout=3600&amp;rsquo; #自定义配置记住 1 小时的命令  永久记住密码 git config &amp;ndash;global credential.helper store
修改配置文件.gitconfig
[credential] helper = store 在上面的命令中，如果没有&amp;ndash;global，则会在当前项目下的.git/config文件增加配置
SSH拉取 git clone git@gitee.com:xxx/xxxx.git xxxx
创建一个ssh key 执行命令: ssh-keygen 之后一直回车
查看公钥 cat ~/.ssh/id_rsa.pub
添加公钥到服务器 把公钥粘贴上去</description>
    </item>
    
    <item>
      <title>1.2.国内镜像配置</title>
      <link>https://ruichengm1987.github.io/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.2.%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.2.%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/</guid>
      <description>1.2.国内镜像配置 Go 1.13及以上(推荐) 打开你的终端并执行: go env -w GOPROXY=https://goproxy.cn,direct  Go module 打开你的终端并执行: go env -w GO111MODULE=on  go imports go imports包的引入可以让代码书写变得更加快捷 $ go get -v golang.org/x/tools/cmd/goimports  </description>
    </item>
    
    <item>
      <title>1.4.2 switch</title>
      <link>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.2.switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.2.switch/</guid>
      <description>1.4.2 switch switch  </description>
    </item>
    
    <item>
      <title>2.1.2.变量</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.2.%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.2.%E5%8F%98%E9%87%8F/</guid>
      <description>2.1.2.变量 变量的来历 程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。
变量类型 变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。
Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。
变量声明 Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。
标准声明 Go语言的变量声明格式为：
var 变量名 变量类型 变量声明以关键字var开头，变量类型放在变量的后面，行尾无需分号。 举个例子：
var name string var age int var isOk bool 批量声明 每声明一个变量就需要写var关键字会比较繁琐，go语言中还支持批量变量声明：
var ( a string b int c bool d float32 ) 变量的初始化 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。
当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：
var 变量名 类型 = 表达式 举个例子：
var name string = &amp;quot;Q1mi&amp;quot; var age int = 18 或者一次初始化多个变量
var name, age = &amp;quot;Q1mi&amp;quot;, 20 类型推导 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</description>
    </item>
    
    <item>
      <title>2.1.2.封装</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.2.%E5%B0%81%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.2.%E5%B0%81%E8%A3%85/</guid>
      <description>2.1.2.封装 修饰符 public
protecd
private
this修饰符  this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 封装对象的属性的时候,经常会使用this关键字  </description>
    </item>
    
    <item>
      <title>2.10.2.结构体</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.2.%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.2.%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>2.10.2.结构体 Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。
Go语言中通过struct来实现面向对象。
结构体定义 使用type和struct关键字来定义结构体，具体代码格式如下：
type 类型名 struct { 字段名 字段类型 字段名 字段类型 … } 其中：
 类型名：标识自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。  举个例子，我们定义一个Person（人）结构体，代码如下：
type person struct { name string city string age int8 } 同样类型的字段也可以写在一行，
type person1 struct { name, city string age int8 } 这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。
语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型
结构体实例化 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。
结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。
var 结构体实例 结构体类型 基本实例化 举个例子：
type person struct { name string city string age int8 } func main() { var p1 person p1.</description>
    </item>
    
    <item>
      <title>2.13.2.反射介绍</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.2.%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.2.%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>2.13.2.反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。
支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。
Go程序在运行期使用reflect包访问程序的反射信息。
在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</description>
    </item>
    
    <item>
      <title>2.14.2.goroutine</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.2.goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.2.goroutine/</guid>
      <description>2.14.2.goroutine 在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？
Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。
在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。
使用goroutine Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。
一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。
启动单个goroutine 启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。
举个例子如下：
func hello() { fmt.Println(&amp;quot;Hello Goroutine!&amp;quot;) } func main() { hello() fmt.Println(&amp;quot;main goroutine done!&amp;quot;) } 这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。
接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。
func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(&amp;quot;main goroutine done!&amp;quot;) } 这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？
在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。
当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。
所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。
func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(&amp;quot;main goroutine done!&amp;quot;) time.Sleep(time.Second) } 执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。
首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。
启动多个goroutine 在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.</description>
    </item>
    
    <item>
      <title>2.16.2.测试函数</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.2.%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.2.%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/</guid>
      <description>2.16.2.测试函数 测试函数的格式 每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：
func TestName(t *testing.T){ // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：
func TestAdd(t *testing.T){ ... } func TestSum(t *testing.T){ ... } func TestLog(t *testing.T){ ... } 其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：
func (c *T) Error(args ...interface{}) func (c *T) Errorf(format string, args ...interface{}) func (c *T) Fail() func (c *T) FailNow() func (c *T) Failed() bool func (c *T) Fatal(args ...interface{}) func (c *T) Fatalf(format string, args ...interface{}) func (c *T) Log(args ...interface{}) func (c *T) Logf(format string, args .</description>
    </item>
    
    <item>
      <title>2.2.2.Collection接口</title>
      <link>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.2.collection%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.2.collection%E6%8E%A5%E5%8F%A3/</guid>
      <description>2.2.2.Collection接口  Collection父接口  特点: 代表一组任意类型的对象,无序、无下标、不能重复 方法  boolean add(Object obj) // 添加一个对象 boolean addAll(Collection c) // 将一个集合中的所有对象添加到此结合中 void clear() // 清空此集合中的所有对象 boolean contains(Object o) //检查此集合中是否包含o对象 boolean equals(Object o) // 比较此集合是否与指定对象相等 boolean isEmpty() // 判断此集合是否为空 boolean remove(Object o) // 在此集合中移除o对象 int size() // 返回此集合中的元素个数 Object[] toArray() // 将此集合转换成数组    public class demo { public static void main(String[] args) { // 创建集合 Collection collection = new ArrayList(); // 添加元素 collection.</description>
    </item>
    
    <item>
      <title>2.2.2.浮点型</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.2.%E6%B5%AE%E7%82%B9%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.2.%E6%B5%AE%E7%82%B9%E5%9E%8B/</guid>
      <description>2.2.2.浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。
打印浮点数时，可以使用fmt包配合动词%f，代码如下：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { fmt.Printf(&amp;quot;%f\n&amp;quot;, math.Pi) fmt.Printf(&amp;quot;%.2f\n&amp;quot;, math.Pi) } </description>
    </item>
    
    <item>
      <title>2.2.应用部署样例</title>
      <link>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.2.%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%A0%B7%E4%BE%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.2.%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%A0%B7%E4%BE%8B/</guid>
      <description>2.2.应用部署样例 https://www.bilibili.com/video/BV1tK411A7iQ?p=10</description>
    </item>
    
    <item>
      <title>2.3.2.关系运算符</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.2.%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.2.%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>2.3.2.关系运算符    运算符 描述     == 检查两个值是否相等，如果相等返回 True 否则返回 False。   != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   &amp;gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   &amp;gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。   &amp;lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   &amp;lt;= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。    </description>
    </item>
    
    <item>
      <title>2.4.2.for</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.2.for/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.2.for/</guid>
      <description>2.4.2.for(循环结构) Go 语言中的所有循环类型均可以使用for关键字来完成。
for循环的基本格式如下：
for 初始语句;条件表达式;结束语句{ 循环体语句 } 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。
func forDemo() { for i := 0; i &amp;lt; 10; i++ { fmt.Println(i) } } for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：
func forDemo2() { i := 0 for ; i &amp;lt; 10; i++ { fmt.Println(i) } } for循环的初始语句和结束语句都可以省略，例如：
func forDemo3() { i := 0 for i &amp;lt; 10 { fmt.Println(i) i++ } } 这种写法类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。
无限循环 for { 循环体语句 } for循环可以通过break、goto、return、panic语句强制退出循环。
for range(键值循环) Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：</description>
    </item>
    
    <item>
      <title>2.8.2.函数进阶</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.2.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.2.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</guid>
      <description>2.8.2.函数进阶 变量作用域 全局变量 全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。
package main import &amp;quot;fmt&amp;quot; //定义全局变量num var num int64 = 10 func testGlobalVar() { fmt.Printf(&amp;quot;num=%d\n&amp;quot;, num) //函数中可以访问全局变量num } func main() { testGlobalVar() //num=10 } 局部变量 局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：
func testLocalVar() { //定义一个函数局部变量x,仅在该函数内生效 var x int64 = 100 fmt.Printf(&amp;quot;x=%d\n&amp;quot;, x) } func main() { testLocalVar() fmt.Println(x) // 此时无法使用变量x } 如果局部变量和全局变量重名，优先访问局部变量。
package main import &amp;quot;fmt&amp;quot; //定义全局变量num var num int64 = 10 func testNum() { num := 100 fmt.Printf(&amp;quot;num=%d\n&amp;quot;, num) // 函数中优先使用局部变量 } func main() { testNum() // num=100 } 接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</description>
    </item>
    
    <item>
      <title>3.2.time</title>
      <link>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.2.time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.2.time/</guid>
      <description>3.2.time 时间类型 time.Time类型表示时间。我们可以通过time.Now()函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。示例代码如下：
func timeDemo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;quot;current time:%v\n&amp;quot;, now) year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second) } 输出结果:
current time:2020-11-16 18:19:06.066198 +0800 CST m=+0.000058943 2020-11-16 18:19:06 时间戳 时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。
基于时间对象获取时间戳的示例代码如下：
func timestampDemo() { now := time.Now() //获取当前时间 timestamp1 := now.Unix() //时间戳 timestamp2 := now.</description>
    </item>
    
    <item>
      <title>Bash变量</title>
      <link>https://ruichengm1987.github.io/docs/shell/bash%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/shell/bash%E5%8F%98%E9%87%8F/</guid>
      <description>shell基础 Buttons are styled links that can lead to local page or external link.
Example {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}}  Get Home  Contribute  </description>
    </item>
    
    <item>
      <title>defer</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/defer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/defer/</guid>
      <description>defer 什么是defer  defer是Go语言的一种用于注册延迟调用的机制,使得函数或语句可以在当前函数执行完毕后执行.  为什么需要defer  Go语言提供的语法糖,减少资源泄露的发生.  如何使用defer  在创建资源语句的附近,使得defer语句释放资源.  例子 func f1() (r int) { t := 5 // 1. 赋值指令 r = t // 2. defer被插入到赋值与返回质检， 这个例子中返回值r没被修改过 defer func() { t = t + 5 }() // 3. 空的return指令 return t } 返回值是5 func f2() (r int) { defer func(r int) { r = r + 5 }(r) // 此处r是copy了一份 return 1 } 返回值是1 func f3() (r int) { defer func(r *int) { *r = *r + 5 }(&amp;amp;r) // 此处r是传址 return 1 } 返回值是6 defer 是先入先出 func e1() { var err error defer fmt.</description>
    </item>
    
    <item>
      <title>GC垃圾回收</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>垃圾回收 </description>
    </item>
    
    <item>
      <title>Go Mock (gomock)简明教程</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/mock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/mock/</guid>
      <description>Go Mock (gomock)简明教程 1.gomock 简介 上一篇文章 Go Test 单元测试简明教程 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。
GoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too. gomock 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。
使用如下命令即可安装：
go get -u github.com/golang/mock/gomock go get -u github.com/golang/mock/mockgen 2.一个简单的 Demo // db.go type DB interface { Get(key string) (int, error) } func GetFromDB(db DB, key string) int { if value, err := db.</description>
    </item>
    
    <item>
      <title>iota</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/iota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/iota/</guid>
      <description>iota   const (
a = 1 &amp;laquo; iota // a==1 (iota == 0)
b = 1 &amp;laquo; iota // b==2 （iota == 1）
c = 3 // c == 3 (iota==2, unused)
d = 1 &amp;laquo; iota // d==8 (iota == 3) )
  const x = iota // x==0
  const y = iota // y==0 分开的const语句,iota每次都从0开始
  </description>
    </item>
    
    <item>
      <title>RPM</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/rpm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/rpm/</guid>
      <description>RPM RPM包在系统光盘中 RPM包命名规则 httpd-2.2.15-15.el6.CENTOS.1.i686.rpm
-httpd 软件包名
-2.2.15 软件版本 -15 软件包发布的次数
-el6.centos 适合的Linux平台 -i686 适合的硬件平台 -rpm rpm包扩展名
RPM包依赖性  树形依赖: a -&amp;gt; b -&amp;gt; c 环形依赖: a -&amp;gt; b -&amp;gt; c -&amp;gt; a 模块依赖: 模块依赖, 查询网站: www.rpmfind.net  包全名与报名  包全名 操作的包是没有安装的软件包时,使用包全名,而且要注意路径 包名 操作已经安装的软件包时,使用包名,是搜索/var/lib/rpm中的数据库  RPM包安装  rpm -ivh 包全名 选项: -i (install) 安装 -v (verbose) 显示详细信息 -h (hash) 显示进度 &amp;ndash;nodeps 不检测依赖性  RPM包升级  rpm -Uvh 包全名 选项: -U (upgrade) 升级  RPM包卸载  rpm -e httpd 包名 选项: -e （erase）卸载 &amp;ndash;nodeps 不检查依赖性  RPM包查询 1.</description>
    </item>
    
    <item>
      <title>列表vs元组</title>
      <link>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%88%97%E8%A1%A8vs%E5%85%83%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%88%97%E8%A1%A8vs%E5%85%83%E7%BB%84/</guid>
      <description>列表vs元组 列表 一、创建列表 1.创建空的列表 列表 = [] 2.创建包含元素的列表 列表 = [元素1, 元素2, ..., 元素N] 二、列表元素的获取 1.通过索引获取元素 元素 = 列表[索引] 2.通过元素获取索引 索引 = 列表.index(元素) 3.查看元素是否存在于列表中 布尔值 = 元素 in 列表 4.统计元素在列表中的个数 个数 = 列表.count(元素) 三、列表元素的添加 1.向列表末尾追加元素 列表.append(元素) 2.向列表的任意位置插入元素 列表.insert(索引, 元素) 3.列表末尾追加另一个列表的所有元素 列表.extend(另一列表) 四、列表元素的删除 1.按索引删除元素 元素 = 列表.pop(索引) 2.按索引删除元素（del方法) del 列表[索引] 3.直接删除元素 列表.remove(元素) 4.清空所有元素 列表.clear() 五、列表元素的修改 1.通过赋值修改列表元素 列表[索引] = 新元素 2.反转整个列表 列表.reverse() 3.列表元素排序 列表.sort() 元组 元组和列表非常相似，也是用于存放元素的有序序列。它用的圆括号（()）表示，元素写入圆括号中，多个元素时用逗号分隔，如 (1, 2, 3)。
元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素。所以它与列表相比，只能查找元素，也就是说只具备读的功能，不具备写的功能。元组的这一特性叫作不可变（性）（Immutable），而列表是可变的（Mutable）。
一、创建元组 1.创建空的元组 元组 = () 2.</description>
    </item>
    
    <item>
      <title>并行、并发与分布式计算</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</guid>
      <description>ddd</description>
    </item>
    
    <item>
      <title>数组操作</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</guid>
      <description>数组操作 </description>
    </item>
    
    <item>
      <title>用例图</title>
      <link>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml/%E7%94%A8%E4%BE%8B%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml/%E7%94%A8%E4%BE%8B%E5%9B%BE/</guid>
      <description>用例图 站在系统用户(系统角色)的角度分析系统存在哪些功能?
实现用例图的时候， 需要先进行系统角色的抽取。  </description>
    </item>
    
    <item>
      <title>网络配置</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid>
      <description>网络配置 配置IP地址 1. ifconfig命令临时配置ip地址 ifconfig命令: 查看与配置网络状态命令
#临时设置eth0网卡的IP地址与子网掩码 ifconfig eth0 192.168.0.200 netmask 255.255.255.0
2. setup工具永久配置IP地址(rethat专有) 3. 修改网络配置文件  网卡信息文件  vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 //网卡设备名 BOOTPROTO=none //是否自动获取IP(none、static、dhcp) HWADDR=00:0c:29:17:c4:09 //MAC地址 NM_CONTROLLED=yes //是否可以由network manager图形管理工具托管 ONBOOT=yes //是否随网络服务启动, eth0生效 TYPE=Ethernet //类型为以太网 UUID=&amp;quot;xxsfwafewfw&amp;quot; //唯一识别码 IPADDR=192.168.0.252 //IP地址 NETMASK=255.255.255.0 //子网掩码 GATEWAY=192.168.0.1 //网关 DNS1=202.106.0.20 //DNS IPV6INIT=no //IPv6没有启用 USERCTL=no //不允许非root用户控制此网卡  主机名文件  vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=localhost.localdomain # 查看与临时设置主机名命令 [root@localhost ~]# hostname imooc  DNS配置文件  vi /etc/resolv.conf nameserver 202.106.0.20 search localhost 4.</description>
    </item>
    
    <item>
      <title>1.2.3 变量</title>
      <link>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.3.%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.3.%E5%8F%98%E9%87%8F/</guid>
      <description>1.2.3 变量 通过三个元素描述变量：变量类型、变量名以及变量值。
 变量使用规则
 1、Java 中的变量需要先声明后使用 2、变量使用时，可以声明变量的同时进行初始化, 也可以先声明后赋值 3、变量中每次只能赋一个值，但可以修改多次 4、main 方法中定义的变量必须先赋值，然后才能输出 5、虽然语法中没有提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患，譬如后期跨平台操作时出现乱码等等  </description>
    </item>
    
    <item>
      <title>1.3.依赖管理</title>
      <link>https://ruichengm1987.github.io/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.3.%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.3.%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</guid>
      <description>1.3.依赖管理 依赖管理的三个阶段: GOPATH, GOVENDOR, go mod
GOPATH 默认在~/go
go mod的使用 使用intelij Idea创建项目  打开Intelij Idea, File-&amp;gt;new-&amp;gt;project 选择Go MOdules(vgo), 将Proxy: 改为https://goproxy.cn,direct 打开ide的terminal输入go env查看GO111MODULE是否为on，和查看GOPROXY是否为: https://goproxy.cn,direct 继续在terminal输入: go get -u go.uber.org/zap  获取某个固定版本: go get -u go.uber.org/zap@1.11
获取最新的版本: go get -u go.uber.org/zap
清洁: go mod tidy
增加依赖：
1. go get
2. 代码直接写, 点run的时候自动下载
go build ./...  迁移到go mod go mod init modtest2 go build ./... 增加依赖 go get  总结  由go命令统一的管理, 用户不必关心目录结构 初始化: go mode init [名称] 增加依赖: go get 或者 直接写代码,在build的时候把依赖加进去 更新依赖: go get [@v&amp;hellip;], go mod tidy # 不加@v表示拿最新版本 将旧项目迁移到go mod: go mod init, go build .</description>
    </item>
    
    <item>
      <title>1.3.如何把修改后的代码提交到远程仓库</title>
      <link>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.3.%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.3.%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid>
      <description>1.3.如何把修改后的代码提交到远程仓库 同步远程代码 git pull
检查改动文件 git status
 Untracked: 未跟踪,一般为新增文件，此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. deleted: 文件已删除，本地删除，服务器上还没有删除. renamed: 文件名称被改变  如果发现无意中编辑了某一个文件，但实际上并不想改变它，这里可以使用git checkout 文件名来撤销更改
git checkout README.md 添加文件到缓存 git add index.php #添加所有使用 git add .
提交代码 git commit . -m “这是备注信息”
推送代码 git push
开发中的提交 git add test1.php test2.log
git commit #此刻会打开一个文件, 删除非提交的之后保存 git push origin branch/feature/1 #推送到指定分支
notice  git add -A更好。因为git add .不会提交删除操作 git add abc.</description>
    </item>
    
    <item>
      <title>1.3.形容词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.3.%E5%BD%A2%E5%AE%B9%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.3.%E5%BD%A2%E5%AE%B9%E8%AF%8D/</guid>
      <description>1.3.形容词 </description>
    </item>
    
    <item>
      <title>1.4.3.while</title>
      <link>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.3.while/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.3.while/</guid>
      <description>1.4.3.while while  </description>
    </item>
    
    <item>
      <title>2.1.3.常量</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.3.%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/2.1.3.%E5%B8%B8%E9%87%8F/</guid>
      <description>2.1.3.常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。
const pi = 3.1415 const e = 2.7182 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。
多个常量也可以一起声明：
const ( pi = 3.1415 e = 2.7182 ) const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：
const ( n1 = 100 n2 n3 ) 上面示例中，常量n1、n2、n3的值都是100。
iota iota是go语言的常量计数器，只能在常量的表达式中使用。
iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。
举个例子：
const ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) 使用_跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) iota声明中间插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 定义数量级 （这里的&amp;laquo;表示左移操作，1&amp;laquo;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2&amp;laquo;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）</description>
    </item>
    
    <item>
      <title>2.1.3.继承</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.3.%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.3.%E7%BB%A7%E6%89%BF/</guid>
      <description>2.1.3.继承 语法规则 class 子类 extends 父类 例: class Dog extends Animal {
}
方法重写 子类不满父类的类, 子类重写方法
final关键字 使用final关键字做标识有&amp;quot;最终的&amp;quot;含义
final可以修饰类、方法、属性、变量
 修饰类, 则该类不允许被继承 修饰方法, 则该方法不允许被覆盖 修饰属性 则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)
或在构造方法中赋值(但只能选其一) 修饰变量, 则该变量的值只能赋一次值,即变为常量  super关键字 在对象内部使用,可以代表父类对象
1.访问父类的属性: super.age
2.访问父类的方法: super.eat()
Object类 Object类是所有类的父类,如果一个类没有使用extends关键字明确标识继承另外一个类, 那么这个类默认继承Object类
Object类中的方法,适合所有子类
toString()方法 转换为字符串，所有类可以重写
equals() 方法 比较的是对象的引用是否指向同一块内存地址</description>
    </item>
    
    <item>
      <title>2.10.3.json与结构体</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.3.json%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/2.10.3.json%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>2.10.3.json与结构体 </description>
    </item>
    
    <item>
      <title>2.13.3.reflect包</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.3.reflect%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.3.reflect%E5%8C%85/</guid>
      <description>2.13.3.reflect包 在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type。
TypeOf 在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) func reflectType(x interface{}) { v := reflect.TypeOf(x) fmt.Printf(&amp;quot;type:%v\n&amp;quot;, v) } func main() { var a float32 = 3.14 reflectType(a) // type:float32 var b int64 = 100 reflectType(b) // type:int64 } type name和type kind 在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) type myInt int64 func reflectType(x interface{}) { t := reflect.TypeOf(x) fmt.Printf(&amp;quot;type:%v kind:%v\n&amp;quot;, t.Name(), t.Kind()) } func main() { var a *float32 // 指针 var b myInt // 自定义类型 var c rune // 类型别名 reflectType(a) // type: kind:ptr reflectType(b) // type:myInt kind:int64 reflectType(c) // type:int32 kind:int32 type person struct { name string age int } type book struct{ title string } var d = person{ name: &amp;quot;沙河小王子&amp;quot;, age: 18, } var e = book{title: &amp;quot;《跟小王子学Go语言》&amp;quot;} reflectType(d) // type:person kind:struct reflectType(e) // type:book kind:struct } Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.</description>
    </item>
    
    <item>
      <title>2.14.3.goroutine与线程</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.3.goroutine%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.3.goroutine%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>2.14.3.goroutine与线程 可增长的栈 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的goroutine也是可以的。
goroutine调度 GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。
 G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；  P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。
P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。
单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。
GOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。
Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。
Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。
我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：
func a() { for i := 1; i &amp;lt; 10; i++ { fmt.Println(&amp;quot;A:&amp;quot;, i) } } func b() { for i := 1; i &amp;lt; 10; i++ { fmt.Println(&amp;quot;B:&amp;quot;, i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.</description>
    </item>
    
    <item>
      <title>2.16.3.基准测试</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.3.%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.3.%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>2.16.3.基准测试 基准测试函数格式 基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：
func BenchmarkName(b *testing.B){ // ... } 基准测试以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下：
func (c *B) Error(args ...interface{}) func (c *B) Errorf(format string, args ...interface{}) func (c *B) Fail() func (c *B) FailNow() func (c *B) Failed() bool func (c *B) Fatal(args ...interface{}) func (c *B) Fatalf(format string, args ...interface{}) func (c *B) Log(args ...interface{}) func (c *B) Logf(format string, args ...interface{}) func (c *B) Name() string func (b *B) ReportAllocs() func (b *B) ResetTimer() func (b *B) Run(name string, f func(b *B)) bool func (b *B) RunParallel(body func(*PB)) func (b *B) SetBytes(n int64) func (b *B) SetParallelism(p int) func (c *B) Skip(args .</description>
    </item>
    
    <item>
      <title>2.2.3.List接口和实现类</title>
      <link>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.3.list%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.3.list%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</guid>
      <description>2.2.3.List接口和实现类  特点: 有序、有下标、元素可以重复 方法  void add(int index, Object o) // 在index位置插入对象o boolean addAll(int index, Collection c) //将一个集合中的元素添加到此集合中的index位置 Object get(int index) // 返回集合中指定位置的元素 List subList(int fromIndex, int toIndex) // 返回fromIndex和toIndex之间的集合元素    public class demo { public static void main(String[] args) { // 先创建集合对象 List list = new ArrayList(); // 添加元素 list.add(&amp;quot;苹果&amp;quot;); list.add(&amp;quot;小米&amp;quot;); list.add(0, &amp;quot;华为&amp;quot;); System.out.println(&amp;quot;元素个数:&amp;quot; + list.size()); System.out.println(list.toString()); // 删除元素 list.remove(&amp;quot;苹果&amp;quot;); System.out.println(&amp;quot;删除之后:&amp;quot; + list.size()); System.out.println(list.toString()); // 遍历 for (int i = 0; i &amp;lt; list.</description>
    </item>
    
    <item>
      <title>2.2.3.复数</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.3.%E5%A4%8D%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.3.%E5%A4%8D%E6%95%B0/</guid>
      <description>2.2.3.复数 complex64和complex128
package main import &amp;quot;fmt&amp;quot; func main() { var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) } 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</description>
    </item>
    
    <item>
      <title>2.3.3.逻辑运算符</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.3.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.3.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>2.3.3.逻辑运算符    运算符 描述     &amp;amp;&amp;amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。   || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。   ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。    </description>
    </item>
    
    <item>
      <title>2.3.迁移与备份</title>
      <link>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.3.%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%87%E4%BB%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.3.%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%87%E4%BB%BD/</guid>
      <description>2.3.迁移与备份 容器保存为镜像 语法: docker commit 容器名称|容器id 镜像 docker commit redis myredis 镜像备份 我们可以通过以下命令将镜像保存为tar文件
docker save -o myredis.tar myredis 镜像恢复与迁移 首先我们先删除掉myredis镜像,然后执行此命令恢复
docker load -i myredis.tar  -i 输入的文件
执行后再次查看镜像,可以看到镜像已经恢复  </description>
    </item>
    
    <item>
      <title>2.4.2.switch</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.3.switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.3.switch/</guid>
      <description>2.4.3.switch 使用switch语句可方便地对大量的值进行条件判断。
func switchDemo1() { finger := 3 switch finger { case 1: fmt.Println(&amp;quot;大拇指&amp;quot;) case 2: fmt.Println(&amp;quot;食指&amp;quot;) case 3: fmt.Println(&amp;quot;中指&amp;quot;) case 4: fmt.Println(&amp;quot;无名指&amp;quot;) case 5: fmt.Println(&amp;quot;小拇指&amp;quot;) default: fmt.Println(&amp;quot;无效的输入！&amp;quot;) } } Go语言规定每个switch只能有一个default分支。
一个分支可以有多个值，多个case值中间使用英文逗号分隔。
func testSwitch3() { switch n := 7; n { case 1, 3, 5, 7, 9: fmt.Println(&amp;quot;奇数&amp;quot;) case 2, 4, 6, 8: fmt.Println(&amp;quot;偶数&amp;quot;) default: fmt.Println(n) } } 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：
func switchDemo4() { age := 30 switch { case age &amp;lt; 25: fmt.</description>
    </item>
    
    <item>
      <title>2.8.3.内置函数</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.3.%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/2.8.3.%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid>
      <description>2.8.3.内置函数    内置函数 介绍     close 主要用来关闭channel   len 用来求长度,比如string、array、slice、map、channel   new 用来分配内存,主要用来分配值类型,比如int、struct. 返回的是指针   make 用来分配内存,主要用来分配应用类型, 比如chan、map、slice   append 用来追加元素到数组、slice中   panic和recover 用来做错误处理    panic/recover Go语言中目前（Go1.12）是没有异常机制，但是使用panic/recover模式来处理错误。 panic可以在任何地方引发，但recover只有在defer调用的函数中有效。 首先来看一个例子：
func funcA() { fmt.Println(&amp;quot;func A&amp;quot;) } func funcB() { panic(&amp;quot;panic in B&amp;quot;) } func funcC() { fmt.Println(&amp;quot;func C&amp;quot;) } func main() { funcA() funcB() funcC() } 输出:
func A panic: panic in B goroutine 1 [running]: main.</description>
    </item>
    
    <item>
      <title>shell运算符</title>
      <link>https://ruichengm1987.github.io/docs/shell/shell%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/shell/shell%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>shell基础 Buttons are styled links that can lead to local page or external link.
Example {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}}  Get Home  Contribute  </description>
    </item>
    
    <item>
      <title>切片操作</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/</guid>
      <description>切片操作 </description>
    </item>
    
    <item>
      <title>可靠的性能测试</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description>可靠的性能测试 主要内容  可靠的测试环境 benchstat 例子与实践  对代码进行性能调优 Benchmark的正确性分析 其他的影响因素   假设检验的原理 局限与应对措施 总结  性能测试方法论 1、搜索需求
2、编写测试用例
3、自动化性能测试用例
4、执行性能测试用例
5、分析性能测试结果
6、性能调优
7、性能基准测试(Performance Benchmarking)
8、向客户推荐合适的配合
影响测试环境的软硬件因素  硬件: CPU型号、温度、IO等 软件: 操作系统版本、当前系统调度的负载等  性能基准测试的两个基本目标 可重复性: 在其他外在的条件不变的情况下, 性能度量结果是稳定、可重复的(能复现的才叫bug)
可比较性: 总是存在一个可以比较的基本线(有比较才有伤害)
benchstat go get golang.org/x/perf/cmd/benchstat benchstat --help usage: benchstat [options] old.txt [new.txt] [more.txt ...] options: -alpha α consider change significant if p &amp;lt; α (default 0.05) -csv print results in CSV form -delta-test test significance test to apply to delta: utest, ttest, or none (default &amp;quot;utest&amp;quot;) -geomean print the geometric mean of each file -html print results as an HTML table -norange suppress range columns (CSV only) -sort order sort by order: [-]delta, [-]name, none (default &amp;quot;none&amp;quot;) -split labels split benchmarks by labels (default &amp;quot;pkg,goos,goarch&amp;quot;) </description>
    </item>
    
    <item>
      <title>字典vs集合</title>
      <link>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E5%85%B8vs%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E5%85%B8vs%E9%9B%86%E5%90%88/</guid>
      <description>字典vs集合 字典 字典是一种用来存放若干键值对的数据类型。
一、创建字典 1.创建空的字典 字典 = {} 2.创建包含键值对的字典 字典 = {键1:值1, 键2:值2, ..., 键N:值N} 二、字典键值对的添加 1.向字典中增加键值对 字典[键] = 值 三、键值对的获取 1.通过键获取值 值 = 字典[键] 2.通过键获取值(get方法) 值 = 字典.get(键) 3.判断字典中是否包含某个键 布尔值 = 键 in 字典 4.获取所有键 键的列表 = 字典.keys() 5.获取所有值 值的列表 = 字典.values() 6.获取所有键值对的列表 值的列表 = 字典.items() 四、字典键值对的删除 1.通过键删除键值对 值 = 字典.pop(键) 2.通过键删除键值对（del 方法） del 字典[键] 3.随机删除一个键值对 键值二元组 = 字典.popitem() 4.清空所有键值对 键值二元组 = 字典.clear() 五、字典中键值对修改 1.修改键对应的值 字典[键] = 值 2.用字典批量更新键值对 字典.</description>
    </item>
    
    <item>
      <title>数据类型</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>#数据类型
一、基本数据类型 Go 语言内置七类基本数据类型
1.布尔类型  True False //不初始化默认为false  2.整型 byte int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr  3.浮点型 float32 float64  4.复数 complex64 complex128 // real返回复数的实部, image返回复数的虚部  5.字符 rune //rune是uint类型的别名  6.字符串: string 赋值: a := &amp;quot;hello&amp;quot; a := &amp;quot;hello world&amp;quot; b := []byte(a) c := []rune(a) b和c的结果都是:[104 101 108 108 111 44 32 119 111 114 108 100]  7.错误类型: error 8.</description>
    </item>
    
    <item>
      <title>时序图</title>
      <link>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml/%E6%97%B6%E5%BA%8F%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml/%E6%97%B6%E5%BA%8F%E5%9B%BE/</guid>
      <description>时序图 时序图当中描述了方法的调用过程, 程序的执行流程，以及方法执行结束的返回值情况
     人图形: 动作发起人 矩形/小圆圈: 队形 实现箭头: 调用 虚线箭头: 返回 柱状: 对象的声明周期，柱状不能断， 在同一个流程当中不能断 回折线: 当前类的方法执行过程中调用自己当前类中的其它方法  组合片段 组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：   </description>
    </item>
    
    <item>
      <title>网络命令</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</guid>
      <description>网络命令 网络环境查看命令 1. ifconfig 查看与配置网络状态命令
2. 关闭与启动网卡 ifdown 网卡设备名 # 禁用该网卡设备
ifup 网卡设备名 # 启用该网卡设备
3. 查询网络状态 netstat 选项:
-t 列出TCP协议端口
-u 列出UDP协议端口
-n 不适用域名与服务名, 而使用IP地址和端口号
-l 仅列出在监听状态网络服务
-a 列出所有的网络连接
4. route命令 route -n # 查看路由列表(可以看到网关)
route add default gw 192.168.1.1 # 临时设定网关
在一台服务器里, 连内网的网卡是不能设置网关的
5. 域名解析命令 nslookup [主机名或IP] # 进行域名或IP地址解析
nslookup # 查看本机DNS服务器
网络测试命令 1. ping 命令 ping -c 10 192.168.1.1 # ping 10次
2. telnet 命令 telnet [域名或IP] 【端口】# 远程管理与端口探测命令(明文传输)</description>
    </item>
    
    <item>
      <title>逃逸分析</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>逃逸分析 例子 /* * 闭包引用了x变量, a,b可以看做2个不同的实例,实例之间互不影响,实例内部,x变量是同一个地址,因此具有&amp;quot;累加效应&amp;quot; */ package main import &amp;quot;fmt&amp;quot; func main() { var a = acc() fmt.Printf(&amp;quot;%d\n&amp;quot;, a(1)) fmt.Printf(&amp;quot;%d\n&amp;quot;, a(10)) fmt.Printf(&amp;quot;%d\n&amp;quot;, a(100)) fmt.Println(&amp;quot;-------------------&amp;quot;) var b = acc() fmt.Printf(&amp;quot;%d\n&amp;quot;, b(1)) fmt.Printf(&amp;quot;%d\n&amp;quot;, b(10)) fmt.Printf(&amp;quot;%d\n&amp;quot;, b(100)) } func acc() func(int) int { var x int return func(delta int) int { fmt.Printf(&amp;quot;%+v, %+v&amp;quot;, &amp;amp;x, x) x += delta return x } } 结果: 0xc000016070, 01 0xc000016070, 111 0xc000016070, 11111 ------------------- 0xc0000160b0, 01 0xc0000160b0, 111 0xc0000160b0, 11111 </description>
    </item>
    
    <item>
      <title>1.2.4 数据类型</title>
      <link>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.4.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.4.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1.2.4 数据类型 Java 语言是一种强类型语言。
  基本数据类型变量存的是数据本身 引用类型变量存的是保存数据的空间地址  说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。
常用的基本数据类型有：  你可能已经注意到了：   String 是一种常见的引用数据类型，用来表示字符串。  自动类型转换 int score1=82; double score2=score1 System.out.println(score2) 运行结果: 82.0
自动类型转换需要满足的条件:
   目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型    目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了    强制类型转换 语法：( 数据类型 ) 数值
double avg1 = 75.8 int avg2=(int)avg1 强制类型转换可能会造成数据的丢失哦</description>
    </item>
    
    <item>
      <title>1.4.4 do while</title>
      <link>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.4.dowhile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.4.dowhile/</guid>
      <description>1.4.4 do while do while  </description>
    </item>
    
    <item>
      <title>1.4.使用diff查看修改了哪些代码</title>
      <link>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.4.%E4%BD%BF%E7%94%A8diff%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.4.%E4%BD%BF%E7%94%A8diff%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81/</guid>
      <description>1.4.使用diff查看修改了哪些代码 名词定义 工作区 工作区，指的是当前正在编辑的文件，将还没有修改的内容通过git add命令暂存起来
暂存区 暂存区，指的是文件修改之后并且通过git add命令临时存储到版本记录里了，但还没有正式通过git commit提交的阶段
比较改动 git diff [文件]
与指定记录比较 你可以先通过git log命令，找到历史提交记录的一个 hash 值。 将要比较的 hash 值复制下来，然后执行如下所示命令：git diff hash值
与最新版本比较 git diff HEAD
比较两个历史记录 git diff hash值1 hash值2
查看暂存区的额外参数 &amp;ndash;cached </description>
    </item>
    
    <item>
      <title>1.4.数词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.4.%E6%95%B0%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.4.%E6%95%B0%E8%AF%8D/</guid>
      <description>1.4.数词 </description>
    </item>
    
    <item>
      <title>2.1.4.多台</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.4.%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.4.%E5%A4%9A%E6%80%81/</guid>
      <description>2.1.4.多台 对象的多种形态 引用多台 父类的引用可以指向本类的对象 父类的引用可以指向子类的对象  方法多台 创建本类对象时, 调用的方法为本类的方法 创建子类对象时, 调用的方法为子类重写的方法或继承的方法  多态中的引用类型转换  向上类型的转换(隐式/自动类型转换),是小类型到大类型的转换 向下类型转换(强制类型转换), 是大类型到小类型 instanceof运算符, 来解决引用对象的类型,避免类型转换的安全性问题 它的作用是测试它左边的对象是否是它右边的类的实例  </description>
    </item>
    
    <item>
      <title>2.13.4.结构体反射</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.4.%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/2.13.4.%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8D%E5%B0%84/</guid>
      <description>2.13.4.结构体反射 与结构体相关的方法 任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。
reflect.Type中与获取结构体成员相关的的方法如下表所示。
   方法 说明     Field(i int) StructField 根据索引，返回索引对应的结构体字段的信息。   NumField() int 返回结构体成员字段数量。   FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。   FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。   FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。   NumMethod() int 返回该类型的方法集中方法的数目   Method(int) Method 返回该类型方法集中的第i个方法   MethodByName(string)(Method, bool) 根据方法名返回该类型方法集中的方法    StructField类型 StructField类型用来描述结构体中的一个字段的信息。
StructField的定义如下：
type StructField struct { // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&amp;quot;&amp;quot;。 // 参见http://golang.</description>
    </item>
    
    <item>
      <title>2.14.4.channel</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.4.channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.4.channel/</guid>
      <description>2.14.4.channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。
虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。
Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。
如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。
Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。
channel类型 channel是一种类型，一种引用类型。声明通道类型的格式如下： 举几个例子：
var ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 创建channel 通道是引用类型，通道类型的空值是nil。
var ch chan int fmt.Println(ch) // &amp;lt;nil&amp;gt; 声明的通道后需要使用make函数初始化之后才能使用。
创建channel的格式如下：
make(chan 元素类型, [缓冲大小]) channel的缓冲大小是可选的。
举几个例子：
ch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) channel操作 通道有发送（send）、接收(receive）和关闭（close）三种操作。
发送和接收都使用&amp;lt;-符号。
现在我们先使用以下语句定义一个通道：
ch := make(chan int) 发送 将一个值发送到通道中。</description>
    </item>
    
    <item>
      <title>2.16.4.Setup与TearDown</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.4.setup%E4%B8%8Eteardown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.4.setup%E4%B8%8Eteardown/</guid>
      <description>2.16.4.Setup与TearDown 测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。
TestMain 通过在*_test.go文件中定义TestMain函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。
如果测试文件包含函数:func TestMain(m *testing.M)那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 m.Run前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用os.Exit。
一个使用TestMain来设置Setup和TearDown的示例如下：
func TestMain(m *testing.M) { fmt.Println(&amp;quot;write setup code here...&amp;quot;) // 测试之前的做一些设置 // 如果 TestMain 使用了 flags，这里应该加上flag.Parse() retCode := m.Run() // 执行测试 fmt.Println(&amp;quot;write teardown code here...&amp;quot;) // 测试之后做一些拆卸工作 os.Exit(retCode) // 退出测试 } 需要注意的是：在调用TestMain时, flag.Parse并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用flag.Parse。
子测试的Setup与Teardown 有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：
// 测试集的Setup与Teardown func setupTestCase(t *testing.T) func(t *testing.T) { t.Log(&amp;quot;如有需要在此执行:测试之前的setup&amp;quot;) return func(t *testing.T) { t.Log(&amp;quot;如有需要在此执行:测试之后的teardown&amp;quot;) } } // 子测试的Setup与Teardown func setupSubTest(t *testing.</description>
    </item>
    
    <item>
      <title>2.2.4.布尔值</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.4.%E5%B8%83%E5%B0%94%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.4.%E5%B8%83%E5%B0%94%E5%80%BC/</guid>
      <description>2.2.4.布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。
注意:
 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。  </description>
    </item>
    
    <item>
      <title>2.2.4.泛型和工具类</title>
      <link>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.4.%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.4.%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>2.2.4.泛型和工具类 </description>
    </item>
    
    <item>
      <title>2.3.4.位运算符</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.4.%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.4.%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>2.3.4.位运算符 位运算符对整数在内存中的二进制位进行操作。
   运算符 描述     &amp;amp; 参与运算的两数各对应的二进位相与。（两位均为1才为1）   | 参与运算的两数各对应的二进位相或。（两位有一个为1就为1）   ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）   &amp;laquo; 左移n位就是乘以2的n次方。“a&amp;laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。   &amp;gt;&amp;gt; 右移n位就是除以2的n次方。“a&amp;raquo;b”是把a的各二进位全部右移b位。    </description>
    </item>
    
    <item>
      <title>2.4.4.goto</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.4.goto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.4.goto/</guid>
      <description>2.4.4.goto(跳转到指定标签) goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：
func gotoDemo1() { var breakFlag bool for i := 0; i &amp;lt; 10; i++ { for j := 0; j &amp;lt; 10; j++ { if j == 2 { // 设置退出标签 breakFlag = true break } fmt.Printf(&amp;quot;%v-%v\n&amp;quot;, i, j) } // 外层for循环判断 if breakFlag { break } } } 使用goto语句能简化代码：
func gotoDemo2() { for i := 0; i &amp;lt; 10; i++ { for j := 0; j &amp;lt; 10; j++ { if j == 2 { // 设置退出标签 goto breakTag } fmt.</description>
    </item>
    
    <item>
      <title>2.4.Dockerfile</title>
      <link>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.4.dockerfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.4.dockerfile/</guid>
      <description>2.4.Dockerfile Dockerfile是由一系列命令和参数构成的脚本,这些命令应用于基础镜像并最终创建一个新的镜像
   命令 作用     FROM image_name:tag 定义了使用哪个基础镜像启动构建流程   MAINTAINER user_name 声明镜像的创建者   ENV key value 设置环境变量(可以写多条)   RUN command 是Dockfile的核心部分(可以写多条)   ADD source_dir/file_dest_dir/file 将宿主机的文件复制到容器内, 如果是一个压缩文件，将会在复制后自动解压   COPY source_dir/file_desc_dir/file 和ADD相似, 但是如果有压缩文件并不能解压   WORKDIR path_dir 设置工作目录    构建命令 docker build -t=&#39;jdk1.8&#39; #构建名为jdk1.8 </description>
    </item>
    
    <item>
      <title>MAP操作</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/map%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/map%E6%93%8D%E4%BD%9C/</guid>
      <description>MAP操作 </description>
    </item>
    
    <item>
      <title>控制结构</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid>
      <description>控制结构 1.if语句 if err, file := os.Open(&amp;quot;xxx&amp;quot;); err == nil { //do smoething } else { return nil, err } if score &amp;gt;= 90 { } else if score &amp;gt;= 80 { } else { }  2.switch语句 switch 语句会根据传入的参数检测并执行符合条件的分支. switch 的语法特点如下: switch 和 if 语句一样, switch后面可以带一个可选的简单的初始化语句 switch 后面的表达式也是可选的, 如果没有表达式, 则case子句是一个布尔表达式. 而不是一个值, 此时就相当于多重if else语句 switch 条件表达式的值不像c语言那样必须限制为整数, 可以是任意支持相等比较运算的类型变量 通过fallthough语句来强制执行下一个case子句(不再判断下一个case子句的条件是否满足) switch支持default语句, 当所有的case分支都不符合时,执行default语句,并且default语句可以放到任意位置,并不影响switch的逻辑判断 swith和.(type)结合可以进行类型的查询， （//todo::） switch i := &amp;quot;y&amp;quot;; i { //switch后面可以带上一个初始化语句 case &amp;quot;y&amp;quot;, &amp;quot;Y&amp;quot;: //多个case值使用逗号分隔 fmt.</description>
    </item>
    
    <item>
      <title>环境变量配置文件</title>
      <link>https://ruichengm1987.github.io/docs/shell/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/shell/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>shell基础 Buttons are styled links that can lead to local page or external link.
Example {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}}  Get Home  Contribute  </description>
    </item>
    
    <item>
      <title>远程登录工具</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%B7%A5%E5%85%B7/</guid>
      <description>远程登录工具 SSH协议原理 对称加密算法: 采用单秘钥密码系统的加密方法
 ssh 用户名@ip scp [-r]  </description>
    </item>
    
    <item>
      <title>迭代器和生成器</title>
      <link>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>迭代器和生成器 迭代器 什么是迭代呢？在编程中，迭代指的是通过重复执行某个操作，不断获取被迭代对象中的数据。这样的每一次操作就是就是一次迭代。
迭代器是具有迭代功能的对象。我们使用迭代器来进行迭代操作。
迭代器 = iter(容器)
&amp;gt;&amp;gt;&amp;gt; numbers=[1,2,3,4,5] &amp;gt;&amp;gt;&amp;gt; it = iter(numbers) &amp;gt;&amp;gt;&amp;gt; it &amp;lt;listiterator object at 0x1007e6950&amp;gt; &amp;gt;&amp;gt;&amp;gt; for 循环的迭代过程 for 循环的迭代就是通过使用迭代器来完成的。它在背后所做的事情是：
 对一个容器调用 iter() 函数，获取到该容器的迭代器 每次循环时对迭代器调用 next() 函数，以获取一个值 若捕获到 StopIteration 异常则结束循环  可迭代（Iterable）对象 并不是所有的对象都可以被 iter() 函数使用。
什么是可迭代(的)？
1、从表面来看，所有可用于 for 循环的对象是可迭代的，如列表、元组、字符串、集合、字典等容器
2、从深层来看，定义了 iter() 方法的类对象就是可迭代的。当这个类对象被 iter() 函数使用时，将返回一个迭代器对象。如果对象具有__iter__() 方法，则可以说它支持迭代协议。
判断一个已有的对象是否是可迭代的 1、 &amp;lsquo;iter&amp;rsquo; in dir(list)
2、 isinstance(对象, Iterable)
自定义迭代器 class MyIterator: def __next__(self): 代码块 def __iter__(self): return self 生成器 刚才我们自定义了迭代器，其实创建迭代器还有另一种方式，就是使用生成器。
生成器是一个函数，这个函数的特殊之处在于它的 return 语句被 yield 语句替代。</description>
    </item>
    
    <item>
      <title>1.2.5 常量</title>
      <link>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.5.%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.5.%E5%B8%B8%E9%87%8F/</guid>
      <description>1.2.5 常量 语法：final 常量名 = 值;
 常量名一般使用大写字符</description>
    </item>
    
    <item>
      <title>1.4.5.for</title>
      <link>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.5.for/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1.4.5.for/</guid>
      <description>1.4.5 for for  </description>
    </item>
    
    <item>
      <title>1.5.动词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.5.%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.5.%E5%8A%A8%E8%AF%8D/</guid>
      <description>1.5.动词 </description>
    </item>
    
    <item>
      <title>1.5.解决提示文件权限被修改问题</title>
      <link>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.5.%E8%A7%A3%E5%86%B3%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A2%AB%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.5.%E8%A7%A3%E5%86%B3%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A2%AB%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/</guid>
      <description>1.5.解决提示文件权限被修改问题 当执行git diff 命令时出现:
diff --git a/index.php b/index.php old mode 100644 new mode 100755 表示文件权限被修改了， 这时候我们git pull拉取下代码,会提示文件冲突: 例如:
git pull eror: Your local changes to the following files would be overwritten by merge: index.php Please commit your changes or stash them before you merge. Aborting 解决方法 在Git进行代码管理时,如果不想让 Git 记录文件权限，可以通过 Git 配置让其忽略文件权限的信息，参考命令如下：
#当前版本库 git config core.filemode false #所有版本库 git config --global core.fileMode false 当上面的命令被执行之后，就设置了忽略文件权限，此时通过cat查看配置文件.git/config，参考命令如下：
cat .git/config 在配置文件中，如果看到fileMode false则代表配置成功.
这时候再次使用git pull命令更新代码就不会再提示有冲突.</description>
    </item>
    
    <item>
      <title>2.1.5.包</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.5.%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.5.%E5%8C%85/</guid>
      <description>2.1.5.包 包的作用 管理Java文件 解决同名文件冲突  定义包:package包名 注: 必须放在Java源程序的第一行, 包名间可以使用&amp;quot;.&amp;quot;号隔开 eg: com.imooc.MyClass  系统中的包 java.(功能).(类) java.lang.(类) 包含java语言基础的类 java.util.(类) 包含java语言中的各种工具类 java.io.(类) 包含输入、输出相关功能的类
包的使用 (1) 可以通过import关键字,在某个文件使用其它文件中的类。
import com.immoc.music.MyClass
(2) java中, 包的命名规范是全小写字母拼写
(3) 使用的时候不但可以加载某个包下的所有文件 eg: com.immoc.*
也可以加载某个具体子包下的所有文件
eg: com.immoc.music.*</description>
    </item>
    
    <item>
      <title>2.14.5.worker pool（goroutine池）</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.5.worker_pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.5.worker_pool/</guid>
      <description>2.14.5.worker pool（goroutine池） 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。
一个简易的work pool示例代码如下：
func worker(id int, jobs &amp;lt;-chan int, results chan&amp;lt;- int) { for j := range jobs { fmt.Printf(&amp;quot;worker:%d start job:%d\n&amp;quot;, id, j) time.Sleep(time.Second) fmt.Printf(&amp;quot;worker:%d end job:%d\n&amp;quot;, id, j) results &amp;lt;- j * 2 } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) // 开启3个goroutine for w := 1; w &amp;lt;= 3; w++ { go worker(w, jobs, results) } // 5个任务 for j := 1; j &amp;lt;= 5; j++ { jobs &amp;lt;- j } close(jobs) // 输出结果 for a := 1; a &amp;lt;= 5; a++ { &amp;lt;-results } } </description>
    </item>
    
    <item>
      <title>2.16.5.示例函数</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.5.%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2.16.5.%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0/</guid>
      <description>2.16.5.示例函数 示例函数的格式 被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下：
func ExampleName() { // ... } 示例函数示例 下面的代码是我们为Split函数编写的一个示例函数：
func ExampleSplit() { fmt.Println(split.Split(&amp;quot;a:b:c&amp;quot;, &amp;quot;:&amp;quot;)) fmt.Println(split.Split(&amp;quot;沙河有沙又有河&amp;quot;, &amp;quot;沙&amp;quot;)) // Output: // [a b c] // [ 河有 又有河] } 为你的代码编写示例代码有如下三个用处：
  示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。
  示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。
  split $ go test -run Example PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s  示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果。   </description>
    </item>
    
    <item>
      <title>2.2.5.Set接口和实现类</title>
      <link>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.5.set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.5.set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</guid>
      <description>2.2.5.Set接口和实现类 </description>
    </item>
    
    <item>
      <title>2.2.5.字符串</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.5.%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.5.%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>2.2.5.字符串 Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(&amp;quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：
s1 := &amp;quot;hello&amp;quot; s2 := &amp;quot;你好&amp;quot; 字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。
   转义符 含义     \r 回车符(返回行首)   \n hua换行符(直接跳到下一行的同列位置)   \t 制表符   \&amp;rsquo; 单引号   \&amp;rdquo; 双引号   \\ 反斜杠    举个例子，我们要打印一个Windows平台下的一个文件路径：
package main import ( &amp;quot;fmt&amp;quot; ) func main() { fmt.Println(&amp;quot;str := \&amp;quot;c:\\Code\\lesson1\\go.exe\&amp;quot;&amp;quot;) } 多行字符串 Go语言中要定义一个多行字符串时，就必须使用反引号字符：
s1 := `第一行 第二行 第三行 ` fmt.</description>
    </item>
    
    <item>
      <title>2.3.5.赋值运算符</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.5.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/2.3.5.%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>2.3.5.赋值运算符    运算符 描述     = 简单的赋值运算符，将一个表达式的值赋给一个左值   += 相加后再赋值   -= 相减后再赋值   *= 相乘后再赋值   /= 相除后再赋值   %= 求余后再赋值   &amp;laquo;= 左移后赋值   &amp;raquo;= 右移后赋值   &amp;amp;= 按位与后赋值   |= 按位或后赋值   ^= 按位异或后赋值    </description>
    </item>
    
    <item>
      <title>2.4.5.break</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.5.break/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.5.break/</guid>
      <description>2.4.5.break(跳出循环) break语句可以结束for、switch和select的代码块。
break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子：
func breakDemo1() { BREAKDEMO1: for i := 0; i &amp;lt; 10; i++ { for j := 0; j &amp;lt; 10; j++ { if j == 2 { break BREAKDEMO1 } fmt.Printf(&amp;quot;%v-%v\n&amp;quot;, i, j) } } fmt.Println(&amp;quot;...&amp;quot;) } </description>
    </item>
    
    <item>
      <title>2.5.Docker私有仓库</title>
      <link>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.5.docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.5.docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</guid>
      <description>2.5.Docker私有仓库 私有仓库搭建与配置 拉取私有仓库镜像
docker pull registry 启动私有仓库容器
docker run -di --name=registry -p 5000:5000 registry 打开终端输入: curl http://127.0.0.1:5000/v2/_catalog 看到{&amp;ldquo;repositories&amp;rdquo;:[]}表示私有仓库搭建成功并且内容为空
修改daemon.json
vim /etc/docker/daemon.json 添加以下内容,保存退出
{ &amp;quot;insecure-registries&amp;quot;: [&amp;quot;127.0.0.1:5000&amp;quot;] } 此步用于docker信任私有仓库地址
重启docker服务
systemctl restart docker 私有仓库镜像上传 docker tag 镜像名称 # docker tag centosofme 127.0.0.1:5000/centosofme # docker images REPOSITORY TAG IMAGE ID CREATED SIZE 127.0.0.1:5000/centosofme latest 30615ec12063 5 hours ago 204MB centosofme latest 30615ec12063 5 hours ago 204MB centos 7 8652b9f0cb4c # docker push 127.0.0.1:5000/centosofme # curl http://127.</description>
    </item>
    
    <item>
      <title>3.5.net/http</title>
      <link>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.5.net.http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.5.net.http/</guid>
      <description>3.5.net/http Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现。
net/http介绍 Go语言内置的net/http包提供了HTTP客户端和服务端的实现。
HTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。
HTTP客户端 基本的HTTP/HTTPS请求 Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。
resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) ... resp, err := http.Post(&amp;quot;http://example.com/upload&amp;quot;, &amp;quot;image/jpeg&amp;quot;, &amp;amp;buf) ... resp, err := http.PostForm(&amp;quot;http://example.com/form&amp;quot;, url.Values{&amp;quot;key&amp;quot;: {&amp;quot;Value&amp;quot;}, &amp;quot;id&amp;quot;: {&amp;quot;123&amp;quot;}}) 程序在使用完response后必须关闭回复的主体。
resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;) if err != nil { // handle error } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... GET请求示例 使用net/http包编写一个简单的发送HTTP请求的Client端，代码如下：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;net/http&amp;quot; ) func main() { resp, err := http.Get(&amp;quot;https://www.liwenzhou.com/&amp;quot;) if err !</description>
    </item>
    
    <item>
      <title>帮助命令</title>
      <link>https://ruichengm1987.github.io/docs/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/</guid>
      <description>帮助命令 帮助命令man man 命令 man的级别 1: 查看命令帮助 2: 查看可被内核调用的函数的帮助 3: 查看函数和函数库的帮助 4: 查看特殊文件的帮助(主要是/dev目录下的文件) 5: 查看配置文件的帮助 6: 查看游戏的帮助 7: 查看其他杂项的帮助 8: 查看系统管理员可用命令的帮助 9: 查看和内核相关文件的帮助 查看命令拥有哪个级别的帮助 man -f 命令 或者 whatis 命令 举例: man -5 passwd man -4 null man -8 ifconfig 查看和命令相关的所有帮助 man -k 命令 或者 apropos 命令 举例: man -k passwd  其他帮助命令 * 选项帮助: 命令 --help #获取命令选项的帮助 例如: ls --help * shell内部命令帮助 help shell内部命令 #获取shell内部命令的帮助 例如: whereis cd #确定是否是shell内部命令 只要找不到执行文件都是内部命令 help cd #获取内部命令帮助 * 详细命令帮助info - 回车: 进入子帮助页面(带有*号标记) - u: 进入上层页面 - n: 进入下一个帮助小节 - p: 进入上一个帮助小节 - q: 退出  </description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://ruichengm1987.github.io/docs/shell/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/shell/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>shell基础 Buttons are styled links that can lead to local page or external link.
Example {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}}  Get Home  Contribute  </description>
    </item>
    
    <item>
      <title>生成器表达式和列表生成式</title>
      <link>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</guid>
      <description>生成器表达式和列表生成式 列表生成式 nums = [2 ** i for i in range(1, 11)] 这行代码就是我们这个章节要所讲的列表生成式。顾名思义，列表生成式最终生成的是一个列表，它是用已有的可迭代对象来构造新列表的便捷方法。
列表生成式的写法 列表生成式的语法如下： [对项的操作 for 项 in 可迭代对象]
列表生成式中使用 if 在列表生成式的中，每次迭代的 项 是可以被筛选过滤的，使用 if 关键字。如： [对项的操作 for 项 in 可迭代对象 if 对项的判断]
列表生成式中嵌套 for 列表生成式中的 for 中还可以再嵌套 for。如：[对项1和(或)项2的操作 for 项1 in 可迭代对象1 for 项2 in 可迭代对象2]
字典生成式 便捷地构造列表可以使用列表生成式，同样的，想要通过已有的可迭代对象来便捷地构造字典，可以使用字典生成式。
字典生成式的写法是：{键: 值 for 项 in 可迭代对象}
集合生成式 你可能已经猜到了，只需要将列表生成式的方括号（[]）替换为花括号（{}）即可：{对项的操作 for 项 in 可迭代对象}
生成器表达式 Python 中并没有「元组生成式」！虽然 Python 中确实有类似的圆括号的写法：(对项的操作 for 项 in 可迭代对象)</description>
    </item>
    
    <item>
      <title>结构体操作</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E7%BB%93%E6%9E%84%E4%BD%93%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B8%B8%E7%94%A8/%E7%BB%93%E6%9E%84%E4%BD%93%E6%93%8D%E4%BD%9C/</guid>
      <description>结构体操作 类型转换 比较对比 搜索 查找 统计 替换 删除过滤 大小写转换 前缀后缀 字符串分割 拼接 </description>
    </item>
    
    <item>
      <title>1.2.6 注释</title>
      <link>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.6.%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.2.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/1.2.6.%E6%B3%A8%E9%87%8A/</guid>
      <description>1.2.6 注释 注释有三种类型：单行注释、多行注释、文档
 PS：使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息：
 @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明  </description>
    </item>
    
    <item>
      <title>1.6.副词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.6.%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.6.%E5%89%AF%E8%AF%8D/</guid>
      <description>1.6.副词 </description>
    </item>
    
    <item>
      <title>1.6.忽略指定文件或目录</title>
      <link>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.6.%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/1.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.6.%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</guid>
      <description>1.6.忽略指定文件或目录 我们可以在在Git工作区的根目录下创建一个.gitignore文件，把想忽略的文件名或者目录填进去，Git 就会自动忽略这些文件。
vi .gitignore .DS_Store .idea 常见问题   无法添加.gitignore windows系统会出现
  添加忽略文件 .gitignore 文件支持通配符，当你在文件中添加一些忽略规则之后，可能匹配过于宽松，导致某一个文件无法提交到 git ;这个时候你有两种方式来处理，
  或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：
$ git check-ignore -v 文件名 .gitignore:1:.DS_Store .DS_Store Git 会告诉我们，.gitignore 的第 1 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。
除了修改 .gitignore 文件的规则之外还可以使用强制添加的方式:
git add -f .DS_Store </description>
    </item>
    
    <item>
      <title>2.1.6.抽象类</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.6.%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.6.%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid>
      <description>2.1.6.抽象类 使用规则  abstract定义抽象类 abstract定义抽象方法,只有声明,不需要实现 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法, 也可以没有抽象方法 抽象类不能直接创建, 可以定义引用变量  public abstract class Telphone { public abstract void call() } </description>
    </item>
    
    <item>
      <title>2.14.6.select多路复用</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.6.select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.6.select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>2.14.6.select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：
for{ // 尝试从ch1接收值 data, ok := &amp;lt;-ch1 // 尝试从ch2接收值 data, ok := &amp;lt;-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。
select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：
select{ case &amp;lt;-ch1: ... case data := &amp;lt;-ch2: ... case ch3&amp;lt;-data: ... default: 默认操作 } 举个小例子来演示下select的使用：
func main() { ch := make(chan int, 1) for i := 0; i &amp;lt; 10; i++ { select { case x := &amp;lt;-ch: fmt.Println(x) case ch &amp;lt;- i: } } } 使用select语句能提高代码的可读性。
 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select{}会一直等待，可用于阻塞main函数。  </description>
    </item>
    
    <item>
      <title>2.2.6.byte和rune类型</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.6.byte%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.6.byte%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</guid>
      <description>2.2.6.byte和rune类型 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：
var a := &#39;中&#39; var b := &#39;x&#39; Go 语言的字符有以下两种：
 uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。  Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。
// 遍历字符串 func traversalString() { s := &amp;quot;hello沙河&amp;quot; for i := 0; i &amp;lt; len(s); i++ { //byte fmt.Printf(&amp;quot;%v(%c) &amp;quot;, s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(&amp;quot;%v(%c) &amp;quot;, r, r) } fmt.Println() } 输出:</description>
    </item>
    
    <item>
      <title>2.2.6.Map接口和实现类</title>
      <link>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.6.map%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2.2.6.map%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</guid>
      <description>2.2.6.Map接口和实现类 </description>
    </item>
    
    <item>
      <title>2.4.6.continue</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.6.continue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2.4.6.continue/</guid>
      <description>2.4.6.continue(继续下次循环) continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。
在 continue语句后添加标签时，表示开始标签对应的循环。例如：
func continueDemo() { forloop1: for i := 0; i &amp;lt; 5; i++ { // forloop2: for j := 0; j &amp;lt; 5; j++ { if i == 2 &amp;amp;&amp;amp; j == 2 { continue forloop1 } fmt.Printf(&amp;quot;%v-%v\n&amp;quot;, i, j) } } } </description>
    </item>
    
    <item>
      <title>2.6.DockerMaven插件</title>
      <link>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.6.dockermaven%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/docker/2.docker%E4%BD%BF%E7%94%A8/2.6.dockermaven%E6%8F%92%E4%BB%B6/</guid>
      <description>2.6.DockerMaven插件 微服务部署有两种方法:
 手动部署: 首先基于源码打包生成jar包, (或war包), 将jar包上传至虚拟机并拷贝到JDK容器 通过Maven插件自动部署  修改宿主机的docker配置,让其可以远程访问 vim /lib/systemd/system/docker.service 修改以ExecStart开头的行
ExecStart= ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 刷新一下配置
systemctl daemon-reload systemctl restart docker docker start registry </description>
    </item>
    
    <item>
      <title>3.6.context</title>
      <link>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.6.context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.6.context/</guid>
      <description>3.6.context 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。
为什么需要Context 基本示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) var wg sync.WaitGroup // 初始的例子 func worker() { for { fmt.Println(&amp;quot;worker&amp;quot;) time.Sleep(time.Second) } // 如何接收外部命令实现退出？？？ wg.Done() } func main() { wg.Add(1) go worker() // 如何优雅的实现结束子goroutine？？？ wg.Wait() fmt.Println(&amp;quot;over&amp;quot;) } 全局变量方式 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) var wg sync.WaitGroup var exit bool // 全局变量方式存在的问题： // 1.</description>
    </item>
    
    <item>
      <title>函数进阶</title>
      <link>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</guid>
      <description>函数进阶 位置参数 位置参数这个东西我们并不陌生，之前所编写的函数使用的就是位置参数。位置参数，顾名思义，传入函数时每个参数都是通过位置来作区分的。函数调用时，传入的值需按照位置与参数一一对应。
def overspeed_rate(current, max, min): if current &amp;gt; max: return (current - max) / max # 超过最大时速，结果为正 elif current &amp;lt; min: return (current - min) / min # 超过最小时速，结果为负 else: return 0 # 不超速，结果为 0 参数默认值 def 函数(参数1, 参数2=默认值): pass 关键字参数 我们还可以在函数调用时，以 参数名=值 的形式来向指定的参数传入值。
overspeed_rate(100, min=80) 任意参数列表 定义函数时，在参数列表中使用 **参数名，可以接收一切关键字参数。类似的，参数列表中使用 *参数名，就可以接受任意数量的非关键字参数，也就是可变参数。 如，计算任意个数的乘积：
def multiply(*nums): result = 1 for n in nums: result *= n return result &amp;gt;&amp;gt;&amp;gt; multiply(1,3,5,7) 105 这个函数能接收任意个参数，这正是 *nums 所发挥的作用。函数所有接收到的非关键字参数组装成一个元组，并绑定到 nums 上。来试验一下：</description>
    </item>
    
    <item>
      <title>流量控制语句</title>
      <link>https://ruichengm1987.github.io/docs/shell/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/shell/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid>
      <description>shell基础 Buttons are styled links that can lead to local page or external link.
Example {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}}  Get Home  Contribute  </description>
    </item>
    
    <item>
      <title>1.7.冠词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.7.%E5%86%A0%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.7.%E5%86%A0%E8%AF%8D/</guid>
      <description>1.7.冠词 </description>
    </item>
    
    <item>
      <title>2.1.7.接口</title>
      <link>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.7.%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/2.1.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.1.7.%E6%8E%A5%E5%8F%A3/</guid>
      <description>2.1.7.接口 接口定义的基本语法 [修饰符] interface 接口名 [extends 父接口1, 父接口2&amp;hellip;] { 零个到多个常量定义 零个到的讴歌抽象方法的定义 }
接口定义 常量:
接口中的属性是常量,即使定义时不添加public static final 修饰符, 系统也会自动加上
方法:
接口中的方法只能是抽象方法,总是使用, 即使定义时不添加public abstract修饰符,系统也会自动加上。
使用接口 一个类可以实现一个或多个接口, 实现接口使用implements关键字. java中一个类只能继承一个父类,是不够灵活的，通过 实现多个接口可以做补充
继承父类实现接口的语法为: [修饰符] class 类名 extends 父类 implements 接口1, 接口2&amp;hellip; { 类体部分 //如果继承了抽象类，需要实现继承的抽象方法;要实现接口中的抽象方法 }
如果要继承父类,继承父类必须在实现接口之前</description>
    </item>
    
    <item>
      <title>2.14.7.并发安全和锁</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.7.%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.7.%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/</guid>
      <description>2.14.7.并发安全和锁 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。
举个例子：
var x int64 var wg sync.WaitGroup func add() { for i := 0; i &amp;lt; 5000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。
互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：
var x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i &amp;lt; 5000; i++ { lock.Lock() // 加锁 x = x + 1 lock.</description>
    </item>
    
    <item>
      <title>2.2.7.类型转换</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.7.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.2.7.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>2.2.7.类型转换 类型强转 Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。
强制类型转换的基本语法如下：
T(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.
比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。
func sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } 使用sprintf 把其它类型转换string类型 int:%d, float:%f, bool:%t, byte:%c
类型使用 %T
通过strconv 把其它类型转换string类型 strconv.FormatInt()
string类型转成整型 </description>
    </item>
    
    <item>
      <title>函数</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%87%BD%E6%95%B0/</guid>
      <description>函数  函数是一种类型,函数类型变量可以像其他类型变量一样使用,可以作为其他函数的参数或返回值,也可以直接调用执行。 函数支持多值返回 支持闭包 函数支持可变参数  基本概念 函数定义 func funcName(param-list) (result-list) { function-body }  函数的特点 1、函数可以没有输入, 也可以没有返回值(默认返回0) 2、多个相邻的相同类型的参数可以使用简写模式: func add(a, b int) int { //a int, b int 简写为 a,b int return a + b } 3、支持有名的返回值,参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化为类型零值， 最后的return可以不带参数名直接返回 func add(a, b int) (sum int) { sum = a + b return //return sum的简写模式 // sum := a + b // 如果是 sum:=a + b, 则相当于新声明一个sum变量命名返回变量sum覆盖 // return sum //最后需要显示的调用return sum } 4、不支持默认值参数 5、不支持函数重载 6、不支持函数嵌套，严格地说是不支持命名函数的嵌套定义，但支持嵌套匿名函数 func add(a, b int) (sum int) { anonymouse := function(x, y int) int { return x + y } return anonymouse(a, b) }  多值返回 func swap(a, b int) (int, int) { return b, a }  实参到形参的传递 package main import &amp;quot;fmt&amp;quot; func chvalue(a int) int { a = a + 1 return a } func chpointer(a *int) { *a = *a + 1 return } func main() { a := 10 chvalue(a) //实参传递给形参是值拷贝 fmt.</description>
    </item>
    
    <item>
      <title>1.8.介词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.8.%E4%BB%8B%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.8.%E4%BB%8B%E8%AF%8D/</guid>
      <description>1.8.介词 </description>
    </item>
    
    <item>
      <title>2.14.8.原子操作</title>
      <link>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.8.%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/2.14.8.%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <description>2.14.8.原子操作 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。
atomic包    方法 解释     func LoadInt32(addr *int32) (val int32) 读取操作   func LoadInt64(addr *int64) (val int64)    func LoadUint32(addr *uint32) (val uint32)    func LoadUint64(addr *uint64) (val uint64)    func LoadUintptr(addr *uintptr) (val uintptr)    func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)    func StoreInt32(addr *int32, val int32) 写入操作   func StoreInt64(addr *int64, val int64)    func StoreUint32(addr *uint32, val uint32)    func StoreUint64(addr *uint64, val uint64)    func StoreUintptr(addr *uintptr, val uintptr)    func StorePointer(addr *unsafe.</description>
    </item>
    
    <item>
      <title>接口</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口 语法 type Traversal interface { Traverse() }  duck typing 定义 使用者-&amp;gt;实现者
接口由使用者定义
接口的实现: 接口的实现是隐式的
只要实现接口里的方法
接口的值类型 fmt.printf(&amp;quot;%T, %v&amp;quot;, 接口变量, 接口变量) #打印接口类型和值 // r.(type) r的类型 switch v := r.(type) { case mock.Retriever: case *real.Retrieve: } // type assertion r.(*real.Retruever) 或 r, ok := r.(mock.Retruever) if ok != nil { fmt.Printf(&amp;quot;Err: %s&amp;quot;, ok) } 接口变量里面有什么: * 接口变量自带指针 * 接口变量同样采用值传递, 几乎不需要使用接口的指针 * 指针接收者实现只能以指针方式使用； 值接收者都可以  接口的组合 // 把Retriever和poster接口组合成一个接口 type RetrieverPoster interface { Retriever Poster }  常用接口 string reader writer  </description>
    </item>
    
    <item>
      <title>1.9.连词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.9.%E8%BF%9E%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.9.%E8%BF%9E%E8%AF%8D/</guid>
      <description>1.9.连词 </description>
    </item>
    
    <item>
      <title>并发</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E5%8F%91/</guid>
      <description>并发 进程、线程、协程   进程:
 进程是什么? 一种系统运行行动 进程的定位是什么? 程序的执行实体 进程长什么样子? 在terminal中查看 进程怎么使用? [一般情况]一个程序一个进程, [多进程]一个程序多个进程    线程:
 线程是什么? 运算调度的最小单元 线程的作用是什么? 同时运算多个任务 和进程有什么区别? 大哥和小弟的关系 线程内存大小?
怎么&amp;quot;切&amp;rdquo;? 内核控制
&amp;ldquo;切多大&amp;rdquo;? 缓存+内核控制
&amp;ldquo;等长吗&amp;rdquo;? 不等长 线程观摩  回到我们的terminal 输入命令ps -M [pid] 查看对应pid的线程      协程
 协程(Coroutine)是什么? 轻量级的线程 协程的定位是什么? 用户控制的函数 有什么样的优势? 协程优势  协程的内存消耗更小  一个线程可以包含多个协程 线程大约8MB的内存申请量 协程大概2kb的内存申请量   上下文切换更快  协程少一道手续 线程申请内存, 需要走过内核 协程申请内存，不需要走过内核        灵魂Goroutine</description>
    </item>
    
    <item>
      <title>1.10.感叹词</title>
      <link>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.10.%E6%84%9F%E5%8F%B9%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/english/1.%E8%AF%8D%E7%B1%BB/1.10.%E6%84%9F%E5%8F%B9%E8%AF%8D/</guid>
      <description>1.10.感叹词 </description>
    </item>
    
    <item>
      <title>3.1.1.异常</title>
      <link>https://ruichengm1987.github.io/docs/java/3.1.%E5%BC%82%E5%B8%B8/3.1.1.%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/3.1.%E5%BC%82%E5%B8%B8/3.1.1.%E5%BC%82%E5%B8%B8/</guid>
      <description>异常 Error Exception 继承 Throwable
try { // 一些会抛出异常的方法 } catch(Exception e) { // 处理该异常的代码块 } try { } catch (InputMismatchException e) { } catch (ArithmeticException e) { } try { } catch (Exception e) { } catch (Exception2 e) { } ...(n个catch块)... { } finally { // 最终将要执行的一些代码 } </description>
    </item>
    
    <item>
      <title>1.7.1.java中的常见注解</title>
      <link>https://ruichengm1987.github.io/docs/java/1.7.%E6%B3%A8%E8%A7%A3/1.7.1.java%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.7.%E6%B3%A8%E8%A7%A3/1.7.1.java%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/</guid>
      <description>1.7.1.java中的常见注解 JDK自带注解  @Override 覆盖父类的方法 @Deprecated 表示已经过时 @Suppvisewarnings @SuppressWarning(&amp;ldquo;deprecation&amp;rdquo;) 忽略deprecation警告  java第三方注解 Spring  @Autowired @Service @Repository  Mybatis  @InsertProvider @UpdateProvider @Options  </description>
    </item>
    
    <item>
      <title>1.7.2.注解的分类</title>
      <link>https://ruichengm1987.github.io/docs/java/1.7.%E6%B3%A8%E8%A7%A3/1.7.2.%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/java/1.7.%E6%B3%A8%E8%A7%A3/1.7.2.%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%88%86%E7%B1%BB/</guid>
      <description>1.7.2.注解的分类 按照运行机制分  源码注解: 注解只在源码中存在,编译成.class文件就不存在了 编译时注解: 注解在源码和.class文件中都存在 (包括: @OVerride @Deprecated, @Suppvi 运行时注解: 在运行阶段还起作用,甚至会影响运行逻辑的注解 (ps: @Autowired)  按照来源分  来自JDK的注解 来自第三方的注解 我们自己定义的注解  自定义注解 TODO::</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/git/git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/git/git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
      <description>git 移除已经add的文件 使用 git rm 命令即可，有两种选择,  一种是 git rm &amp;ndash;cached “文件路径”，不删除物理文件，仅将该文件从缓存中删除； 一种是 git rm &amp;ndash;f “文件路径”，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。  请问 git rm &amp;ndash;cache 和 git reset HEAD 的区别到底在哪里呢？ 如果要删除文件，最好用 git rm file_name，而不应该直接在工作区直接 rm file_name。
如果一个文件已经add到暂存区，还没有 commit，此时如果不想要这个文件了 有两种方法：
 1，用版本库内容清空暂存区，git reset HEAD 但要慎重使用 2，只把特定文件从暂存区删除，git rm &amp;ndash;cached xxx  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.3.log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.3.log/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.4.strconv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/3.4.strconv/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/5.golang%E9%AB%98%E7%BA%A7/%E5%9C%A8-go-%E4%B8%AD%E6%81%B0%E5%88%B0%E5%A5%BD%E5%A4%84%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/5.golang%E9%AB%98%E7%BA%A7/%E5%9C%A8-go-%E4%B8%AD%E6%81%B0%E5%88%B0%E5%A5%BD%E5%A4%84%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>https://segmentfault.com/a/1190000017527311</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/5.golang%E9%AB%98%E7%BA%A7/%E6%B7%B1%E5%85%A5golang%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8Bgmp%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/5.golang%E9%AB%98%E7%BA%A7/%E6%B7%B1%E5%85%A5golang%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8Bgmp%E6%A8%A1%E5%9E%8B/</guid>
      <description>https://www.cnblogs.com/sunsky303/p/9705727.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/go%E9%98%85%E8%AF%BB/100.%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BBgo%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/go%E9%98%85%E8%AF%BB/100.%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BBgo%E4%BB%A3%E7%A0%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E4%B8%8D%E8%83%BD%E5%8F%96%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E4%B8%8D%E8%83%BD%E5%8F%96%E5%9C%B0%E5%9D%80/</guid>
      <description>cannot take address of temporary variables</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/yum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/yum/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E6%BA%90%E7%A0%81%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E6%BA%90%E7%A0%81%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/1.helloworld/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/1.helloworld/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/restapi%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/restapi%E8%A7%84%E8%8C%83/</guid>
      <description>restapi规范 规范 URI 设计原则  资源必须使用复数名词表示集合，如果该词语没有合适的复数形式，则应该使用单数形式  例如： GET /employees GET /weather 必须使用正斜杠（/）表示层次关系 正斜杠（/）字符用于URI的路径部分，以指示资源之间的层次关系。 例如： GET /employees/56   不应该在URI中使用尾部正斜杠（/）
  应该使用连字符（ - ）来提高URI的可读性，不应该使用下划线（ _ ）
  必须在URI中使用小写字母
  资源包含父子嵌套关系必须遵循以下原则
  如果该资源脱离父资源后没有意义，则如下设计，例如：文件的某行与文件的关系 GET /file/1000/line/20 如果该资源可以独立访问或可以从属于多个父资源，则不用嵌套显示， 例如：专辑和歌曲的关系 GET /albums/151 GET /songs/10 版本控制 由于一个API服务可以提供多个API接口，如果有不兼容和破坏性的更改，版本号将让你能更容易的发布API。版本控制格式约定为：vN（N=1,2,3&amp;hellip;）
例如: GET /api/v1/employees/123 GET /api/v2/employees/123 资源操作 HTTP方法 资源操作必须尽可能使用正确的HTTP方法，并且必须遵守操作幂等性。HTTP方法通常被称为HTTP动词。
   方法 安全 幂等     GET 是 是   POST 否 否   PUT 否 是   DELETE 否 是   PATCH 否 否   OPTIONS 是 是   HEAD 是 是    关于以上方法的说明：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/%E7%AE%97%E6%B3%95/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E7%AE%97%E6%B3%95/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <description>二叉搜索树的操作 添加
修改
查找
删除</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/%E7%AE%97%E6%B3%95/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E6%A0%91%E7%9A%843%E7%A7%8D%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E7%AE%97%E6%B3%95/6.%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%A0%91.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E6%A0%91%E7%9A%843%E7%A7%8D%E9%81%8D%E5%8E%86/</guid>
      <description>代码:树的3种遍历 package main import ( &amp;quot;fmt&amp;quot; ) type node struct { Val string Left *node Right *node } type bst struct { root *node } /* m k l h i j a b c d e f */ func (tree *bst) buildTree() { m := &amp;amp;node{Val: &amp;quot;m&amp;quot;} tree.root = m k := &amp;amp;node{Val: &amp;quot;k&amp;quot;} l := &amp;amp;node{Val: &amp;quot;l&amp;quot;} m.Left = k m.Right = l h := &amp;amp;node{Val: &amp;quot;h&amp;quot;} i := &amp;amp;node{Val: &amp;quot;i&amp;quot;} k.</description>
    </item>
    
    <item>
      <title>堆栈</title>
      <link>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E5%A0%86%E6%A0%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/readgo/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E5%A0%86%E6%A0%88/</guid>
      <description>堆栈 </description>
    </item>
    
  </channel>
</rss>