<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="二.并发 多路复用 select { case ret := &lt;-retCh1: t.Logf(&quot;result %s&quot;, ret) case ret := &lt;-retCh2: t.Logf(&quot;result %s&quot;, ret) default: t.Error(&quot;no one returned&quot;) } 如果执行到select时没有收到channel的消息的时候，如果有default就会执行default 超时 select { case ret := &lt;-retCh1: t.Logf(&quot;result %s&quot;, ret) case &lt;-time.After(time.Second * 1) // 超时 t.Error(&quot;time out&quot;) } channel的关闭与广播  向关闭的channel发送数据, 会导致panic v, ok &lt;- ch; ok 为bool值, true表示正常接收, false表示通道关闭 所有的channel接收者都会在channel关闭时,立刻从阻塞等待中返回且上述ok值为false。这个广播机制被利用,进行向多个 订阅者同时发送信号。例如:退出信号 接收已经关闭的通道，将获取该通道类型的默认值  任务的取消 package cancel_task import ( &quot;fmt&quot; &quot;testing&quot; &quot;time&quot; ) func isCancelled(cancelChan chan struct{}) bool { select { case &lt;-cancelChan: return true default: return false } } func cancel_1(cancelChan chan struct {}) { cancelChan &lt;- struct {} { } } func cancel_2(cancelChan chan struct {}) { close(cancelChan) } func TestCancel(t *testing.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="二、并发" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ruichengm1987.github.io/docs/go/2.%E5%B9%B6%E5%8F%91/" />

<title>二、并发 | 笔记本</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css" integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA&#43;eA0kDHPqIYF&#43;1eU=">
<script defer src="/en.search.min.bb4a93f672284143ad5e07bd92e93a011244e3039e121071eecfa2c25a838ec4.js" integrity="sha256-u0qT9nIoQUOtXge9kuk6ARJE4wOeEhBx7s&#43;iwlqDjsQ="></script>
<link rel="alternate" type="application/rss+xml" href="https://ruichengm1987.github.io/docs/go/2.%E5%B9%B6%E5%8F%91/index.xml" title="笔记本" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>笔记本</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/algorithm/" class="collapsed ">algorithm</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/" class="collapsed ">go</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/go/1.%E5%9F%BA%E7%A1%80/" class="collapsed ">一、基础</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.%E5%B9%B6%E5%8F%91/" class="collapsed active">二、并发</a>
  

          
  
  
  

  
  <ul>
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/3.%E6%B5%8B%E8%AF%95/" class="collapsed ">三、测试</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/4.%E5%8F%8D%E5%B0%84%E5%92%8C%E4%B8%8D%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/" class="collapsed ">四、反射和不安全编程</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/5.%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86go-mod/" class="collapsed ">五、依赖管理go mod</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/6.%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/" class="collapsed ">六、文件目录操作</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/%E5%AE%89%E8%A3%85/" class="">安装</a>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/kafka/" class="collapsed ">kafka</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/docker/" class="collapsed ">docker</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/jiagou/" class="collapsed ">jiagou</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/vbox/" class="collapsed ">vbox</a>
  

          
  
  
  

  

        </li>
      
    
      
    
      
        <li>
          
  
    <span>成&#34;神&#34;之路</span>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  















</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>二、并发</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#多路复用">多路复用</a></li>
    <li><a href="#超时">超时</a></li>
    <li><a href="#channel的关闭与广播">channel的关闭与广播</a></li>
    <li><a href="#任务的取消">任务的取消</a></li>
    <li><a href="#context与任务取消">context与任务取消</a></li>
    <li><a href="#仅运行一次">仅运行一次</a></li>
    <li><a href="#仅需任意任务完成">仅需任意任务完成</a></li>
    <li><a href="#所有任务都完成">所有任务都完成</a></li>
    <li><a href="#对象池">对象池</a>
      <ul>
        <li><a href="#使用buffer-channel实现对象池">使用buffer channel实现对象池</a></li>
      </ul>
    </li>
    <li><a href="#syncpool对象缓存">sync.Pool对象缓存</a>
      <ul>
        <li><a href="#syncpool对象的放回">sync.Pool对象的放回</a></li>
        <li><a href="#syncpool对象的生命周期">sync.Pool对象的生命周期</a></li>
        <li><a href="#syncpool总结">sync.Pool总结</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="二并发">二.并发</h1>
<h2 id="多路复用">多路复用</h2>
<pre><code class="language-$xslt" data-lang="$xslt">select {
case ret := &lt;-retCh1:
    t.Logf(&quot;result %s&quot;, ret)
case ret := &lt;-retCh2:
    t.Logf(&quot;result %s&quot;, ret)
default:
    t.Error(&quot;no one returned&quot;)
}
如果执行到select时没有收到channel的消息的时候，如果有default就会执行default
</code></pre><h2 id="超时">超时</h2>
<pre><code class="language-$xslt" data-lang="$xslt">select {
case ret := &lt;-retCh1:
    t.Logf(&quot;result %s&quot;, ret)
case &lt;-time.After(time.Second * 1) // 超时
    t.Error(&quot;time out&quot;)
}
</code></pre><h2 id="channel的关闭与广播">channel的关闭与广播</h2>
<ul>
<li>向关闭的channel发送数据, 会导致panic</li>
<li>v, ok &lt;- ch; ok 为bool值, true表示正常接收, false表示通道关闭</li>
<li>所有的channel接收者都会在channel关闭时,立刻从阻塞等待中返回且上述ok值为false。这个广播机制被利用,进行向多个
订阅者同时发送信号。例如:退出信号</li>
<li>接收已经关闭的通道，将获取该通道类型的默认值</li>
</ul>
<h2 id="任务的取消">任务的取消</h2>
<pre><code class="language-$xslt" data-lang="$xslt">package cancel_task

import (
	&quot;fmt&quot;
	&quot;testing&quot;
	&quot;time&quot;
)

func isCancelled(cancelChan chan struct{}) bool {
	select {
	case &lt;-cancelChan:
		return true
	default:
	    return false
	}
}

func cancel_1(cancelChan chan struct {}) {
	cancelChan &lt;- struct {} {

	}
}

func cancel_2(cancelChan chan struct {}) {
	close(cancelChan)
}

func TestCancel(t *testing.T) {
	cancelChan  := make(chan struct {}, 0)
	for i := 0; i &lt; 5; i++ {
		go func(i int, cancelCh chan struct{}) {
			for {
				if isCancelled(cancelChan) {
					break
				}
				time.Sleep(time.Millisecond * 5)
			}
			fmt.Println(i, &quot;Cancelled()&quot;)
		}(i, cancelChan)
	}
	//cancel_1(cancelChan) // 此方法不可取
	cancel_2(cancelChan) // 广播机制
	time.Sleep(time.Millisecond * 1)
}
</code></pre><h2 id="context与任务取消">context与任务取消</h2>
<ul>
<li>根Context:通过context.Background() 创建</li>
<li>子 Context: context.WithCancel(parentContext) 创建
<ul>
<li>ctx, cancel := context.WithCancel(context.Background())</li>
</ul>
</li>
<li>当前Context被取消时,基于他的子context都会被取消</li>
<li>接收取消通知 &lt;-ctx.Done()</li>
</ul>
<pre><code class="language-$xslt" data-lang="$xslt">package cancel_task

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;testing&quot;
	&quot;time&quot;
)

func isCancelled(ctx context.Context) bool {
	select {
	case &lt;-ctx.Done():
		return true
	default:
	    return false
	}
}

func TestCancel(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	for i := 0; i &lt; 5; i++ {
		go func(i int, ctx context.Context) {
			for {
				if isCancelled(ctx) {
					break
				}
				time.Sleep(time.Millisecond * 5)
			}
			fmt.Println(i, &quot;Cancelled()&quot;)
		}(i, ctx)
	}
	cancel()
	time.Sleep(time.Millisecond * 1)
}
</code></pre><h2 id="仅运行一次">仅运行一次</h2>
<p>sync.once</p>
<pre><code class="language-$xslt" data-lang="$xslt">package once_test

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

type SingletonObj struct {
    Id string
}

var once sync.Once
var obj *SingletonObj

func GetSingletonObj() *SingletonObj {
	once.Do(func() {
		fmt.Println(&quot;Create singleton obj&quot;)
		obj = &amp;SingletonObj{}
	})
	return obj
}
</code></pre><h2 id="仅需任意任务完成">仅需任意任务完成</h2>
<pre><code class="language-$xslt" data-lang="$xslt">package one_ok

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;testing&quot;
	&quot;time&quot;
)

func runTask(id int) string {
	time.Sleep(10 * time.Millisecond)
	return fmt.Sprintf(&quot;The result is from %d&quot;, id)
}

func FirstResponse() string {
	numOfRunner := 10
	ch := make(chan string, numOfRunner) // 使用buffer channel 防止协程泄露
	for i := 0; i &lt; numOfRunner; i++ {
		go func(i int) {
			ret := runTask(i)
			ch &lt;- ret
		}(i)
	}
	return &lt;-ch
}

func TestFirstResponse(t *testing.T) {
	t.Log(&quot;Befor:&quot;, runtime.NumGoroutine())
	t.Log(FirstResponse())
	time.Sleep(time.Second * 1)
	t.Log(&quot;After:&quot;, runtime.NumGoroutine())
}

</code></pre><h2 id="所有任务都完成">所有任务都完成</h2>
<pre><code class="language-$xslt" data-lang="$xslt">package mul_ok

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;testing&quot;
	&quot;time&quot;
)

func runTask(id int) string {
	time.Sleep(10 * time.Millisecond)
	return fmt.Sprintf(&quot;The result is from %d&quot;, id)
}

func AllResponse() string {
	numOfRunner := 10
	ch := make(chan string, numOfRunner) // 使用buffer channel 防止协程泄露
	for i := 0; i &lt; numOfRunner; i++ {
		go func(i int) {
			ret := runTask(i)
			ch &lt;- ret
		}(i)
	}
	finalRet := &quot;&quot;
	for j:=0;j&lt; numOfRunner;j++ {
		finalRet += &lt;-ch + &quot;\n&quot;
	}
	return finalRet
}

func TestFirstResponse(t *testing.T) {
	t.Log(&quot;Befor:&quot;, runtime.NumGoroutine())
	t.Log(AllResponse())
	time.Sleep(time.Second * 1)
	t.Log(&quot;After:&quot;, runtime.NumGoroutine())
}
</code></pre><h2 id="对象池">对象池</h2>
<h3 id="使用buffer-channel实现对象池">使用buffer channel实现对象池</h3>
<pre><code class="language-$xslt" data-lang="$xslt">package pool_test

import (
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;testing&quot;
	&quot;time&quot;
)

type ReusableObj struct {
	
}

type ObjPool struct {
    bufChan chan *ReusableObj
}

func NewObjPool(numOfObj int) *ObjPool {
	objPool := ObjPool {}
	objPool.bufChan = make(chan * ReusableObj, numOfObj)
	for i := 0; i &lt; numOfObj; i++ {
		objPool.bufChan &lt;- &amp;ReusableObj{

		}
	}
	return &amp;objPool
}

func (p *ObjPool) GetObj(timeout time.Duration) (*ReusableObj, error) {
	select {
	case ret := &lt;- p.bufChan:
		return ret, nil
	case &lt;-time.After(timeout):
		return nil, errors.New(&quot;time out&quot;)
	}
}

func (p *ObjPool) ReleaseObj(obj *ReusableObj) error {
	select {
	case p.bufChan &lt;- obj:
		return nil
	default:
		return errors.New(&quot;overflow&quot;)
	}
}

func TestObjPool(t *testing.T) {
	pool := NewObjPool(10)
	for i := 0; i &lt; 11; i++ {
		if v, err := pool.GetObj(time.Second + 1); err != nil {
			t.Error(err)
		} else {
			fmt.Printf(&quot;%T\n&quot;, v)
			if err := pool.ReleaseObj(v); err != nil {
				t.Error(err)
			}

		}
	}
}
</code></pre><h2 id="syncpool对象缓存">sync.Pool对象缓存</h2>
<ul>
<li>尝试从私有对象获取</li>
<li>私有对象不存在，尝试从当前Processor的共享池获取</li>
<li>如果当前Processor共享池也是空的，那么就尝试去其他Processor的共享池获取</li>
<li>如果所有子池都是空的，最后就用用户指定的New函数产生一个新的对象返回</li>
</ul>
<p>私有对象: 协程安全<br>
共享池: 协程不安全</p>
<h3 id="syncpool对象的放回">sync.Pool对象的放回</h3>
<ul>
<li>如果私有对象不存在则保存为私有对象</li>
<li>如果私有对象存在，放入当前Processor子池的共享池中</li>
</ul>
<pre><code class="language-$xslt" data-lang="$xslt">pool := &amp;sync.Pool{
    New: func() interface{} {
        return 0
    },
}
arry := pool.Get().(int)
...
pool.Put(10)
</code></pre><h3 id="syncpool对象的生命周期">sync.Pool对象的生命周期</h3>
<ul>
<li>GC会清除sync.pool缓存的对象</li>
<li>对象的缓存有效期为下一次GC之前</li>
</ul>
<h3 id="syncpool总结">sync.Pool总结</h3>
<ul>
<li>适用于通过复用,降低复杂对象的创建和GC代价</li>
<li>协程安全, 会有锁的开销</li>
<li>生命周期受GC影响,不适合于做 连接池等，需要自己管理生命周期的资源的池化</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#多路复用">多路复用</a></li>
    <li><a href="#超时">超时</a></li>
    <li><a href="#channel的关闭与广播">channel的关闭与广播</a></li>
    <li><a href="#任务的取消">任务的取消</a></li>
    <li><a href="#context与任务取消">context与任务取消</a></li>
    <li><a href="#仅运行一次">仅运行一次</a></li>
    <li><a href="#仅需任意任务完成">仅需任意任务完成</a></li>
    <li><a href="#所有任务都完成">所有任务都完成</a></li>
    <li><a href="#对象池">对象池</a>
      <ul>
        <li><a href="#使用buffer-channel实现对象池">使用buffer channel实现对象池</a></li>
      </ul>
    </li>
    <li><a href="#syncpool对象缓存">sync.Pool对象缓存</a>
      <ul>
        <li><a href="#syncpool对象的放回">sync.Pool对象的放回</a></li>
        <li><a href="#syncpool对象的生命周期">sync.Pool对象的生命周期</a></li>
        <li><a href="#syncpool总结">sync.Pool总结</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












