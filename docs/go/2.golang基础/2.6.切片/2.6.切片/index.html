<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="切片 引子 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：
func arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum &#43; v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，
a := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。
切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。
切片的定义 声明切片类型的基本语法如下：
var name []T 其中，
 name:表示变量名 T:表示切片中的元素类型 举个例子：  func main() { // 声明切片类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 var d = []bool{false, true} //声明一个布尔切片并初始化 fmt.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="2.6.切片" />
<meta property="og:description" content="切片 引子 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：
func arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum &#43; v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，
a := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。
切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。
切片的定义 声明切片类型的基本语法如下：
var name []T 其中，
 name:表示变量名 T:表示切片中的元素类型 举个例子：  func main() { // 声明切片类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 var d = []bool{false, true} //声明一个布尔切片并初始化 fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ruichengm1987.github.io/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/2.6.%E5%88%87%E7%89%87/" />

<title>2.6.切片 | 真努力与假努力</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css" integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA&#43;eA0kDHPqIYF&#43;1eU=">
<script defer src="/en.search.min.4c64710a2873b92852352b7991742d921e548b8a1991f49a943b1b66f676176b.js" integrity="sha256-TGRxCihzuShSNSt5kXQtkh5Ui4oZkfSalDsbZvZ2F2s="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>真努力与假努力</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/c&#43;&#43;/" class="collapsed ">C&#43;&#43;</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/docker/" class="collapsed ">docker</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/english/" class="collapsed ">Englinsh</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/" class="collapsed ">Go</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/go/1.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="collapsed ">1.开发环境</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/" class="collapsed ">2. Golang基础</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.1.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/" class="collapsed ">2.1.变量和常量</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="collapsed ">2.2.基本数据类型</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.3.%E8%BF%90%E7%AE%97%E7%AC%A6/" class="collapsed ">2.3.运算符</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.4.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="collapsed ">2.4.流程控制</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.5.%E6%95%B0%E7%BB%84/" class="collapsed ">2.5.数组</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/" class="collapsed ">2.6.切片</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.6.%E5%88%87%E7%89%87/2.6.%E5%88%87%E7%89%87/" class="active">2.6.切片</a>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.7.map/" class="collapsed ">2.7.map</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.8.%E5%87%BD%E6%95%B0/" class="collapsed ">2.8.函数</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.9.%E6%8C%87%E9%92%88/" class="collapsed ">2.9.指针</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.10.%E7%BB%93%E6%9E%84%E4%BD%93/" class="collapsed ">2.10.结构体</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.11.%E5%8C%85/" class="collapsed ">2.11.包</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.12.%E6%8E%A5%E5%8F%A3/" class="collapsed ">2.12.接口</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.13.%E5%8F%8D%E5%B0%84/" class="collapsed ">2.13.反射</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.14.%E5%B9%B6%E5%8F%91/" class="collapsed ">2.14.并发</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/2.golang%E5%9F%BA%E7%A1%80/2.16.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="collapsed ">2.16.单元测试</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/3.%E6%A0%87%E5%87%86%E5%BA%93/" class="collapsed ">3.标准库</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/4.web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/" class="collapsed ">4. Web开发相关</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/5.golang%E9%AB%98%E7%BA%A7/" class="collapsed ">5. Golang高级</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/6.golang%E6%BA%90%E7%A0%81/" class="collapsed ">6. Golang源码</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/7.%E5%BA%94%E7%94%A8/" class="collapsed ">7.应用</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/8.go%E8%BF%9B%E9%98%B6/" class="collapsed ">8. Go进阶</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/java/" class="collapsed ">java</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/kafka/" class="collapsed ">kafka</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/mysql/" class="collapsed ">Mysql</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/rust/" class="collapsed ">Rust</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" class="collapsed ">项目管理</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/python/" class="collapsed ">Python</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/datas_tructure/" class="collapsed ">Datas Tructure</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/chart/" class="collapsed ">Chart</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/git/" class="collapsed ">git</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/linux/" class="collapsed ">Linux</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/nginx/" class="collapsed ">Nginx</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/shell/" class="collapsed ">Shell</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/%E7%AE%97%E6%B3%95/" class="collapsed ">算法</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/%E4%BA%94%E7%AC%94/" class="collapsed ">五笔</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/" class="collapsed ">架构师</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  















</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2.6.切片</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#引子">引子</a></li>
    <li><a href="#切片-1">切片</a></li>
    <li><a href="#切片的定义">切片的定义</a></li>
    <li><a href="#切片的长度和容量">切片的长度和容量</a>
      <ul>
        <li><a href="#切片表达式">切片表达式</a></li>
      </ul>
    </li>
    <li><a href="#使用make函数构造切片">使用make()函数构造切片</a></li>
    <li><a href="#切片的本质">切片的本质</a></li>
    <li><a href="#判断切片是否为空">判断切片是否为空</a></li>
    <li><a href="#切片不能直接比较">切片不能直接比较</a></li>
    <li><a href="#切片的赋值拷贝">切片的赋值拷贝</a></li>
    <li><a href="#切片遍历">切片遍历</a></li>
    <li><a href="#append方法为切片添加元素">append()方法为切片添加元素</a></li>
    <li><a href="#切片的扩容策略">切片的扩容策略</a></li>
    <li><a href="#使用copy函数复制切片">使用copy()函数复制切片</a></li>
    <li><a href="#从切片中删除元素">从切片中删除元素</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="切片">切片</h1>
<h2 id="引子">引子</h2>
<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>
<pre><code class="language-aidl" data-lang="aidl">func arraySum(x [3]int) int{
    sum := 0
    for _, v := range x{
        sum = sum + v
    }
    return sum
}

</code></pre><p>这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，</p>
<pre><code class="language-aidl" data-lang="aidl">a := [3]int{1, 2, 3}
</code></pre><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p>
<h2 id="切片-1">切片</h2>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<p>切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p>
<h2 id="切片的定义">切片的定义</h2>
<p>声明切片类型的基本语法如下：</p>
<pre><code class="language-aidl" data-lang="aidl">var name []T
</code></pre><p>其中，</p>
<ul>
<li>name:表示变量名</li>
<li>T:表示切片中的元素类型
举个例子：</li>
</ul>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}
</code></pre><h2 id="切片的长度和容量">切片的长度和容量</h2>
<p>切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。</p>
<h3 id="切片表达式">切片表达式</h3>
<p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p>
<h4 id="简单切片表达式">简单切片表达式</h4>
<p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1&lt;=索引值&lt;4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))
}
</code></pre><p>输出:</p>
<pre><code class="language-aidl" data-lang="aidl">s:[2 3] len(s):2 cap(s):4
</code></pre><p>为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:</p>
<pre><code class="language-aidl" data-lang="aidl">a[2:]  // 等同于 a[2:len(a)]
a[:3]  // 等同于 a[0:3]
a[:]   // 等同于 a[0:len(a)]
</code></pre><p>注意:<br>
对于数组或字符串，如果0 &lt;= low &lt;= high &lt;= len(a)，则索引合法，否则就会索引越界（out of range）。</p>
<p>对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low &lt;= high。如果索引在运行时超出范围，就会发生运行时panic。</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))
	s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)
	fmt.Printf(&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;, s2, len(s2), cap(s2))
}
</code></pre><p>输出:</p>
<pre><code class="language-aidl" data-lang="aidl">s:[2 3] len(s):2 cap(s):4
s2:[5] len(s2):1 cap(s2):1
</code></pre><h4 id="完整切片表达式">完整切片表达式</h4>
<p>对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：</p>
<pre><code class="language-aidl" data-lang="aidl">a[low : high : max]
</code></pre><p>上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[1:3:5]
	fmt.Printf(&quot;t:%v len(t):%v cap(t):%v\n&quot;, t, len(t), cap(t))
}
</code></pre><p>输出结果：</p>
<pre><code class="language-aidl" data-lang="aidl">t:[2 3] len(t):2 cap(t):4
</code></pre><p>完整切片表达式需要满足的条件是0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)，其他条件和简单切片表达式相同。</p>
<h2 id="使用make函数构造切片">使用make()函数构造切片</h2>
<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下：</p>
<pre><code class="language-aidl" data-lang="aidl">make([]T, size, cap)

</code></pre><p>其中：</p>
<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量
举个例子：</li>
</ul>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre><p>上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。</p>
<h2 id="切片的本质">切片的本质</h2>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<p>举个例子，现在有一个数组a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片s1 := a[:5]，相应示意图如下。</p>

<figure >

    <img src="/architect/02/12.png"  />
    

</figure>

<h2 id="判断切片是否为空">判断切片是否为空</h2>
<p>要检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断。</p>
<h2 id="切片不能直接比较">切片不能直接比较</h2>
<p>切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：</p>
<pre><code class="language-aidl" data-lang="aidl">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre><p>所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。</p>
<h2 id="切片的赋值拷贝">切片的赋值拷贝</h2>
<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre><h2 id="切片遍历">切片遍历</h2>
<p>切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	s := []int{1, 3, 5}

	for i := 0; i &lt; len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}
}
</code></pre><h2 id="append方法为切片添加元素">append()方法为切片添加元素</h2>
<p>Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<pre><code class="language-aidl" data-lang="aidl">func main(){
	var s []int
	s = append(s, 1)        // [1]
	s = append(s, 2, 3, 4)  // [1 2 3 4]
	s2 := []int{5, 6, 7}  
	s = append(s, s2...)    // [1 2 3 4 5 6 7]
}

</code></pre><p>注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。</p>
<pre><code class="language-aidl" data-lang="aidl">var s []int
s = append(s, 1, 2, 3)
</code></pre><p>没有必要像下面的代码一样初始化一个切片再传入append()函数使用，</p>
<pre><code class="language-aidl" data-lang="aidl">s := []int{}  // 没有必要初始化
s = append(s, 1, 2, 3)

var s = make([]int)  // 没有必要初始化
s = append(s, 1, 2, 3)
</code></pre><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>举个例子：</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	//append()添加元素和切片扩容
	var numSlice []int
	for i := 0; i &lt; 10; i++ {
		numSlice = append(numSlice, i)
		fmt.Printf(&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice)
	}
}
</code></pre><p>输出:</p>
<pre><code class="language-aidl" data-lang="aidl">[0]  len:1  cap:1  ptr:0xc0000a8000
[0 1]  len:2  cap:2  ptr:0xc0000a8040
[0 1 2]  len:3  cap:4  ptr:0xc0000b2020
[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
</code></pre><p>从上面的结果可以看出：</p>
<ul>
<li>append()函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ul>
<p>append()函数还支持一次性追加多个元素。 例如：</p>
<pre><code class="language-aidl" data-lang="aidl">var citySlice []string
// 追加一个元素
citySlice = append(citySlice, &quot;北京&quot;)
// 追加多个元素
citySlice = append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)
// 追加切片
a := []string{&quot;成都&quot;, &quot;重庆&quot;}
citySlice = append(citySlice, a...)
fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
</code></pre><h2 id="切片的扩容策略">切片的扩容策略</h2>
<p>可以通过查看$GOROOT/src/runtime/slice.go源码，其中扩容相关代码如下：</p>
<pre><code class="language-aidl" data-lang="aidl">newcap := old.cap
doublecap := newcap + newcap
if cap &gt; doublecap {
	newcap = cap
} else {
	if old.len &lt; 1024 {
		newcap = doublecap
	} else {
		// Check 0 &lt; newcap to detect overflow
		// and prevent an infinite loop.
		for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
			newcap += newcap / 4
		}
		// Set newcap to the requested cap when
		// the newcap calculation overflowed.
		if newcap &lt;= 0 {
			newcap = cap
		}
	}
}
</code></pre><p>从上面的代码可以看出以下内容：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。</p>
<h2 id="使用copy函数复制切片">使用copy()函数复制切片</h2>
<p>首先我们来看一个问题：</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	a := []int{1, 2, 3, 4, 5}
	b := a
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(b) //[1 2 3 4 5]
	b[0] = 1000
	fmt.Println(a) //[1000 2 3 4 5]
	fmt.Println(b) //[1000 2 3 4 5]
}
</code></pre><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>
<p>Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：</p>
<pre><code class="language-aidl" data-lang="aidl">copy(destSlice, srcSlice []T)
</code></pre><p>其中：</p>
<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>
<p>举个例子：</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre><h2 id="从切片中删除元素">从切片中删除元素</h2>
<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<pre><code class="language-aidl" data-lang="aidl">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre><p>总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]&hellip;)</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#引子">引子</a></li>
    <li><a href="#切片-1">切片</a></li>
    <li><a href="#切片的定义">切片的定义</a></li>
    <li><a href="#切片的长度和容量">切片的长度和容量</a>
      <ul>
        <li><a href="#切片表达式">切片表达式</a></li>
      </ul>
    </li>
    <li><a href="#使用make函数构造切片">使用make()函数构造切片</a></li>
    <li><a href="#切片的本质">切片的本质</a></li>
    <li><a href="#判断切片是否为空">判断切片是否为空</a></li>
    <li><a href="#切片不能直接比较">切片不能直接比较</a></li>
    <li><a href="#切片的赋值拷贝">切片的赋值拷贝</a></li>
    <li><a href="#切片遍历">切片遍历</a></li>
    <li><a href="#append方法为切片添加元素">append()方法为切片添加元素</a></li>
    <li><a href="#切片的扩容策略">切片的扩容策略</a></li>
    <li><a href="#使用copy函数复制切片">使用copy()函数复制切片</a></li>
    <li><a href="#从切片中删除元素">从切片中删除元素</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












