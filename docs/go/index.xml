<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on 笔记本</title>
    <link>https://ruichengm1987.github.io/docs/go/</link>
    <description>Recent content in go on 笔记本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://ruichengm1987.github.io/docs/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/%E5%AE%89%E8%A3%85/</guid>
      <description>安装 卸载docker sudo yum remove docker
docker-client
docker-client-latest
docker-common
docker-latest
docker-latest-logrotate
docker-logrotate
docker-engine
安装docker环境依赖 yum install -y yum-utils device-mapper-persistent-data lvm2
配置国内docker-ce的yum源(阿里云) yum-config-manager &amp;ndash;add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
会下载 /etc/yum.repos.d/docker-ce.repo 文件
安装docker yum install aocker-ce docker-ce-cli containerd.io -y
docker-ce-cli docker命令行工具包 containerd.io 容器接口相关包 启动并设置开机启动 systemctl start docker &amp;amp;&amp;amp; systemctl enable docker
curl -fsSL get.docker.com -o get-docker.sh</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ruichengm1987.github.io/docs/go/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/go/%E5%B9%B6%E5%8F%91/%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</guid>
      <description>互斥锁的实现机制 临界区 在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。
我们可以使用互斥锁，限定临界区只能同时由一个线程持有。
当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。
Mutex 是使用最广泛的同步原语（Synchronization primitives，有人也叫做并发原语。
在这门课的前两个模块，我会和你讲互斥锁 Mutex、读写锁 RWMutex、并发编排 WaitGroup、条件变量 Cond、Channel 等同步原语。所以，在这里，我先和你说一下同步原语的适用场景。
同步原语的适用场景
 共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。(共享资源一般靠锁来控制) 任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。 消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。  在 Go 的标准库中，package sync 提供了锁相关的一系列同步原语，这个 package 还定义了一个 Locker 的接口，Mutex 就实现了这个接口。
简单来说，互斥锁 Mutex 就提供两个方法 Lock 和 Unlock：进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法：
当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。
import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var count = 0 // 使用WaitGroup等待10个goroutine完成 var wg sync.</description>
    </item>
    
  </channel>
</rss>