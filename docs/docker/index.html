<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Docker 1、概念  镜像：可以理解为软件安装包，可以方便的进行传播和安装。 容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。  1.1、安装 https://docs.docker.com/engine/install/#server
1.2、镜像加速源    镜像加速器 镜像加速器地址     Docker 中国官方镜像 https://registry.docker-cn.com   DaoCloud 镜像站 http://f1361db2.m.daocloud.io   Azure 中国镜像 https://dockerhub.azk8s.cn   科大镜像站 https://docker.mirrors.ustc.edu.cn   阿里云 https://&lt;your_code&gt;.mirror.aliyuncs.com   七牛云 https://reg-mirror.qiniu.com   网易云 https://hub-mirror.c.163.com   腾讯云 https://mirror.ccs.tencentyun.com    通过:registry-mirrors参数配置
2、Docker 快速安装软件 2.1、演示 Docker 安装 Redis Docker 官方镜像仓库查找 Redis ：https://hub.docker.com/
安装: docker run -d -p 6379:6379 &ndash;name redis redis:latest 3、命令参考 https://docs.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="docker" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ruichengm1987.github.io/docs/docker/" />

<title>docker | 笔记本</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css" integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA&#43;eA0kDHPqIYF&#43;1eU=">
<script defer src="/en.search.min.7cf83567475c6f602e7ab967781ad24ccddf00033fe1ed0f5e8e51d3643d6e72.js" integrity="sha256-fPg1Z0dcb2AuerlneBrSTM3fAAM/4e0PXo5R02Q9bnI="></script>
<link rel="alternate" type="application/rss+xml" href="https://ruichengm1987.github.io/docs/docker/index.xml" title="笔记本" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>笔记本</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/alg/" class="collapsed ">algorithm</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/" class="collapsed ">algorithm</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/" class="collapsed ">go</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/kafka/" class="collapsed ">kafka</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/docker/" class="collapsed active">docker</a>
  

          
  
  
  

  
  <ul>
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/jiagou/" class="collapsed ">jiagou</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/vbox/" class="collapsed ">vbox</a>
  

          
  
  
  

  

        </li>
      
    
      
    
      
        <li>
          
  
    <span>成&#34;神&#34;之路</span>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  















</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>docker</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#1概念">1、概念</a>
      <ul>
        <li><a href="#11安装">1.1、安装</a></li>
        <li><a href="#12镜像加速源">1.2、镜像加速源</a></li>
      </ul>
    </li>
    <li><a href="#2docker-快速安装软件">2、Docker 快速安装软件</a>
      <ul>
        <li><a href="#21演示-docker-安装-redis">2.1、演示 Docker 安装 Redis</a></li>
      </ul>
    </li>
    <li><a href="#3命令参考">3、命令参考</a>
      <ul>
        <li><a href="#31仓库相关">3.1、仓库相关</a></li>
        <li><a href="#32容器相关">3.2、容器相关</a></li>
        <li><a href="#33镜像相关">3.3、镜像相关</a></li>
        <li><a href="#34run命令相关">3.4、run命令相关</a></li>
        <li><a href="#35进入当前正在运行的容器">3.5、进入当前正在运行的容器</a></li>
        <li><a href="#36从容器拷贝文件到主机">3.6、从容器拷贝文件到主机</a></li>
      </ul>
    </li>
    <li><a href="#4容器数据卷">4、容器数据卷</a>
      <ul>
        <li><a href="#41使用数据卷">4.1、使用数据卷</a></li>
        <li><a href="#42通过dockerfile">4.2、通过Dockerfile</a></li>
        <li><a href="#43数据卷容器">4.3、数据卷容器</a></li>
      </ul>
    </li>
    <li><a href="#5dockerfile">5、Dockerfile</a>
      <ul>
        <li><a href="#51构建步骤">5.1、构建步骤</a></li>
        <li><a href="#52dockerfile的指令">5.2、Dockerfile的指令</a></li>
        <li><a href="#53实战">5.3、实战</a></li>
        <li><a href="#54研究人家dockerfile如何做的">5.4、研究人家dockerfile如何做的</a></li>
        <li><a href="#55cmd和entrypoint-区别">5.5、CMD和ENTRYPOINT 区别</a></li>
        <li><a href="#56发布自己的镜像">5.6、发布自己的镜像</a></li>
      </ul>
    </li>
    <li><a href="#6docker网络">6、Docker网络</a>
      <ul>
        <li><a href="#61原理">6.1、原理</a></li>
        <li><a href="#62--link">6.2、&ndash;link</a></li>
        <li><a href="#63自定义网络">6.3、自定义网络</a></li>
      </ul>
    </li>
    <li><a href="#7redis集群部署实战">7、redis集群部署实战</a></li>
    <li><a href="#8微服务打包docker镜像">8、微服务打包docker镜像</a></li>
    <li><a href="#9docker-compose">9、Docker compose</a></li>
    <li><a href="#10docker-swarm">10、Docker Swarm</a></li>
    <li><a href="#11cicd">11、CICD</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="docker">Docker</h1>
<h2 id="1概念">1、概念</h2>
<ul>
<li>镜像：可以理解为软件安装包，可以方便的进行传播和安装。</li>
<li>容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</li>
</ul>
<h3 id="11安装">1.1、安装</h3>
<p><a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p>
<h3 id="12镜像加速源">1.2、镜像加速源</h3>
<table>
<thead>
<tr>
<th>镜像加速器</th>
<th>镜像加速器地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 中国官方镜像</td>
<td><a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></td>
</tr>
<tr>
<td>DaoCloud 镜像站</td>
<td><a href="http://f1361db2.m.daocloud.io">http://f1361db2.m.daocloud.io</a></td>
</tr>
<tr>
<td>Azure 中国镜像</td>
<td><a href="https://dockerhub.azk8s.cn">https://dockerhub.azk8s.cn</a></td>
</tr>
<tr>
<td>科大镜像站</td>
<td><a href="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a></td>
</tr>
<tr>
<td>阿里云</td>
<td>https://&lt;your_code&gt;.mirror.aliyuncs.com</td>
</tr>
<tr>
<td>七牛云</td>
<td><a href="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></td>
</tr>
<tr>
<td>网易云</td>
<td><a href="https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a></td>
</tr>
<tr>
<td>腾讯云</td>
<td><a href="https://mirror.ccs.tencentyun.com">https://mirror.ccs.tencentyun.com</a></td>
</tr>
</tbody>
</table>
<p>通过:registry-mirrors参数配置</p>
<h2 id="2docker-快速安装软件">2、Docker 快速安装软件</h2>
<h3 id="21演示-docker-安装-redis">2.1、演示 Docker 安装 Redis</h3>
<p>Docker 官方镜像仓库查找 Redis ：https://hub.docker.com/</p>
<h4 id="安装-docker-run--d--p-63796379---name-redis-redislatest">安装: docker run -d -p 6379:6379 &ndash;name redis redis:latest</h4>
<h2 id="3命令参考">3、命令参考</h2>
<p><a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p>
<h3 id="31仓库相关">3.1、仓库相关</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>docker search $KEY_WORD</strong></td>
<td><strong>查找镜像</strong></td>
</tr>
<tr>
<td><strong>docker pull $REGISTRY:$TAG</strong></td>
<td><strong>获取镜像</strong></td>
</tr>
<tr>
<td><strong>docker push $IMAGE_NAME:$IMAGE_TAG</strong></td>
<td><strong>推送镜像到仓库，需要先登录</strong></td>
</tr>
<tr>
<td><strong>docker login $REGISTRY_URL</strong></td>
<td><strong>登录仓库</strong></td>
</tr>
<tr>
<td><strong>docker logout $REGISTRY_URL</strong></td>
<td><strong>退出仓库</strong></td>
</tr>
<tr>
<td><strong>docker info</strong></td>
<td><strong>显示Docker详细的系统信息，可查看仓库地址</strong></td>
</tr>
<tr>
<td><strong>docker version</strong></td>
<td><strong>显示Docker信息</strong></td>
</tr>
<tr>
<td><strong>docker &ndash;help</strong></td>
<td><strong>显示Docker的帮助信息</strong></td>
</tr>
</tbody>
</table>
<h3 id="32容器相关">3.2、容器相关</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker attach $CONTAINER_ID</td>
<td>启动一个已存在的docker容器</td>
</tr>
<tr>
<td><strong>docker stop $CONTAINER_ID</strong></td>
<td><strong>停止docker容器</strong></td>
</tr>
<tr>
<td><strong>docker start $CONTAINER_ID</strong></td>
<td><strong>启动docker容器</strong></td>
</tr>
<tr>
<td><strong>docker restart $CONTAINER_ID</strong></td>
<td><strong>重启docker容器</strong></td>
</tr>
<tr>
<td><strong>docker kill $CONTAINER_ID</strong></td>
<td><strong>强制关闭docker容器</strong></td>
</tr>
<tr>
<td>docker pause $CONTAINER_ID</td>
<td>暂停容器</td>
</tr>
<tr>
<td>docker unpause $CONTAINER_ID</td>
<td>恢复暂停的容器</td>
</tr>
<tr>
<td>docker rename $CONTAINER_ID</td>
<td>重新命名docker容器</td>
</tr>
<tr>
<td><strong>docker rm $CONTAINER_ID</strong></td>
<td><strong>删除容器</strong></td>
</tr>
<tr>
<td><strong>docker logs $CONTAINER_ID</strong></td>
<td><strong>查看docker容器运行日志，确保正常运行</strong></td>
</tr>
<tr>
<td><strong>docker inspect $CONTAINER_ID</strong></td>
<td><strong>查看container的容器属性，比如ip等等</strong></td>
</tr>
<tr>
<td><strong>docker port $CONTAINER_ID</strong></td>
<td><strong>查看container的端口映射</strong></td>
</tr>
<tr>
<td><strong>docker top $CONTAINER_ID</strong></td>
<td><strong>查看容器中正在运行的进程</strong></td>
</tr>
<tr>
<td><strong>docker commit $CONTAINER_ID</strong> $NEW_IMAGE_NAME:$NEW_IMAGE_TAG</td>
<td><strong>将容器保存为镜像</strong></td>
</tr>
<tr>
<td><strong>docker ps -a</strong></td>
<td><strong>查看所有容器</strong></td>
</tr>
<tr>
<td><strong>docker stats</strong></td>
<td><strong>查看容器的资源使用情况</strong></td>
</tr>
</tbody>
</table>
<h3 id="33镜像相关">3.3、镜像相关</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>docker images</strong></td>
<td><strong>查看本地镜像</strong></td>
</tr>
<tr>
<td><strong>docker rmi $IMAGE_ID</strong></td>
<td><strong>删除本地镜像</strong></td>
</tr>
<tr>
<td><strong>docker rmi -f $(docker images -qa)</strong></td>
<td><strong>删除本地所有镜像</strong></td>
</tr>
<tr>
<td><strong>docker inspect $IMAGE_ID</strong></td>
<td><strong>查看镜像详情</strong></td>
</tr>
<tr>
<td>docker save $IMAGE_ID &gt; 文件路径</td>
<td>保存镜像为离线文件</td>
</tr>
<tr>
<td>docker save -o 文件路径 $IMAGE_ID</td>
<td>保存镜像为离线文件</td>
</tr>
<tr>
<td>docker load &lt; 文件路径</td>
<td>加载文件为docker镜像</td>
</tr>
<tr>
<td>docker load -i 文件路径</td>
<td>加载文件为docker镜像</td>
</tr>
<tr>
<td><strong>docker tag $IMAGE_ID $NEW_IMAGE_NAME:$NEW_IMAGE_TAG</strong></td>
<td><strong>修改镜像TAG</strong></td>
</tr>
<tr>
<td><strong>docker run 参数 $IMAGE_ID $CMD</strong></td>
<td><strong>运行一个镜像</strong></td>
</tr>
<tr>
<td><strong>docker history $IMAGE_ID</strong></td>
<td><strong>显示镜像每层的变更内容</strong></td>
</tr>
</tbody>
</table>
<h3 id="34run命令相关">3.4、run命令相关</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>-d</strong></td>
<td><strong>后台运行容器, 并返回容器ID；不指定时, 启动后开始打印日志, Ctrl+C退出命令同时会关闭容器</strong></td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td><strong>以交互模式运行容器, 通常与-t同时使用</strong></td>
</tr>
<tr>
<td><strong>-t</strong></td>
<td><strong>为容器重新分配一个伪输入终端, 通常与-i同时使用</strong></td>
</tr>
<tr>
<td><strong>&ndash;name container_name</strong></td>
<td><strong>设置容器名称, 不指定时随机生成</strong></td>
</tr>
<tr>
<td>-h container_hostname</td>
<td>设置容器的主机名, 默认随机生成</td>
</tr>
<tr>
<td>&ndash;dns 8.8.8.8</td>
<td>指定容器使用的DNS服务器, 默认和宿主机一致</td>
</tr>
<tr>
<td>-e docker_host=172.17.0.1</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>&ndash;cpuset=&quot;0-2&rdquo; or &ndash;cpuset=&quot;0,1,2&rdquo;</td>
<td>绑定容器到指定CPU运行</td>
</tr>
<tr>
<td>-m 100M</td>
<td>设置容器使用内存最大值</td>
</tr>
<tr>
<td>&ndash;net bridge</td>
<td>指定容器的网络连接类型, 支持bridge/host/none/container四种类型</td>
</tr>
<tr>
<td>&ndash;ip 172.18.0.13</td>
<td>为容器指定固定IP（需要使用自定义网络none）</td>
</tr>
<tr>
<td>&ndash;expose 8081 &ndash;expose 8082</td>
<td>开放一个端口或一组端口，会覆盖镜像设置中开放的端口</td>
</tr>
<tr>
<td><strong>-p [宿主机端口]:[容器内端口]</strong></td>
<td><strong>宿主机到容器的端口映射，可指定宿主机的要监听的IP，默认为0.0.0.0</strong></td>
</tr>
<tr>
<td>-P</td>
<td>注意是大写的, 宿主机随机指定一组可用的端口映射容器expose的所有端口</td>
</tr>
<tr>
<td>-v [宿主机目录路径]:[容器内目录路径]</td>
<td>挂载宿主机的指定目录（或文件）到容器内的指定目录（或文件）</td>
</tr>
<tr>
<td>&ndash;add-host [主机名]:[IP]</td>
<td>为容器hosts文件追加host, 默认会在hosts文件最后追加[主机名]:[容器IP]</td>
</tr>
<tr>
<td>&ndash;volumes-from [其他容器名]</td>
<td>将其他容器的数据卷添加到此容器</td>
</tr>
<tr>
<td>&ndash;link [其他容器名]:[在该容器中的别名]</td>
<td>添加链接到另一个容器，在本容器hosts文件中加入关联容器的记录，效果类似于&ndash;add-host</td>
</tr>
</tbody>
</table>
<h3 id="35进入当前正在运行的容器">3.5、进入当前正在运行的容器</h3>
<p>docker exec -it 容器id /bin/bash  #进入容器开启新的终端
docker attach 容器id /bin/bash  #进入容器正在执行的终端,不会启动新的进程</p>
<h3 id="36从容器拷贝文件到主机">3.6、从容器拷贝文件到主机</h3>
<p>docker cp 容器id:容器内路径 目的的主机路径</p>
<h2 id="4容器数据卷">4、容器数据卷</h2>
<h3 id="41使用数据卷">4.1、使用数据卷</h3>
<h4 id="411直接使用命令来挂载--v">4.1.1、直接使用命令来挂载 -v</h4>
<ul>
<li>docker run -it -v [宿主机目录路径]:[容器内目录路径] centos /bin/bash</li>
<li>docker inspect 容器id   #查看Mounts
双向同步的,在容器中改，或者在宿主机改，都会互相同步的。</li>
</ul>
<h4 id="412匿名挂载">4.1.2、匿名挂载</h4>
<ul>
<li>-v 容器内路径: <br>
docker run -d -P -name nginx01 -v /etc/nginx nginx</li>
<li>查看所有卷的情况
docker volume ls</li>
</ul>
<h4 id="413具名挂载">4.1.3、具名挂载</h4>
<ul>
<li>-v 卷名:容器内路径: <br>
docker run -d -P -name nginx02 -v juming-nginx:/etc/nginx nginx</li>
<li>查看一下这个卷
docker volume inspect 卷名</li>
</ul>
<h4 id="414指定路径挂载">4.1.4、指定路径挂载</h4>
<ul>
<li>-v 宿主路径:容器内路径</li>
</ul>
<h4 id="415扩展">4.1.5、扩展</h4>
<p>docker run -d -P -name nginx02 -v juming-nginx:/etc/nginx:ro nginx  #容器不能修改
ro: 只读, rw:可读写</p>
<p>所有的docker容器内的卷,没有指定目录的情况下都是在 /var/lib/docker/volumes/xxxx/_data</p>
<h3 id="42通过dockerfile">4.2、通过Dockerfile</h3>
<p>参考5、Dockerfile</p>
<h3 id="43数据卷容器">4.3、数据卷容器</h3>
<p>利用容器给别的容器共享数据<br>
docker run -it &ndash;name docker01 [容器名称/id]<br>
docker run -it &ndash;name docker02 &ndash;volumes-from docker01 [容器名称/id]</p>
<h2 id="5dockerfile">5、Dockerfile</h2>
<p>Dockerfile是用来构建docker镜像文件</p>
<h3 id="51构建步骤">5.1、构建步骤</h3>
<ul>
<li>编写一个dockerfile文件</li>
<li>docker build 构建成一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像(DockerHub、阿里云镜像仓库)</li>
</ul>
<h3 id="52dockerfile的指令">5.2、Dockerfile的指令</h3>
<pre><code class="language-aidl" data-lang="aidl">FROM #基础镜像,一切从这里开始构建
MAINTAINER   #镜像是谁写的, 姓名+邮箱
RUN          #镜像构建的时候需要运行的命令
ADD          #步骤,tocat镜像；添加内容
WORKDIR      #镜像的工作目录
VOLUME       #挂载的目录位置
EXPOSE       #暴露端口
CMD          #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT   #指定这个容器启动的时候要运行的命令,可以追加命令
ONBUILD      #当构建一个被继承DockerFile 这个时候就会运行ONBUILD的指令、触发指令
COPY         #类似ADD，将我们文件拷贝到镜像中
ENV          #构建的时候设置环境变量
</code></pre><h3 id="53实战">5.3、实战</h3>
<p>scratch 最基础镜像</p>
<h4 id="531编写dockerfile文件">5.3.1、编写dockerfile文件</h4>
<pre><code>FROM centos
MAINTAINER mrc&lt;mrc@qq.com&gt;

ENV MYPATH /usr/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80
CMD echo $MYPATH
CMD echo &quot;----end----&quot;
CMD /bin/bash
</code></pre><h4 id="532构建">5.3.2、构建</h4>
<p>docker build -f dockerfile文件路径 -t 镜像名:[tag] .</p>
<h3 id="54研究人家dockerfile如何做的">5.4、研究人家dockerfile如何做的</h3>
<p>docker history 镜像id</p>
<h3 id="55cmd和entrypoint-区别">5.5、CMD和ENTRYPOINT 区别</h3>
<p>CMD          #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT   #指定这个容器启动的时候要运行的命令,可以追加命令</p>
<h3 id="56发布自己的镜像">5.6、发布自己的镜像</h3>
<p>git push [容器名]:[版本号]</p>
<h2 id="6docker网络">6、Docker网络</h2>
<h3 id="61原理">6.1、原理</h3>
<p>我们每启动一个docker容器 docker就会给docker容器分配一个ip,我们只要安装了docker，就会有一个网卡docker0</p>
<p>桥接模式，使用的技术是evth-pair技术</p>
<pre><code class="language-aidl" data-lang="aidl">我们发现这个容器带来的网卡，都是一对对的  
evth-pair 就是一对虚拟设备接口，他们都是成对出现的，一段俩这协议，一段彼此相连
正以为有这个特性，evth-pair充当了桥梁，连接各种虚拟网络设备的
openstac docker容器之间的连接，都是使用evth-pair技术
</code></pre><p>容器和容器之间是可以互相ping通的</p>
<h3 id="62--link">6.2、&ndash;link</h3>
<p>思考一个场景，我们编写了一个微服务,database url=ip 项目不重启，数据库ip换掉了，我们希望可以处理这个问题。可以名字来进行访问吗？</p>
<p>docker run -d -P -name tomcat03 &ndash;link tomcat02 tomcat<br>
docker exec -it tomcate ping tomcate02</p>
<h3 id="63自定义网络">6.3、自定义网络</h3>
<h4 id="631网络模式">6.3.1、网络模式</h4>
<ul>
<li>bridge: 桥接docker （默认,自己创建也使用bridge模式）</li>
<li>none: 不配置网络</li>
<li>host: 和宿主机共享网络</li>
<li>container: 容器网络连通 (用的少,局限很大)</li>
</ul>
<pre><code class="language-aidl" data-lang="aidl">#我们直接启动的命令 --net 吧 ridge， 而这个就是我们的docker0
docker  run -d -P --name tomcat01 --net bridge tomcat

# docker0特点, 默认，域名不能访问, --link可以打通连接

# 我们可以自定义一个网络
# --driver bridge
# --subnet 192.168.0.0/16 192.168.0.0/24
# --gateway 192.168.0.1
docker network create  --driver bridge --subnet 192.168.0.0、16 --gateway --gateway 192.168.0.1 mynet
</code></pre><p>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络</p>
<h4 id="632网络连通">6.3.2、网络连通</h4>
<p>docker network connect mynet tomcat01</p>
<h2 id="7redis集群部署实战">7、redis集群部署实战</h2>
<p>// todo::</p>
<h2 id="8微服务打包docker镜像">8、微服务打包docker镜像</h2>
<h2 id="9docker-compose">9、Docker compose</h2>
<h2 id="10docker-swarm">10、Docker Swarm</h2>
<h2 id="11cicd">11、CICD</h2>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#1概念">1、概念</a>
      <ul>
        <li><a href="#11安装">1.1、安装</a></li>
        <li><a href="#12镜像加速源">1.2、镜像加速源</a></li>
      </ul>
    </li>
    <li><a href="#2docker-快速安装软件">2、Docker 快速安装软件</a>
      <ul>
        <li><a href="#21演示-docker-安装-redis">2.1、演示 Docker 安装 Redis</a></li>
      </ul>
    </li>
    <li><a href="#3命令参考">3、命令参考</a>
      <ul>
        <li><a href="#31仓库相关">3.1、仓库相关</a></li>
        <li><a href="#32容器相关">3.2、容器相关</a></li>
        <li><a href="#33镜像相关">3.3、镜像相关</a></li>
        <li><a href="#34run命令相关">3.4、run命令相关</a></li>
        <li><a href="#35进入当前正在运行的容器">3.5、进入当前正在运行的容器</a></li>
        <li><a href="#36从容器拷贝文件到主机">3.6、从容器拷贝文件到主机</a></li>
      </ul>
    </li>
    <li><a href="#4容器数据卷">4、容器数据卷</a>
      <ul>
        <li><a href="#41使用数据卷">4.1、使用数据卷</a></li>
        <li><a href="#42通过dockerfile">4.2、通过Dockerfile</a></li>
        <li><a href="#43数据卷容器">4.3、数据卷容器</a></li>
      </ul>
    </li>
    <li><a href="#5dockerfile">5、Dockerfile</a>
      <ul>
        <li><a href="#51构建步骤">5.1、构建步骤</a></li>
        <li><a href="#52dockerfile的指令">5.2、Dockerfile的指令</a></li>
        <li><a href="#53实战">5.3、实战</a></li>
        <li><a href="#54研究人家dockerfile如何做的">5.4、研究人家dockerfile如何做的</a></li>
        <li><a href="#55cmd和entrypoint-区别">5.5、CMD和ENTRYPOINT 区别</a></li>
        <li><a href="#56发布自己的镜像">5.6、发布自己的镜像</a></li>
      </ul>
    </li>
    <li><a href="#6docker网络">6、Docker网络</a>
      <ul>
        <li><a href="#61原理">6.1、原理</a></li>
        <li><a href="#62--link">6.2、&ndash;link</a></li>
        <li><a href="#63自定义网络">6.3、自定义网络</a></li>
      </ul>
    </li>
    <li><a href="#7redis集群部署实战">7、redis集群部署实战</a></li>
    <li><a href="#8微服务打包docker镜像">8、微服务打包docker镜像</a></li>
    <li><a href="#9docker-compose">9、Docker compose</a></li>
    <li><a href="#10docker-swarm">10、Docker Swarm</a></li>
    <li><a href="#11cicd">11、CICD</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












