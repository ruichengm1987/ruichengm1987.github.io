<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="2.6.「并查集」数据结构总结 在「并查集」数据结构中，其中心思想是将所有连接的顶点，无论是直接连接还是间接连接，都将他们指向同一个父节点或者根节点。此时，如果要判断两个顶点是否具有连通性，只要判断它们的根节点是否为同一个节点即可。
在「并查集」数据结构中，它的两个灵魂函数，分别是 find和 union。find 函数是为了找出给定顶点的根节点。 union 函数是通过更改顶点根节点的方式，将两个原本不相连接的顶点表示为两个连接的顶点。对于「并查集」来说，它还有一个重要的功能性函数 connected。它最主要的作用就是检查两个顶点的「连通性」。find 和 union 函数是「并查集」中必不可少的函数。connected 函数则需要根据题目的意思来决定是否需要。
「并查集」代码基本结构 public class UnionFind { // UnionFind 的构造函数，size 为 root 数组的长度 public UnionFind(int size) {} public int find(int x) {} public void union(int x, int y) {} public boolean connected(int x, int y) {} } 「并查集」的 find 函数 它主要是用于查找顶点 x 的根结点。
 find 函数的基本实现  public int find(int x) { while (x != root[x]) { x = root[x]; } return x; }  find 函数的优化 - 路径压缩  public int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } 「并查集」的 union 函数 它主要是连接两个顶点 x 和 y 。将它们的根结点变成相同的，即代表它们来自于同一个根节点。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="2.6.「并查集」数据结构总结" />
<meta property="og:description" content="2.6.「并查集」数据结构总结 在「并查集」数据结构中，其中心思想是将所有连接的顶点，无论是直接连接还是间接连接，都将他们指向同一个父节点或者根节点。此时，如果要判断两个顶点是否具有连通性，只要判断它们的根节点是否为同一个节点即可。
在「并查集」数据结构中，它的两个灵魂函数，分别是 find和 union。find 函数是为了找出给定顶点的根节点。 union 函数是通过更改顶点根节点的方式，将两个原本不相连接的顶点表示为两个连接的顶点。对于「并查集」来说，它还有一个重要的功能性函数 connected。它最主要的作用就是检查两个顶点的「连通性」。find 和 union 函数是「并查集」中必不可少的函数。connected 函数则需要根据题目的意思来决定是否需要。
「并查集」代码基本结构 public class UnionFind { // UnionFind 的构造函数，size 为 root 数组的长度 public UnionFind(int size) {} public int find(int x) {} public void union(int x, int y) {} public boolean connected(int x, int y) {} } 「并查集」的 find 函数 它主要是用于查找顶点 x 的根结点。
 find 函数的基本实现  public int find(int x) { while (x != root[x]) { x = root[x]; } return x; }  find 函数的优化 - 路径压缩  public int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } 「并查集」的 union 函数 它主要是连接两个顶点 x 和 y 。将它们的根结点变成相同的，即代表它们来自于同一个根节点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ruichengm1987.github.io/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.6.%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" />

<title>2.6.「并查集」数据结构总结 | 笔记本</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css" integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA&#43;eA0kDHPqIYF&#43;1eU=">
<script defer src="/en.search.min.bb4a93f672284143ad5e07bd92e93a011244e3039e121071eecfa2c25a838ec4.js" integrity="sha256-u0qT9nIoQUOtXge9kuk6ARJE4wOeEhBx7s&#43;iwlqDjsQ="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>笔记本</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/algorithm/" class="collapsed ">algorithm</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/" class="collapsed ">图</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/1.%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" class="">1.「图」的基本知识</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="collapsed ">2.并查集</a>
  

          
  
  
  

  
  <ul>
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.1.quick-find-%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="">2.1.Quick Find 的「并查集」</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.2.quick-union-%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="">2.2.Quick Union 的「并查集」</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.3.%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="">2.3.按秩合并的「并查集」</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.4.%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="">2.4.路径压缩优化的「并查集」</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.5.%E5%9F%BA%E4%BA%8E%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="">2.5.基于路径压缩的按秩合并优化的「并查集」</a>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/2.6.%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" class="active">2.6.「并查集」数据结构总结</a>
  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/3.%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-/" class="collapsed ">3.「图」的深度优先搜索算法</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/4.%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" class="collapsed ">4.「图」的广度优先搜索算法</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/5.%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" class="collapsed ">5.最小生成树相关算法</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/6.%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" class="collapsed ">6.单源最短路径相关算法</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%9B%BE/7.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B9%8Bkahn%E7%AE%97%E6%B3%95/" class="collapsed ">7.拓扑排序之Kahn算法</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E5%A0%86/" class="collapsed ">堆</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/algorithm/%E6%8E%92%E5%BA%8F/" class="collapsed ">排序</a>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/go/" class="collapsed ">go</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/kafka/" class="collapsed ">kafka</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/docker/" class="collapsed ">docker</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/jiagou/" class="collapsed ">jiagou</a>
  

          
  
  
  

  

        </li>
      
    
      
        <li>
          
  
    <a href="/docs/vbox/" class="collapsed ">vbox</a>
  

          
  
  
  

  

        </li>
      
    
      
    
      
        <li>
          
  
    <span>成&#34;神&#34;之路</span>
  

          
  
  
  

  

        </li>
      
    
  </ul>
  















</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2.6.「并查集」数据结构总结</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#并查集代码基本结构">「并查集」代码基本结构</a></li>
    <li><a href="#并查集的-find-函数">「并查集」的 find 函数</a></li>
    <li><a href="#并查集的-union-函数">「并查集」的 union 函数</a></li>
    <li><a href="#并查集的-connected-函数">「并查集」的 connected 函数</a></li>
    <li><a href="#并查集的刷题小技巧">「并查集」的刷题小技巧</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="26并查集数据结构总结">2.6.「并查集」数据结构总结</h1>
<p>在「并查集」数据结构中，其中心思想是将所有连接的顶点，无论是直接连接还是间接连接，都将他们指向同一个父节点或者根节点。此时，如果要判断两个顶点是否具有连通性，只要判断它们的根节点是否为同一个节点即可。</p>
<p>在「并查集」数据结构中，它的两个灵魂函数，分别是 find和 union。find 函数是为了找出给定顶点的根节点。 union 函数是通过更改顶点根节点的方式，将两个原本不相连接的顶点表示为两个连接的顶点。对于「并查集」来说，它还有一个重要的功能性函数 connected。它最主要的作用就是检查两个顶点的「连通性」。find 和 union 函数是「并查集」中必不可少的函数。connected 函数则需要根据题目的意思来决定是否需要。</p>
<h2 id="并查集代码基本结构">「并查集」代码基本结构</h2>
<pre><code class="language-$xslt" data-lang="$xslt">public class UnionFind {
    // UnionFind 的构造函数，size 为 root 数组的长度
    public UnionFind(int size) {}
    public int find(int x) {}
    public void union(int x, int y) {}
    public boolean connected(int x, int y) {}
}
</code></pre><h2 id="并查集的-find-函数">「并查集」的 find 函数</h2>
<p>它主要是用于查找顶点 x 的根结点。</p>
<ul>
<li>find 函数的基本实现</li>
</ul>
<pre><code class="language-$xslt" data-lang="$xslt">public int find(int x) {
    while (x != root[x]) {
        x = root[x];
    }
    return x;
}
</code></pre><ul>
<li>find 函数的优化 - 路径压缩</li>
</ul>
<pre><code class="language-$xslt" data-lang="$xslt">public int find(int x) {
    if (x == root[x]) {
        return x;
    }
    return root[x] = find(root[x]);
}
</code></pre><h2 id="并查集的-union-函数">「并查集」的 union 函数</h2>
<p>它主要是连接两个顶点 x 和 y 。将它们的根结点变成相同的，即代表它们来自于同一个根节点。</p>
<ul>
<li>union 函数的基本实现</li>
</ul>
<pre><code class="language-$xslt" data-lang="$xslt">public void union(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        root[rootY] = x;
    }
};
</code></pre><ul>
<li>union 函数的优化 - 按秩合并</li>
</ul>
<pre><code class="language-$xslt" data-lang="$xslt">public void union(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        if (rank[rootX] &gt; rank[rootY]) {
            root[rootY] = rootX;
        } else if (rank[rootX] &lt; rank[rootY]) {
            root[rootX] = rootY;
        } else {
            root[rootY] = rootX;
            rank[rootX] += 1;
        }
    }
};
</code></pre><h2 id="并查集的-connected-函数">「并查集」的 connected 函数</h2>
<p>它主要是检查两个顶点 x 和 y 的「连通性」。这个函数通过顶点 x 和 y 的根结点是否相同来判断 x 和 y 的「连通性」。如果 x 和 y 的根结点相同，则为连通。反之，则为不连通。</p>
<pre><code class="language-$xslt" data-lang="$xslt">public boolean connected(int x, int y) {
    return find(x) == find(y);
}
</code></pre><h2 id="并查集的刷题小技巧">「并查集」的刷题小技巧</h2>
<p>「并查集」的代码是高度模版化的。所以作者建议大家熟记「并查集」的实现代码，这样小伙伴们在遇到「并查集」的算法题目的时候，就可以淡定的应对了。作者推荐大家在理解的前题下，请熟记「基于路径压缩+按秩合并的并查集」的实现代码。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#并查集代码基本结构">「并查集」代码基本结构</a></li>
    <li><a href="#并查集的-find-函数">「并查集」的 find 函数</a></li>
    <li><a href="#并查集的-union-函数">「并查集」的 union 函数</a></li>
    <li><a href="#并查集的-connected-函数">「并查集」的 connected 函数</a></li>
    <li><a href="#并查集的刷题小技巧">「并查集」的刷题小技巧</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












