<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>坚持的事:读书&amp;攒钱</title>
    <link>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content on 坚持的事:读书&amp;攒钱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1.优先队列</title>
      <link>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
      <description>1.优先队列 特点 能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是自定义的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。
应用场景 从一堆杂乱无章的数据当中按照一定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据。
举例：任意一个数组，找出前 k 大的数。 解法 1：先对这个数组进行排序，然后依次输出前 k 大的数，复杂度将会是 O(nlogn)，其中，n 是数组的元素个数。这是一种直接的办法。
解法 2：使用优先队列，复杂度优化成 O(k + nlogk)。
当数据量很大（即 n 很大），而 k 相对较小的时候，显然，利用优先队列能有效地降低算法复杂度。因为要找出前 k 大的数，并不需要对所有的数进行排序。
实现 优先队列的本质是一个二叉堆结构。堆在英文里叫 Binary Heap，它是利用一个数组结构来实现的完全二叉树。换句话说，优先队列的本质是一个数组，数组里的每个元素既有可能是其他元素的父节点，也有可能是其他元素的子节点，而且，每个父节点只能有两个子节点，很像一棵二叉树的结构。
牢记下面优先队列有三个重要的性质。  1.数组里的第一个元素 array[0] 拥有最高的优先级别。 2.给定一个下标 i，那么对于元素 array[i] 而言：  它的父节点所对应的元素下标是 (i-1)/2 它的左孩子所对应的元素下标是 2×i + 1 它的右孩子所对应的元素下标是 2×i + 2   3.数组里每个元素的优先级别都要高于它两个孩子的优先级别。  优先队列最基本的操作有两个。  1.向上筛选（sift up / bubble up）  当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。 不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止。  时间复杂度：由于二叉堆是一棵完全二叉树，并假设堆的大小为 k，因此整个过程其实就是沿着树的高度往上爬，所以只需要 O(logk) 的时间。   2.</description>
    </item>
    
    <item>
      <title>2.图</title>
      <link>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%9B%BE/</guid>
      <description>2.图 基本知识点 图可以说是所有数据结构里面知识点最丰富的一个，最基本的知识点如下。
 阶（Order）、度：出度（Out-Degree）、入度（In-Degree） 树（Tree）、森林（Forest）、环（Loop） 有向图（Directed Graph）、无向图（Undirected Graph）、完全有向图、完全无向图 连通图（Connected Graph）、连通分量（Connected Component） 存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）  围绕图的算法也是五花八门。
 图的遍历：深度优先、广度优先 环的检测：有向图、无向图 拓扑排序 最短路径算法：Dijkstra、Bellman-Ford、Floyd Warshall 连通性相关算法：Kosaraju、Tarjan、求解孤岛的数量、判断是否为树 图的着色、旅行商问题等  以上的知识点只是图论里的冰山一角，对于算法面试而言，完全不需要对每个知识点都一一掌握，而应该有的放矢地进行准备。
必会知识点 根据长期的经验总结，以下的知识点是必须充分掌握并反复练习的。
 图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List） 图的遍历：深度优先、广度优先 二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图 拓扑排序 联合-查找算法（Union-Find） 最短路径：Dijkstra、Bellman-Ford  其中，环的检测、二部图的检测、树的检测以及拓扑排序都是基于图的遍历，尤其是深度优先方式的遍历。而遍历可以在邻接矩阵或者邻接链表上进行，所以掌握好图的遍历是重中之重！因为它是所有其他图论算法的基础。
至于最短路径算法，能区分它们的不同特点，知道在什么情况下用哪种算法就很好了。对于有充足时间准备的面试者，能熟练掌握它们的写法当然是最好的。</description>
    </item>
    
    <item>
      <title>3.前缀树</title>
      <link>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E5%89%8D%E7%BC%80%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E5%89%8D%E7%BC%80%E6%A0%91/</guid>
      <description>3.前缀树 </description>
    </item>
    
    <item>
      <title>4.线段树</title>
      <link>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>4.线段树 </description>
    </item>
    
    <item>
      <title>5.树状数组</title>
      <link>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ruichengm1987.github.io/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <description>5.树状数组 </description>
    </item>
    
  </channel>
</rss>