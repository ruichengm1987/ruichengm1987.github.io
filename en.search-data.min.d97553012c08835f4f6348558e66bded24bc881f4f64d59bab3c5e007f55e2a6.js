'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/datas_tructure/%E5%85%A5%E9%97%A8/','title':"入门",'content':"数据结构入门  什么是数据结构 数据结构到底学什么 逻辑结构和物理结构 如何衡量一个算法的好坏  "});index.add({'id':1,'href':'/docs/english/%E8%AF%8D%E7%B1%BB/','title':"词类",'content':"词类  名词\n表人、事物、地点、或抽象概念的名称. 代词\n用来代替名词 形容词\n表人或事物的性质或特征 数词\n表数目或顺序 动词\n表动作或状态 副词\n修饰动词、形容词或副词\n说明时间，地点，程度等 冠词\n用在名词前,帮助说明名词 介词\n表示它后面的名词或代词与其他句子成分的关系  todo:: 看到1.20:49 "});index.add({'id':2,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/','title':"0.入门基础",'content':"入门基础 "});index.add({'id':3,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/','title':"标识符",'content':"标识符 1、预声明标识符 1.1 关键字(25个)  关键字(25个)  1.2 其他预声明标识符(40个)  类型标识符(20个) 常量值标识符(4个) 空白标识符(1个) 内置函数(15个)  2、用户自定义标识符 包名 变量名 常量名 函数名 自定义类型名 方法名  3、操作符和分隔符  操作符和分隔符(47个)  "});index.add({'id':4,'href':'/docs/go/%E5%AE%89%E8%A3%85%E7%AF%87/','title':"安装篇",'content':"安装篇  安装 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':5,'href':'/docs/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/','title':"常用命令",'content':"常用命令  命令基本格式 文件处理命令 文件搜索命令 帮助命令 压缩与解压缩命令 关机和重启命令 其他常用命令  "});index.add({'id':6,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/','title':"网络管理",'content':"网络管理  网络基础 网络配置 网络命令 远程登录  "});index.add({'id':7,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/','title':"软件安装管理",'content':"软件安装管理 "});index.add({'id':8,'href':'/docs/mysql/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/','title':"入门指南",'content':"入门指南  环境搭建  "});index.add({'id':9,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/','title':"进阶语言特性",'content':"进阶语言特性  字符串 列表vs元组 字典vs集合 迭代器和生成器 生成器表达式和列表生成式 函数进阶 函数式编程 入手装饰器 其它常用语言特性  "});index.add({'id':10,'href':'/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/','title':"入门指南",'content':"入门指南  环境搭建  "});index.add({'id':11,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml%E5%9B%BE/','title':"Uml图",'content':"UML图 "});index.add({'id':12,'href':'/docs/c++/','title':"C++",'content':"C++ Let\u0026rsquo;s Go, Go Go Go!!!\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':13,'href':'/docs/english/','title':"Englinsh",'content':"英语语法 Let\u0026rsquo;s Go, Go Go Go!!!\n 词类 句子成分 构词法  "});index.add({'id':14,'href':'/docs/go/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/test/','title':"Go Test 单元测试简明教程",'content':"Go Test 单元测试简明教程 1.如何写好单元测试 单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。\n如何写好单元测试呢？\n首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 mock。\n然后，写可测试的代码。\u0026ldquo;高内聚,低耦合\u0026rdquo; 是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。\n接下来将介绍如何使用 Go 语言的标准库 testing 进行单元测试。\n2.一个简单例子 Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。\nexample/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下:\npackage main func Add(a int, b int) int { return a + b } func Mul(a int, b int) int { return a * b } 那么 calc_test.go 中的测试用例可以这么写：\npackage main import \u0026quot;testing\u0026quot; func TestAdd(t *testing.T) { if ans := Add(1, 2); ans != 3 { t.Errorf(\u0026quot;1 + 2 expected be 3, but %d got\u0026quot;, ans) } if ans := Add(-10, -20); ans != -30 { t.Errorf(\u0026quot;-10 + -20 expected be -30, but %d got\u0026quot;, ans) } }  测试用例名称一般命名为 Test 加上待测试的方法名。 测试用的参数有且只有一个，在这里是 t *testing.T。 基准测试(benchmark)的参数是 *testing.B，TestMain 的参数是 *testing.M 类型。 运行 go test，该 package 下所有的测试用例都会被执行。  $ go test ok example 0.009s 或 go test -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。\n$ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) === RUN TestMul --- PASS: TestMul (0.00s) PASS ok example 0.007s 如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。\n$ go test -run TestAdd -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.007s 3.子测试(Subtests) 子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 t.Run创建不同的子测试用例：\n// calc_test.go func TestMul(t *testing.T) { t.Run(\u0026quot;pos\u0026quot;, func(t *testing.T) { if Mul(2, 3) != 6 { t.Fatal(\u0026quot;fail\u0026quot;) } }) t.Run(\u0026quot;neg\u0026quot;, func(t *testing.T) { if Mul(2, -3) != -6 { t.Fatal(\u0026quot;fail\u0026quot;) } }) }  之前的例子测试失败时使用 t.Error/t.Errorf，这个例子中使用 t.Fatal/t.Fatalf，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。  运行某个测试用例的子测试：\n$ go test -run TestMul/pos -v === RUN TestMul === RUN TestMul/pos --- PASS: TestMul (0.00s) --- PASS: TestMul/pos (0.00s) PASS ok example 0.008s 对于多个子测试的场景，更推荐如下的写法(table-driven tests)：\n// calc_test.go func TestMul(t *testing.T) { cases := []struct { Name string A, B, Expected int }{ {\u0026quot;pos\u0026quot;, 2, 3, 6}, {\u0026quot;neg\u0026quot;, 2, -3, -6}, {\u0026quot;zero\u0026quot;, 2, 0, 0}, } for _, c := range cases { t.Run(c.Name, func(t *testing.T) { if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026quot;%d * %d expected %d, but %d got\u0026quot;, c.A, c.B, c.Expected, ans) } }) } } 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：\n 新增用例非常简单，只需给 cases 新增一条测试数据即可。 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。 用例失败时，报错信息的格式比较统一，测试报告易于阅读。  如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。\n4.帮助函数(helpers) 对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。\n例如，我们可以将创建子测试的逻辑抽取出来：\n// calc_test.go package main import \u0026quot;testing\u0026quot; type calcCase struct{ A, B, Expected int } func createMulTestCase(t *testing.T, c *calcCase) { // t.Helper() if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026quot;%d * %d expected %d, but %d got\u0026quot;, c.A, c.B, c.Expected, ans) } } func TestMul(t *testing.T) { createMulTestCase(t, \u0026amp;calcCase{2, 3, 6}) createMulTestCase(t, \u0026amp;calcCase{2, -3, -6}) createMulTestCase(t, \u0026amp;calcCase{2, 0, 1}) // wrong case } 在这里，我们故意创建了一个错误的测试用例，运行 go test，用例失败，会报告错误发生的文件和行号信息：\n$ go test --- FAIL: TestMul (0.00s) calc_test.go:11: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.007s 可以看到，错误发生在第11行，也就是帮助函数 createMulTestCase 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 t.Helper()，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。\n修改 createMulTestCase，调用 t.Helper()\nfunc createMulTestCase(c *calcCase, t *testing.T) { t.Helper() t.Run(c.Name, func(t *testing.T) { if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\u0026quot;%d * %d expected %d, but %d got\u0026quot;, c.A, c.B, c.Expected, ans) } }) } 运行 go test，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。\n$ go test --- FAIL: TestMul (0.00s) calc_test.go:20: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.006s 关于 helper 函数的 2 个建议：\n 不要返回错误， 帮助函数内部直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。 调用 t.Helper() 让报错信息更准确，有助于定位。  5.setup 和 teardown 如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 testing 提供了这样的机制：\nfunc setup() { fmt.Println(\u0026quot;Before all tests\u0026quot;) } func teardown() { fmt.Println(\u0026quot;After all tests\u0026quot;) } func Test1(t *testing.T) { fmt.Println(\u0026quot;I'm test1\u0026quot;) } func Test2(t *testing.T) { fmt.Println(\u0026quot;I'm test2\u0026quot;) } func TestMain(m *testing.M) { setup() code := m.Run() teardown() os.Exit(code) }  在这个测试文件中，包含有2个测试用例，Test1 和 Test2。 如果测试文件中包含函数 TestMain，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。 调用 m.Run() 触发所有测试用例的执行，并使用 os.Exit() 处理返回的状态码，如果不为0，说明有用例失败。 因此可以在调用 m.Run() 前后做一些额外的准备(setup)和回收(teardown)工作。  执行 go test，将会输出\n$ go test Before all tests I'm test1 I'm test2 PASS After all tests ok example 0.006s 6.网络测试(Network) 6.1 TCP/HTTP 假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler\nfunc helloHandler(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026quot;hello world\u0026quot;)) } 那我们可以创建真实的网络连接进行测试：\n// test code import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;net\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;testing\u0026quot; ) func handleError(t *testing.T, err error) { t.Helper() if err != nil { t.Fatal(\u0026quot;failed\u0026quot;, err) } } func TestConn(t *testing.T) { ln, err := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;127.0.0.1:0\u0026quot;) handleError(t, err) defer ln.Close() http.HandleFunc(\u0026quot;/hello\u0026quot;, helloHandler) go http.Serve(ln, nil) resp, err := http.Get(\u0026quot;http://\u0026quot; + ln.Addr().String() + \u0026quot;/hello\u0026quot;) handleError(t, err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) handleError(t, err) if string(body) != \u0026quot;hello world\u0026quot; { t.Fatal(\u0026quot;expected hello world, but got\u0026quot;, string(body)) } }  net.Listen(\u0026ldquo;tcp\u0026rdquo;, \u0026ldquo;127.0.0.1:0\u0026rdquo;)：监听一个未被占用的端口，并返回 Listener。 调用 http.Serve(ln, nil) 启动 http 服务。 使用 http.Get 发起一个 Get 请求，检查返回值是否正确。 尽量不对 http 和 net 库使用 mock，这样可以覆盖较为真实的场景。  6.2 httptest 针对 http 开发的场景，使用标准库 net/http/httptest 进行测试更为高效。\n上述的测试用例改写如下：\n// test code import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;net/http/httptest\u0026quot; \u0026quot;testing\u0026quot; ) func TestConn(t *testing.T) { req := httptest.NewRequest(\u0026quot;GET\u0026quot;, \u0026quot;http://example.com/foo\u0026quot;, nil) w := httptest.NewRecorder() helloHandler(w, req) bytes, _ := ioutil.ReadAll(w.Result().Body) if string(bytes) != \u0026quot;hello world\u0026quot; { t.Fatal(\u0026quot;expected hello world, but got\u0026quot;, string(bytes)) } } 使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。\n7.Benchmark 基准测试 基准测试是指通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量的和可对比的测试。\n基准测试用例的定义如下：\nfunc BenchmarkName(b *testing.B){ // ... }  函数名必须以 Benchmark 开头，后面一般跟待测试的函数名 参数为 b *testing.B。 执行基准测试时，需要添加 -bench 参数。  例如：\nfunc BenchmarkHello(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026quot;hello\u0026quot;) } } $ go test -benchmem -bench . ... BenchmarkHello-16 15991854 71.6 ns/op 5 B/op 1 allocs/op ... 基准测试报告每一列值对应的含义如下：\ntype BenchmarkResult struct { N int // 迭代次数 T time.Duration // 基准测试花费的时间 Bytes int64 // 一次迭代处理的字节数 MemAllocs uint64 // 总的分配内存的次数 MemBytes uint64 // 总的分配内存的字节数 } 如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：\nfunc BenchmarkHello(b *testing.B) { ... // 耗时操作 b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026quot;hello\u0026quot;) } } 使用 RunParallel 测试并发性能\nfunc BenchmarkParallel(b *testing.B) { templ := template.Must(template.New(\u0026quot;test\u0026quot;).Parse(\u0026quot;Hello, {{.}}!\u0026quot;)) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { // 所有 goroutine 一起，循环一共执行 b.N 次 buf.Reset() templ.Execute(\u0026amp;buf, \u0026quot;World\u0026quot;) } }) } $ go test -benchmem -bench . ... BenchmarkParallel-16 3325430 375 ns/op 272 B/op 8 allocs/op ... 附 参考  https://golang.org/pkg/testing/  "});index.add({'id':15,'href':'/docs/go/','title':"GoLang",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':16,'href':'/docs/linux/1.linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/','title':"Linux命令行快捷键",'content':"Linux命令行快捷键 涉及在linux命令行下进行快速移动光标、命令编辑、编辑后执行历史命令、Bang(!)命令、控制命令等。让basher更有效率。\n常用 ctrl+左右键:在单词之间跳转 * ctrl+a:跳到本行的行首 * ctrl+e:跳到页尾 Ctrl+u：删除当前光标前面的文字 （还有剪切功能） ctrl+k：删除当前光标后面的文字(还有剪切功能) Ctrl+L：进行清屏操作 Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容 Ctrl+w:删除光标前面的单词的字符 Alt – d ：由光标位置开始，往右删除单词。往行尾删 说明 Ctrl – k: 先按住 Ctrl 键，然后再按 k 键； Alt – k: 先按住 Alt 键，然后再按 k 键； M – k：先单击 Esc 键，然后再按 k 键。 移动光标 Ctrl – a ：移到行首 Ctrl – e ：移到行尾 Ctrl – b ：往回(左)移动一个字符 Ctrl – f ：往后(右)移动一个字符 Alt – b ：往回(左)移动一个单词 Alt – f ：往后(右)移动一个单词 Ctrl – xx ：在命令行尾和光标之间移动 M-b ：往回(左)移动一个单词 M-f ：往后(右)移动一个单词 编辑命令 Ctrl – h ：删除光标左方位置的字符 Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端） Ctrl – w ：由光标位置开始，往左删除单词。往行首删 Alt – d ：由光标位置开始，往右删除单词。往行尾删 M – d ：由光标位置开始，删除单词，直到该单词结束。 Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。 Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。 Ctrl – y ：粘贴之前删除的内容到光标后。 ctrl – t ：交换光标处和之前两个字符的位置。 Alt + . ：使用上一条命令的最后一个参数。 Ctrl – _ ：回复之前的状态。撤销操作。 Ctrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。 Bang(!)命令 !! ：执行上一条命令。 ^foo^bar ：把上一条命令里的foo替换为bar，并执行。 !wget ：执行最近的以wget开头的命令。 !wget:p ：仅打印最近的以wget开头的命令，不执行。 !$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。 !* ：上一条命令的所有参数 !*:p ：打印上一条命令是所有参数，也即 !*的内容。 ^abc ：删除上一条命令中的abc。 ^foo^bar ：将上一条命令中的 foo 替换为 bar ^foo^bar^ ：将上一条命令中的 foo 替换为 bar !-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5 查找历史命令 Ctrl – p ：显示当前命令的上一条历史命令 Ctrl – n ：显示当前命令的下一条历史命令 * Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。 Ctrl – g ：从历史搜索模式（Ctrl – r）退出。 控制命令 Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。 Ctrl – o ：执行当前命令，并选择上一条命令。 Ctrl – s ：阻止屏幕输出 Ctrl – q ：允许屏幕输出 Ctrl – c ：终止命令 Ctrl – z ：挂起命令 重复执行操作动作 M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。 "});index.add({'id':17,'href':'/docs/linux/%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/linux%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E6%9F%90%E4%B8%AA%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/','title':"Linux如何关闭某个占用端口的进程",'content':"Linux如何关闭某个占用端口的进程 1）查找被占用的端口: netstat -tln | grep 8000 tcp 0 0 192.168.2.106:8000 0.0.0.0:* LISTEN 2）查看被占用端口的PID： sudo lsof -i:8000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nginx 850 root 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) nginx 851 www-data 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) nginx 852 www-data 6u IPv4 15078 0t0 TCP 192.168.2.106:8000 (LISTEN) 3）kill掉该进程\nsudo kill -9 850 "});index.add({'id':18,'href':'/docs/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':19,'href':'/docs/git/1.%E8%BF%9B%E9%98%B6/0.reset%E5%91%BD%E4%BB%A4%E5%B0%86%E4%BB%93%E5%BA%93%E8%AE%B0%E5%BD%95%E5%92%8C%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E5%8E%86%E5%8F%B2%E4%BD%8D%E7%BD%AE/','title':"reset命令:将仓库记录和恢复指定历史位置",'content':"0.reset命令:将仓库记录和恢复指定历史位置 有时候我们用 git commit 提交代码后发现这一次提交的内容是错误的，需要将代码复原，这个时候常见有两种做法。\n第一种是把代码错误内容修改正确，然后重新使用 commit 提交一次； 这种情况会多2条log记录\n第二种方法是使用 git reset 命令撤销上一次错误的 commit 记录。 git reset HEAD^ # 撤销我们最近一次提交 git reset 815ac616803fa89c75467618b2be44f85696543d # 指定回滚位置, commitid git reset 815ac616803fa89c75467618b2be44f85696543d filename # 回滚某个文件到某次提交 "});index.add({'id':20,'href':'/docs/rust/','title':"Rust",'content':"Rust "});index.add({'id':21,'href':'/docs/shell/shell%E5%9F%BA%E7%A1%80/','title':"shell基础",'content':"shell基础 shell是命令行解析器 关系: 内存-\u0026gt; shell -\u0026gt; 用户  shell概述 脚本执行方法 Bash的基本功能 "});index.add({'id':22,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/uml%E5%9B%BE/%E7%B1%BB%E5%9B%BE%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7/','title':"UML",'content':"UML类图 1.类图基础属性   +表示public -表示private #表示protected ~表示default,也就是包权限 _下划线表示static 斜体表示抽象  2.类与类之间关系 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)\n泛化 介绍： 泛化(Generalization)表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系\n(1) 继承\n介绍：\n继承表示是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。 表示方法：\n继承使用空心三角形+实线表示。\n示例：\n鸟类继承抽象类动物\n （2）实现\n介绍：\n实现表示一个class类实现interface接口（可以是多个）的功能。\n表示方法：\n1）矩形表示法\n使用空心三角形+虚线表示\n比如：大雁需要飞行，就要实现飞()接口\n 2）棒棒糖表示法\n使用实线表示\n 依赖 介绍：\n对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。\n表示方法：\n依赖关系用虚线箭头表示。\n示例：\n动物依赖氧气和水。调用新陈代谢方法需要氧气类与水类的实例作为参数\n 关联 介绍：\n对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。\n表示方法：\n关联关系用实线箭头表示。\n示例：\n企鹅需要‘知道’气候的变化，需要‘了解’气候规律。当一个类‘知道’另一个类时，可以用关联。\n 聚合 介绍：\n表示一种弱的‘拥有’关系，即has-a的关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 两个对象具有各自的生命周期。\n表示方法：\n聚合关系用空心的菱形+实线箭头表示。\n示例：\n每一只大雁都属于一个大雁群，一个大雁群可以有多只大雁。当大雁死去后大雁群并不会消失，两个对象生命周期不同。\n 组合 介绍：\n组合是一种强的‘拥有’关系，是一种contains-a的关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。\n表示方法：\n组合关系用实心的菱形+实线箭头表示，还可以使用连线两端的数字表示某一端有几个实例。\n示例：\n鸟和翅膀就是组合关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。\n "});index.add({'id':23,'href':'/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/','title':"什么是数据结构",'content':"什么是数据结构 数据结构，直白地理解，就是研究数据的存储方式。\n"});index.add({'id':24,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/%E5%85%B3%E9%94%AE%E5%AD%9725%E4%B8%AA/','title':"关键字(25个)",'content':"关键字(25个) 引导程序整体结构的8个关键字  package // 定义包名的关键字 import //导入包名关键字 const //常量声明关键字 var //变量声明关键字 func //函数定义关键字 defer //延迟执行关键字 go //并发语法糖关键字 return //函数返回关键字  声明复合数据结构的4个关键字  struct //定义结构类型关键字 interface //定义接口类型关键字 map //声明或创建map类型关键字 chan //声明或创建通道类型关键字  控制程序结构的13个关键宇  if else //if else语句关键字 for range break continue //for循环使用的关键字 switch select type case default fallthrough //switch和select语句使用的关键字 goto //goto跳转语句关键字  "});index.add({'id':25,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/0.%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgit%E4%BB%93%E5%BA%93/','title':"初识Git:本地创建一个Git仓库",'content':"初识Git:本地创建一个Git仓库 ~ mkdir test ~ cd test ~/test git init 已初始化空的 Git 仓库于 /Users/ruichengm/test/.git/ ~/test(master) ls -al total 0 drwxr-xr-x 3 ruichengm staff 96 7 18 08:46 . drwxr-xr-x+ 107 ruichengm staff 3424 7 18 08:47 .. drwxr-xr-x 9 ruichengm staff 288 7 18 08:46 .git 认识.git ➜ .git git:(master) ls -al total 24 drwxr-xr-x 10 song staff 320 6 25 22:11 . drwxr-xr-x 3 song staff 96 6 25 22:11 .. -rw-r--r-- 1 song staff 23 6 25 22:11 HEAD drwxr-xr-x 2 song staff 64 6 25 22:11 branches -rw-r--r-- 1 song staff 137 6 25 22:11 config -rw-r--r-- 1 song staff 73 6 25 22:11 description drwxr-xr-x 13 song staff 416 6 25 22:11 hooks drwxr-xr-x 3 song staff 96 6 25 22:11 info drwxr-xr-x 4 song staff 128 6 25 22:11 objects drwxr-xr-x 4 song staff 128 6 25 22:11 refs 文件夹的作用\n HEAD 文件指示目前被检出的分支 branches 新版本已经废弃无须理会 description 用来显示对仓库的描述信息 config 文件包含项目特有的配置选项 info 目录包含一个全局性排除文件 hooks 目录包含客户端或服务端的钩子脚本 index 文件保存暂存区信息 objects 目录存储所有数据内容 refs 目录存储分支的提交对象的指针  基础配置 配置名称 git config user.name #查看 git config --global user.name \u0026quot;你的昵称\u0026quot; #修改 配置邮箱 git config user.email #查看 git config --global user.email \u0026quot;你的邮箱\u0026quot; #修改 命令行修改配置 git config --global --replace-all user.name \u0026quot;your user name\u0026quot; git config --global --replace-all user.email\u0026quot;your user email\u0026quot; 修改配置文件 修改文件的方式，主要是修改位于主目录下.gitconfig 文件，可以看到如下配置：\n[user] name = daxia email = 78778443@qq.com git config –list可以查看是否修改成功了\n"});index.add({'id':26,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/','title':"变量\u0026常量",'content':"变量\u0026amp;常量 变量 1、显式的完整声明 var varName dataType [ = value] 说明: 关键字var用于变量声明 varName 是变量名称标识符 dataType 数据类型 value 初始化值 例子: var a int = 1 2、短类型声明 varName := value := 声明只能出现在函数内（包括在方法内） 此时Go编译器自动进行数据类型推断 a, b := 1, \u0026quot;hello\u0026quot;  常量 const a = 1 const ( a = iota ) "});index.add({'id':27,'href':'/docs/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/','title':"名词",'content':"名词 "});index.add({'id':28,'href':'/docs/datas_tructure/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/','title':"垃圾回收算法",'content':"常见垃圾回收算法   引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。\n 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。 代表语言：Python、PHP、Swift    标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为\u0026quot;被引用\u0026rdquo;，没有被标记的进行回收。\n 优点：解决了引用计数的缺点。 缺点：需要STW，即要暂时停掉程序运行。 代表语言：Golang(其采用三色标记法)    分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。\n 优点：回收性能好 缺点：算法复杂 代表语言： JAVA    "});index.add({'id':29,'href':'/docs/datas_tructure/%E5%85%A5%E9%97%A8/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F/','title':"复杂度",'content':"复杂度 复杂度是衡量代码运行效率的重要的度量因素，复杂度通常包括时间复杂度和空间复杂度\n复杂度特性:  复杂度与具体的常系数无关 多项式级的复杂度相加的时候，选择高者作为结果 O(1) 也是表示一个特殊复杂度, 与输入数据量n无关  复杂度的经验结论  一个顺序结构的代码，时间复杂度是O(1) 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度是O(logn). 一个简单的for循环，时间复杂度是O(n) 两个顺序执行的for循环,时间复杂度是O(n)+O(n)=O(2n),其实也是O(n) 两个嵌套的for循环, 时间复杂度是O(n2)  总结 时间复杂度与\u0026laquo;代码的结构设计\u0026raquo;高度相关\n空间复杂度与\u0026laquo;数据结构的选择\u0026raquo;高度相关\n"});index.add({'id':30,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E7%AC%A6%E4%B8%B2/','title':"字符串",'content':"字符串 "});index.add({'id':31,'href':'/docs/go/%E5%AE%89%E8%A3%85%E7%AF%87/%E5%AE%89%E8%A3%85/','title':"安装",'content':"安装 linux 下安装  wget https://dl.google.com/go/go1.x.x.linux-amd64.tar.gz 下载安装包 tar -C /usr/local -zxvf go1.x.x.linux-amd64.tar.gz 添加/usr/loacl/go/bin目录到PATH变量中。添加到/etc/profile 或$HOME/.profile都可以  vim /etc/profile export GOROOT=/usr/local/go #设置为go安装的路径,有些安装包会自动设置默认的goroot export GOPATH=/usr/local/goprojects/ #GO项目路径多个用\u0026rsquo;,\u0026lsquo;分开 export PATH=$PATH:$GOROOT/bin:$GOPATH/bin #加载 source /etc/profile   执行go version，如果现实版本号，则Go环境安装成功.  "});index.add({'id':32,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/%E5%AE%B9%E9%94%99%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E7%81%BE%E5%A4%87/','title':"容错，高可用和灾备",'content':"容错，高可用和灾备 容错 容错（fault tolerance）指的是， 发生故障时，系统还能继续运行。\n飞机有四个引擎，如果一个引擎坏了，剩下三个引擎，还能继续飞，这就是\u0026quot;容错\u0026rdquo;。同样的，汽车的一个轮子扎破了，剩下三个轮子，也还是勉强能行驶。\n容错的目的是，发生故障时，系统的运行水平可能有所下降，但是依然可用，不会完全失败。\n高可用 高可用（high availability）指的是， 系统能够比正常时间更久地保持一定的运行水平。\n汽车的备胎就是一个高可用的例子。如果没有备胎，轮胎坏了，车就开不久了。备胎延长了汽车行驶的可用时间。\n注意，高可用不是指系统不中断（那是容错能力），而是指一旦中断能够快速恢复，即中断必须是短暂的。如果需要很长时间才能恢复可用性，就不叫高可用了。上面例子中，更换备胎就必须停车，但只要装上去，就能回到行驶状态。\n灾备 灾备（又称灾难恢复，disaster recovery）指的是， 发生灾难时恢复业务的能力。\n上图中，飞机是你的 IT 基础设施，飞行员是你的业务，飞行员弹射装置就是灾备措施。一旦飞机即将坠毁，你的基础设施就要没了，灾备可以让你的业务幸存下来。\n灾备的目的就是，保存系统的核心部分。一个好的灾备方案，就是从失败的基础设施中获取企业最宝贵的数据，然后在新的基础设施上恢复它们。注意，灾备不是为了挽救基础设置，而是为了挽救业务。\n总结 上面三个方面可以结合起来，设计一个可靠的系统。\n 容错：发生故障时，如何让系统继续运行。 高可用：系统中断时，如何尽快恢复。 灾备：系统毁灭时，如何抢救数据。  "});index.add({'id':33,'href':'/docs/go/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E6%A0%88%E9%80%83%E9%80%B8/','title':"栈逃逸",'content':"栈逃逸 "});index.add({'id':34,'href':'/docs/git/1.%E8%BF%9B%E9%98%B6/1.%E6%B8%85%E7%90%86%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%88%86%E6%94%AF%E6%95%B0%E6%8D%AE/','title':"清理无意义的分支数据",'content':"清理无意义的分支数据  本地不存在，远程存在该分支，但不需要了 远程不存在，本地存在该分支，也不需要了  清理远程分支 1. 查看分支, 远程分支显示红色 git branch -a remotes/origin/dev 2. 执行命令 git push origin --delete dev 清理本地分支 1. 模拟场景 git checkout -b test6 2. 查看当前版本库的分支 git branch -a 3. 将分支推送到远程服务器中 git push --set-upstream origin test6 4. 查看远程分支的信息 git remote show origin 5. 删除远程分支 git push origin --delete test1 "});index.add({'id':35,'href':'/docs/mysql/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/','title':"环境搭建",'content':"环境搭建 Mac版环境搭建 安装 brew install mysql 安装完后启动mysql mysql.server start 执行安全设置 mysql_secure_installation "});index.add({'id':36,'href':'/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/','title':"环境搭建",'content':"环境搭建 安装 1、 安装rustup $ curl https://sh.rustup.rs -sSf | sh 2、执行 $ source $HOME/.cargo/env 更新 $ rustup update 卸载Rust和rustup $ rustup self uninstall 故障排除 $ rustc --version # 看到rustc x.y.z (abcabcabc yyyy-mm-dd)表示安装成功 恭喜入坑！ "});index.add({'id':37,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/1.%E7%AE%80%E4%BB%8B/','title':"简介",'content':"简介 软件包分类  源码包  脚本安装包   二进制包(RPM包、系统默认包)  "});index.add({'id':38,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/','title':"网络基础",'content':"网络基础 1.iso/osi七层模型 7 应用层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-应用层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 应用层 APDU(应用协议数据单元)\n6 表示层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-表示层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 表示层 PPDU(表示协议数据单元) 5 会话层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-会话层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 会话层 SPDU(会话协议数据单元) 4 传输层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-传输层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 传输层 TPDU(传输协议数据单元)\n3 网络层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-网络层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 网络层 报文 2 数据链路层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-数据链路层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 数据链路层 帧 1 物理层 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;-物理层协议\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt; 物理层 比特\nMAC地址负责局域网通信\nIP地址负责外网通信\n物理层: 设备之间的比特流的传输、物理接口、电气特征等\n数据链路层: 成帧、用MAC地址访问媒介、错误检测与修正\n网络层: 提供逻辑地址、选路\n传输层: 可靠与不可靠的传输、传输前的错误检测、流控\n会话层: 对应用会话的管理、同步\n表示层: 数据的表示形式、特定功能的实现如-加密\n应用层: 用户接口\n2.Tcp/Ip四层模型  应用层 \u0026mdash;\u0026gt; (应用层, 表示层, 会话层) 传输层 \u0026mdash;\u0026gt; (传输层) 网际互联层 \u0026mdash;-\u0026gt; (网络层) 网络接口层 \u0026mdash;-\u0026gt; (物理层, 数据链路层)  网络接口层: 网络接入层是OSI参数模型中的物理层和数据链路层相对应.它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议,而 由参与互连的各网络使用自己的物理层和数据链路层协议, 然后与TCP/IP的网络接入层进行连接. ** 地址解析协议(ARP)工作在此层，即OSI参考模型的数据链路层。\n网际互联层: 网际互联层对应于OSI参考模型的网络层,主要解决主机到主机的通信问题. 它所包含的协议设计数据包在整个网络上的逻辑传输 。改层有三个主要协议: 网际协议(IP)、互联网组管理协议(IGMP) 和互联网控制报文协议(ICMP)\n传输层: 传输层对应于OSI参考模型的传输层, 为应用层实体提供端到端的通信功能, 保证了数据包的顺序传送及数据的完整性, 该层定义了两个主要的协议: 传输控制协议(TCP) 和用户数据报协议(UDP).\n应用层: 应用层对应于OSI参考模型的高层, 为用户提供所需要的各种服务, 例如:FTP、Telnet, DNS, SMTP等.\n数据封装过程               应用数据      字节流(数据)   应用层     FTP头 字节流(数据)   传输层    TCP头 FTP头 字节流(数据)   网络层   IP头 TCP头 FTP头 字节流(数据)   数据链路层  以太帧头 IP头 TCP头 FTP头 字节流(数据)    TCP/IP模型与OSI模型的比较  共同点\n1、OSI参考模型和TCP/IP参考模型都采用了层次结构的概念 2、都能够提供面向连接和无连接两种通信服务机制 不同点\n1、前者是七层模型, 后者是四层结构 2、对可靠性要求不同(后者更高)\n3、OSI模型是在协调开发前设计的,具有通用性.TCP/IP是先有协议集然后建立模型, 不适用于非TCP/IP网络\n4、实际市场应用不同(OSI模型只是理论上的模型), 并没有成熟的产品，而TCP/IP已经成为\u0026quot;实际上的国际标准\u0026rdquo;  3.IP地址 IP报文    0  15 16 31     版本(4)) 头部长度(4) 优先级和服务类型(8) 总长度(16)    标识(16)   标志(3) 偏移量(13)   生存时间(8)  协议(8) 头部校验和(16)      源IP地址(32)       目的IP地址(32)       选项(如果有)       数据      注: 字段后面括号中的数字是指该字段在ip数据包头部信息中所占的位数\nIP地址分类    网络类别 最大网络数 IP地址范围 最大主机数 私有IP地址范围     A 2^7-2 1.0.0.0 - 126.255.255.255 2^24-2 10.0.0.0 - 10.255.255.255   B 2^14 128.0.0.0 - 191.255.255.255 2^16-2 127.16.0.0 - 172.31.255.255   C 2^21 192.0.0.0 - 223.255.255.255 2^8-2 192.168.0.0 - 192.168.255.255    4.子网掩码 255.255.255.0 C类标准网段\n26 另外一种子网掩码的表示\n5.端口作用 TCP协议包头    0  15 16 31     源端口(16))   目的端口(16)      序列号(32)       确认号(32)     数据偏移(4) 保留(6) 标识(13)     校验和(16))   紧急指针(16)      选项       数据      注: 字段后面括号中的数字是指该字段在TCP头部信息中所占的位数\nUDP协议包头    0 15 16 31     源端口(16)  目的端口(16)    长度(16)  校验和(16)      数据     注: 字段后面括号中的数字是指该字段在UDP头部信息中所占的位数\n端口范围: 0-65535 1万以内的端口系统用，以外自己用\n查看本机启用的端口 netstat -an 选项:\n-a: 查看所有连接和监听端口\n-n: 显示IP地址和端口号，而不显示域名和服务名\n6.DNS作用 DNS: 域名系统\n 在互联网中, 通过IP地址来进行通信 IP地址用数字表示, 挤一起来台困难了 人对域名跟家敏感  DNS服务的作用: 将域名解析为IP地址\n域名空间结构  \u0026ldquo;.\u0026rdquo; 根域 根域名的服务器只有13台 顶级域: (组织域, 国家或地区域) 二级域 主机名  7.网关作用 网关作用  网关(Gateway)又称网间连接器、协议转换器 网关在网络层以上实现网络互连,是最复杂的网络互连设备, 仅用于两个高层协议不同的网络互连 网关既可以用于广域网互连, 也可以用于局域网互连。 网关是一种充当转换重任的服务器或路由器  "});index.add({'id':39,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/02%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/','title':"进程与线程的一个简单解释",'content':"进程与线程的一个简单解释 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。\n最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。\n 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。\n 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。\n 一个车间里，可以有很多工人。他们协同完成一个任务。\n 线程就好比车间里的工人。一个进程可以包括多个线程。\n 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。\n 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。\n 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫\u0026quot;互斥锁\u0026rdquo;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。\n 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。\n 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做\u0026quot;信号量\u0026rdquo;（Semaphore），用来保证多个线程不会互相冲突。\n不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。\n 操作系统的设计，因此可以归结为三点：\n（1）以多进程形式，允许多个任务同时运行；\n（2）以多线程形式，允许单个任务分成不同的部分运行；\n（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。\n"});index.add({'id':40,'href':'/docs/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/','title':"项目管理",'content':"项目管理 "});index.add({'id':41,'href':'/docs/datas_tructure/%E7%BA%BF/','title':"线",'content':"线 "});index.add({'id':42,'href':'/docs/git/1.%E8%BF%9B%E9%98%B6/','title':"1.进阶",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n 程序基础 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':43,'href':'/docs/git/2.%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/','title':"2.团队协作",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n 程序基础 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':44,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/','title':"基础篇",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n 程序基础 Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':45,'href':'/docs/python/','title':"Python",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':46,'href':'/docs/python/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/','title':"必备知识",'content':"必备知识  IO操作 进程和线程 虚拟环境 更加python的python代码风格  "});index.add({'id':47,'href':'/docs/shell/bash%E5%8F%98%E9%87%8F/','title':"Bash变量",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':48,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/defer/','title':"defer",'content':"defer 什么是defer  defer是Go语言的一种用于注册延迟调用的机制,使得函数或语句可以在当前函数执行完毕后执行.  为什么需要defer  Go语言提供的语法糖,减少资源泄露的发生.  如何使用defer  在创建资源语句的附近,使得defer语句释放资源.  例子 func f1() (r int) { t := 5 // 1. 赋值指令 r = t // 2. defer被插入到赋值与返回质检， 这个例子中返回值r没被修改过 defer func() { t = t + 5 }() // 3. 空的return指令 return t } 返回值是5 func f2() (r int) { defer func(r int) { r = r + 5 }(r) // 此处r是copy了一份 return 1 } 返回值是1 func f3() (r int) { defer func(r *int) { *r = *r + 5 }(\u0026amp;r) // 此处r是传址 return 1 } 返回值是6 defer 是先入先出 func e1() { var err error defer fmt.Println(err) err = errors.New(\u0026quot;defer1 error\u0026quot;) return } func e2() { var err error def func() { fmt.Println(err) }() err = errors.New(\u0026quot;defer2 error\u0026quot;) return } func e3() { var err error def func(err error) { fmt.Println(err) }(err) err = errors.New(\u0026quot;defer3 error\u0026quot;) return } main执行 e1() e2() e3() 结果是: nil defer2 error nil "});index.add({'id':49,'href':'/docs/go/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/','title':"GC垃圾回收",'content':"垃圾回收 "});index.add({'id':50,'href':'/docs/go/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/mock/','title':"Go Mock (gomock)简明教程",'content':"Go Mock (gomock)简明教程 1.gomock 简介 上一篇文章 Go Test 单元测试简明教程 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。\nGoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too. gomock 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。\n使用如下命令即可安装：\ngo get -u github.com/golang/mock/gomock go get -u github.com/golang/mock/mockgen 2.一个简单的 Demo // db.go type DB interface { Get(key string) (int, error) } func GetFromDB(db DB, key string) int { if value, err := db.Get(key); err != nil { return value } return -1 } 假设 DB 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 GetFromDB 这个函数内部的逻辑，就需要 mock 接口 DB。\n第一步：使用 mockgen 生成 db_mock.go。一般传递三个参数。包含需要被mock的接口得到源文件source，生成的目标文件destination，包名package。\n$ mockgen -source=db.go -destination=db_mock.go -package=main 第二步：新建 db_test.go，写测试用例。\nfunc TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Eq(\u0026quot;Tom\u0026quot;)).Return(0, errors.New(\u0026quot;not exist\u0026quot;)) if v := GetFromDB(m, \u0026quot;Tom\u0026quot;); v != -1 { t.Fatal(\u0026quot;expected -1, but got\u0026quot;, v) } }  这个测试用例有2个目的，一是使用 ctrl.Finish() 断言 DB.Get() 被是否被调用，如果没有被调用，后续的 mock 就失去了意义； 二是测试方法 GetFromDB() 的逻辑是否正确(如果 DB.Get() 返回 error，那么 GetFromDB() 返回 -1)。 NewMockDB() 的定义在 db_test.go 中，由 mockgen 自动生成。  最终的代码结构如下：\nproject/ |--db.go |--db_mock.go // generated by mockgen |--db_test.go 执行测试：\n$ go test . -cover -v === RUN TestGetFromDB --- PASS: TestGetFromDB (0.00s) PASS coverage: 81.2% of statements ok example 0.008s coverage: 81.2% of statements 3.打桩(stubs) 在上面的例子中，当 Get() 的参数为 Tom，则返回 error，这称之为打桩(stub)，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。\n3.1 参数(Eq, Any, Not, Nil) m.EXPECT().Get(gomock.Eq(\u0026quot;Tom\u0026quot;)).Return(0, errors.New(\u0026quot;not exist\u0026quot;)) m.EXPECT().Get(gomock.Any()).Return(630, nil) m.EXPECT().Get(gomock.Not(\u0026quot;Sam\u0026quot;)).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(\u0026quot;nil\u0026quot;))  Eq(value) 表示与 value 等价的值。 Any() 可以用来表示任意的入参。 Not(value) 用来表示非 value 以外的值。 Nil() 表示 None 值  3.2 返回值(Return, DoAndReturn) m.EXPECT().Get(gomock.Not(\u0026quot;Sam\u0026quot;)).Return(0, nil) m.EXPECT().Get(gomock.Any()).Do(func(key string) { t.Log(key) }) m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) { if key == \u0026quot;Sam\u0026quot; { return 630, nil } return 0, errors.New(\u0026quot;not exist\u0026quot;) })  Return 返回确定的值 Do Mock 方法被调用时，要执行的操作吗，忽略返回值。 DoAndReturn 可以动态地控制返回值。  3.3 调用次数(Times) func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Not(\u0026quot;Sam\u0026quot;)).Return(0, nil).Times(2) GetFromDB(m, \u0026quot;ABC\u0026quot;) GetFromDB(m, \u0026quot;DEF\u0026quot;) }  Times() 断言 Mock 方法被调用的次数。 MaxTimes() 最大次数。 MinTimes() 最小次数。 AnyTimes() 任意次数（包括 0 次）。  3.4 调用顺序(InOrder) func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) o1 := m.EXPECT().Get(gomock.Eq(\u0026quot;Tom\u0026quot;)).Return(0, errors.New(\u0026quot;not exist\u0026quot;)) o2 := m.EXPECT().Get(gomock.Eq(\u0026quot;Sam\u0026quot;)).Return(630, nil) gomock.InOrder(o1, o2) GetFromDB(m, \u0026quot;Tom\u0026quot;) GetFromDB(m, \u0026quot;Sam\u0026quot;) } 4 如何编写可 mock 的代码 写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？\n mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。 不直接依赖的实例，而是使用依赖注入降低耦合性。  在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。 如果 GetFromDB() 方法长这个样子\nfunc GetFromDB(key string) int { db := NewDB() if value, err := db.Get(key); err == nil { return value } return -1 } 对 DB 接口的 mock 并不能作用于 GetFromDB() 内部，这样写是没办法进行测试的。那如果将接口 db DB 通过参数传递到 GetFromDB()，那么就可以轻而易举地传入 Mock 对象了。\n附 "});index.add({'id':51,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/iota/','title':"iota",'content':"iota   const (\na = 1 \u0026laquo; iota // a==1 (iota == 0)\nb = 1 \u0026laquo; iota // b==2 （iota == 1）\nc = 3 // c == 3 (iota==2, unused)\nd = 1 \u0026laquo; iota // d==8 (iota == 3) )\n  const x = iota // x==0\n  const y = iota // y==0 分开的const语句,iota每次都从0开始\n  "});index.add({'id':52,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/rpm/','title':"RPM",'content':"RPM RPM包在系统光盘中 RPM包命名规则 httpd-2.2.15-15.el6.CENTOS.1.i686.rpm\n-httpd 软件包名\n-2.2.15 软件版本 -15 软件包发布的次数\n-el6.centos 适合的Linux平台 -i686 适合的硬件平台 -rpm rpm包扩展名\nRPM包依赖性  树形依赖: a -\u0026gt; b -\u0026gt; c 环形依赖: a -\u0026gt; b -\u0026gt; c -\u0026gt; a 模块依赖: 模块依赖, 查询网站: www.rpmfind.net  包全名与报名  包全名 操作的包是没有安装的软件包时,使用包全名,而且要注意路径 报名 操作已经安装的软件包时,使用包名,是搜索/var/lib/rpm中的数据库  RPM安装  rpm -ivh 包全名 选项: -i (install) 安装 -v (verbose) 显示详细信息 -h (hash) 显示进度 \u0026ndash;nodeps 不检测依赖性  RPM升级与卸载  rpm -Uvh 包全名 选项: -U (upgrade) 升级  RPM "});index.add({'id':53,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1.%E4%BD%BF%E7%94%A8git%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%88%B0%E6%9C%AC%E5%9C%B0/','title':"使用Git命令下载远程仓库到本地",'content':"使用Git命令下载远程仓库到本地 HTTP(S)获取远程仓库 首次拉取 git clone 版本库地址\t[本地文件夹名称]\n更新代码 git pull\n临时记住密码  git config –-global credential.helper cache #默认缓存15分钟 git config credential.helper \u0026lsquo;cache –timeout=3600\u0026rsquo; #自定义配置记住 1 小时的命令  永久记住密码 git config \u0026ndash;global credential.helper store\n修改配置文件.gitconfig\n[credential] helper = store 在上面的命令中，如果没有\u0026ndash;global，则会在当前项目下的.git/config文件增加配置\nSSH拉取 git clone git@gitee.com:xxx/xxxx.git xxxx\n创建一个ssh key 执行命令: ssh-keygen 之后一直回车\n查看公钥 cat ~/.ssh/id_rsa.pub\n添加公钥到服务器 把公钥粘贴上去\n"});index.add({'id':54,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%88%97%E8%A1%A8vs%E5%85%83%E7%BB%84/','title':"列表vs元组",'content':"列表vs元组 列表 一、创建列表 1.创建空的列表 列表 = [] 2.创建包含元素的列表 列表 = [元素1, 元素2, ..., 元素N] 二、列表元素的获取 1.通过索引获取元素 元素 = 列表[索引] 2.通过元素获取索引 索引 = 列表.index(元素) 3.查看元素是否存在于列表中 布尔值 = 元素 in 列表 4.统计元素在列表中的个数 个数 = 列表.count(元素) 三、列表元素的添加 1.向列表末尾追加元素 列表.append(元素) 2.向列表的任意位置插入元素 列表.insert(索引, 元素) 3.列表末尾追加另一个列表的所有元素 列表.extend(另一列表) 四、列表元素的删除 1.按索引删除元素 元素 = 列表.pop(索引) 2.按索引删除元素（del方法) del 列表[索引] 3.直接删除元素 列表.remove(元素) 4.清空所有元素 列表.clear() 五、列表元素的修改 1.通过赋值修改列表元素 列表[索引] = 新元素 2.反转整个列表 列表.reverse() 3.列表元素排序 列表.sort() 元组 元组和列表非常相似，也是用于存放元素的有序序列。它用的圆括号（()）表示，元素写入圆括号中，多个元素时用逗号分隔，如 (1, 2, 3)。\n元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素。所以它与列表相比，只能查找元素，也就是说只具备读的功能，不具备写的功能。元组的这一特性叫作不可变（性）（Immutable），而列表是可变的（Mutable）。\n一、创建元组 1.创建空的元组 元组 = () 2.创建包含多个元素的元组 元组 = (元素1, 元素2, ..., 元素N) 3.创建只包含一个元素的元组 元组 = (元素,) 二、元组元素的获取 1.通过索引获取元素 元素 = 元组[索引] 2.通过元素获取索引 索引 = 元组.index(元素) 3.查看元素是否存在于元组中 布尔值 = 元素 in 元组 4.统计元素在元组中出现的个数 个数 = 元组.count(元素) 元组和列表的差别  元组是不可变的（Immutable），列表是可变的（Mutable），元组在被创建之后，就不能添加、删除和修改元素，而列表可以 一般情况下元组的性能在略高于列表  "});index.add({'id':55,'href':'/docs/go/%E5%AE%89%E8%A3%85%E7%AF%87/%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/','title':"国内镜像配置",'content':"国内镜像配置 Go 1.13及以上(推荐) 打开你的终端并执行: go env -w GOPROXY=https://goproxy.cn,direct  Go module 打开你的终端并执行: go env -w GO111MODULE=on  go imports go imports包的引入可以让代码书写变得更加快捷 $ go get -v golang.org/x/tools/cmd/goimports  "});index.add({'id':56,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/','title':"并行、并发与分布式计算",'content':"ddd\n"});index.add({'id':57,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AF%86%E7%AC%A620%E4%B8%AA/','title':"类型标识符(20个)",'content':"类型标识符(20个) 数值（16个） 整型（12个） byte\nint\nint8 int16 int32 int64\nuint unint8 uint16 uint32 uint64\nuintprt\n浮点型（2个） float32\nfloat64\n复数型（2个） complex64\ncomplex128\n字符和字符串型（ 2 个） string rune\n接口型（1个） error\n布尔型（1个） bool\n"});index.add({'id':58,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/','title':"网络配置",'content':"网络配置 配置IP地址 1. ifconfig命令临时配置ip地址 ifconfig命令: 查看与配置网络状态命令\n#临时设置eth0网卡的IP地址与子网掩码 ifconfig eth0 192.168.0.200 netmask 255.255.255.0\n2. setup工具永久配置IP地址(rethat专有) 3. 修改网络配置文件  网卡信息文件  vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 //网卡设备名 BOOTPROTO=none //是否自动获取IP(none、static、dhcp) HWADDR=00:0c:29:17:c4:09 //MAC地址 NM_CONTROLLED=yes //是否可以由network manager图形管理工具托管 ONBOOT=yes //是否随网络服务启动, eth0生效 TYPE=Ethernet //类型为以太网 UUID=\u0026quot;xxsfwafewfw\u0026quot; //唯一识别码 IPADDR=192.168.0.252 //IP地址 NETMASK=255.255.255.0 //子网掩码 GATEWAY=192.168.0.1 //网关 DNS1=202.106.0.20 //DNS IPV6INIT=no //IPv6没有启用 USERCTL=no //不允许非root用户控制此网卡  主机名文件  vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=localhost.localdomain # 查看与临时设置主机名命令 [root@localhost ~]# hostname imooc  DNS配置文件  vi /etc/resolv.conf nameserver 202.106.0.20 search localhost 4. 图形界面配置IP地址 5. 修改uuid 1） vi /etc/sysconfig/network-scripts/ifcfg-eth0\n删除MAC地址行\n2) rm -rf /etc/udev/rules.d/70-persistent-net.rules\n# 删除网卡和mac地址绑定文件\n3) 重启系统\n5. 设置虚拟机网络连接方式  桥接\n虚拟机和真实机之间通讯使用的是真实网卡，配置简单，和真实机配置同一个网段，当成局域网真实的计算机 NAT\n虚拟机和真实机之间通讯使用的是vm-nat8虚拟网卡，只能和主机通讯，利用主机上网 Host-only\n虚拟机和真实机之间通讯使用的是vm-nat1虚拟网卡，只能和主机通讯，不能上网  6. 修改桥接网卡 打开虚拟网络编辑器，选择已桥接到的网卡\n"});index.add({'id':59,'href':'/docs/datas_tructure/','title':"Datas Tructure",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':60,'href':'/docs/datas_tructure/%E6%A0%91/','title':"树",'content':"线 "});index.add({'id':61,'href':'/docs/go/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/','title':"运行时篇",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':62,'href':'/docs/linux/%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/','title':"端口进程",'content':"端口进程 "});index.add({'id':63,'href':'/docs/python/%E5%BA%93/','title':"库",'content':"库 标准库 其中常用的库有 datetime：日期和时间处理相关 random：随机取值相关 josn：json 相关 XML：XML 相关 collections：集合相关 base64：base64 编码相关 hashlib：摘要算法相关，如 MD5、SHA1 itertools：迭代工具相关 contextlib：上下文管理相关 urllib：HTTP 请求相关  标准库 https://docs.python.org/zh-cn/3.7/library/index.html  第三方包 https://pypi.org/ "});index.add({'id':64,'href':'/docs/shell/shell%E8%BF%90%E7%AE%97%E7%AC%A6/','title':"shell运算符",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':65,'href':'/docs/go/%E5%AE%89%E8%A3%85%E7%AF%87/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/','title':"依赖管理",'content':"依赖管理 依赖管理的三个阶段: GOPATH, GOVENDOR, go mod\nGOPATH 默认在~/go\ngo mod的使用 使用intelij Idea创建项目  打开Intelij Idea, File-\u0026gt;new-\u0026gt;project 选择Go MOdules(vgo), 将Proxy: 改为https://goproxy.cn,direct 打开ide的terminal输入go env查看GO111MODULE是否为on，和查看GOPROXY是否为: https://goproxy.cn,direct 继续在terminal输入: go get -u go.uber.org/zap  获取某个固定版本: go get -u go.uber.org/zap@1.11\n获取最新的版本: go get -u go.uber.org/zap\n清洁: go mod tidy\n增加依赖：\n1. go get\n2. 代码直接写, 点run的时候自动下载\ngo build ./...  迁移到go mod go mod init modtest2 go build ./... 增加依赖 go get  总结  由go命令统一的管理, 用户不必关心目录结构 初始化: go mode init [名称] 增加依赖: go get 或者 直接写代码,在build的时候把依赖加进去 更新依赖: go get [@v\u0026hellip;], go mod tidy # 不加@v表示拿最新版本 将旧项目迁移到go mod: go mod init, go build ./\u0026hellip;, 删掉vendor，glide.yaml等文件  目录的整理 把每一个包含main的文件，分别放在不同的目录里\ngo build ./\u0026hellip; #编译当前和所有下级目录中的main方法，不产生编译文件 go install ./\u0026hellip; # 产生编译文件， 在GOPATH的bin目录中\n"});index.add({'id':66,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/2.%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/','title':"如何把修改后的代码提交到远程仓库",'content':"如何把修改后的代码提交到远程仓库 同步远程代码 git pull\n检查改动文件 git status\n Untracked: 未跟踪,一般为新增文件，此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. deleted: 文件已删除，本地删除，服务器上还没有删除. renamed: 文件名称被改变  如果发现无意中编辑了某一个文件，但实际上并不想改变它，这里可以使用git checkout 文件名来撤销更改\ngit checkout README.md 添加文件到缓存 git add index.php #添加所有使用 git add .\n提交代码 git commit . -m “这是备注信息”\n推送代码 git push\n开发中的提交 git add test1.php test2.log\ngit commit #此刻会打开一个文件, 删除非提交的之后保存 git push origin branch/feature/1 #推送到指定分支\nnotice  git add -A更好。因为git add .不会提交删除操作 git add abc.py报错‘fatal: pathspec \u0026lsquo;phase1.py\u0026rsquo; did not match any files’， 应该是这个文件，在于.gitignore文件的忽略规则里，所以Git不让你动，你可以首先把这个文件从.gitignore文件里移除，然后将.gitigore文件提交(或者将文件提交)，再次去处理abc.py文件就正常了~ 建议在修改代码前先执行 git pull命令，避免在commit并且push时候提示远程的版本比本地新 如果出现远程比本地版本更新的情况下，直接执行git pull命令有可能会自动进行合并，也有可能出现代码冲突的问题； 同理如果出现远程比本地版本更新的情况下，执行 git rebase 命令在不出现代码冲突的情况下会拉去远程的版本到本地，并且把本地的修改放在拉去下来版本的后方，但如果有冲突同样需要解决冲突问题 在GitHub上新建版本库后，你可以得到一个仓库地址，这个时候回到本地Git仓库，然后将本地仓库和远程仓库进行关联，再执行推送即可：参考命令如下~ git remote add origin https://github.com/xxxxx/project_name.git git push -u origin master  "});index.add({'id':67,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E5%85%B8vs%E9%9B%86%E5%90%88/','title':"字典vs集合",'content':"字典vs集合 字典 字典是一种用来存放若干键值对的数据类型。\n一、创建字典 1.创建空的字典 字典 = {} 2.创建包含键值对的字典 字典 = {键1:值1, 键2:值2, ..., 键N:值N} 二、字典键值对的添加 1.向字典中增加键值对 字典[键] = 值 三、键值对的获取 1.通过键获取值 值 = 字典[键] 2.通过键获取值(get方法) 值 = 字典.get(键) 3.判断字典中是否包含某个键 布尔值 = 键 in 字典 4.获取所有键 键的列表 = 字典.keys() 5.获取所有值 值的列表 = 字典.values() 6.获取所有键值对的列表 值的列表 = 字典.items() 四、字典键值对的删除 1.通过键删除键值对 值 = 字典.pop(键) 2.通过键删除键值对（del 方法） del 字典[键] 3.随机删除一个键值对 键值二元组 = 字典.popitem() 4.清空所有键值对 键值二元组 = 字典.clear() 五、字典中键值对修改 1.修改键对应的值 字典[键] = 值 2.用字典批量更新键值对 字典.update(另一字典) 六、什么时候用字典 字典的显著优势是可以通过键快速地查询数据。字典中的元素以键值对的形式存在，使用时通过键来获取和修改值，由于字典内部的特殊实现，字典通过键获取值的效率非常高。\n集合 集合是一个用于存放批量元素的数据类型，它不是有序的，其中的元素没有顺序关系。集合中的元素没有重复，重复的元素将被自动剔除最终只留下一个。\n一、创建集合 1.创建包含元素的集合 集合 = {元素1, 元素2, 元素N} 2.创建空集合 集合 = set() 二、集合元素的添加 1.向集合中添加一个元素 集合.add(元素) 2.从另一集合中批量添加元素 集合.update(另一集合) 三、集合元素的获取 1.查看元素是否存在于集合中 布尔值 = 元素 in 集合 四、集合元素的删除 1.随机删除一个元素，并返回这个元素 元素 = 集合.pop() 2.删除一个指定的元素 集合.remove(元素) 3.删除一个指定的元素，且不抛出 KeyError 异常 集合.discard(元素) 4.清空所有元素 集合.clear() 五、集合的运算 1.求交集 交集 = 集合1.intersection(集合2, 集合3, 集合N) 或 交集 = 集合1 \u0026amp; 集合2 \u0026amp; 集合N 2.求并集 并集 = 集合1.union(集合2, 集合3, 集合N) 3.求差集 差集 = 集合1.difference(集合2, 集合3, 集合N) 4.判断是否为子集 布尔值 = 集合1.issubset(集合2) 5.判断是否为超集 布尔值 = 集合1.issuperset(集合2) 六、什么时候用集合 集合非常重要的一个特性是元素无重复，每个元素都是唯一的，重复的元素将被自动剔除（去重）。\n获取字典和集合中的元素数量 使用len函数\n"});index.add({'id':68,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/%E5%B8%B8%E9%87%8F%E5%80%BC%E6%A0%87%E8%AF%86%E7%AC%A64%E4%B8%AA/','title':"常量值标识符(4个)",'content':"常量值标识符(4个) true false //true 和 false 表示 bool 类型的两常量值 iota //用在连续的枚举类型的声明中 nil //指针／引用型的变量的默认值就是 nil\n"});index.add({'id':69,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/','title':"数据类型",'content':"#数据类型\n一、基本数据类型 Go 语言内置七类基本数据类型\n1.布尔类型  True False //不初始化默认为false  2.整型 byte int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr  3.浮点型 float32 float64  4.复数 complex64 complex128 // real返回复数的实部, image返回复数的虚部  5.字符 rune //rune是uint类型的别名  6.字符串: string 赋值: a := \u0026quot;hello\u0026quot; a := \u0026quot;hello world\u0026quot; b := []byte(a) c := []rune(a) b和c的结果都是:[104 101 108 108 111 44 32 119 111 114 108 100]  7.错误类型: error 8.注意 Go内置两种字符类型: 一种是byte的字节类类型(byte是unit的别名), 另一种是表示unicode编码的字符rune. rune在go内部是int32类型的别名,占用4个字节.  二、复合数据类型 复合数据类型就是由其他类型组合而成的类型.\n1.指针 *pointerType //指针类型使用*后面跟其指向的类型名 *T声明指针 **T 声明多级指针 *T 出现在\u0026quot;=\u0026quot; 左边表示指针声明, 右边表示取指针指向的值 结构体指针访问结构体字段仍然使用\u0026quot;.\u0026quot;点操作符,Go语言没有\u0026quot;-\u0026gt;\u0026quot;操作符 Go不支持指针的运算 函数中允许返回局部变量的地址  2.数组 [n]elementType //数组类型使用[n]后面跟数据元素类型来表示 var arr [2]int 数组初始化: a := [3]int{1,2,3} a := [...]int{1,2,3} a := [3]int{1:1, 2:3} // 指定总长度,并通过索引值进行初始化,没有初始化元素时使用类型默认值 a := [...]int{1:1, 2:3} //不指定总长度,通过索引值进行初始化,数组长度由最后一个索引值确定，没有指定索引的元素被初始化为类型的零值 数组的特点: 1. 数组创建完长度就固定了,不可以再追加元素 2. 数组是值类型的,数组复制或作为函数参数都是值拷贝 数组相关操作: 1. 数组元素的访问 b := a[0] for i, v := range a { } 2. 数据的长度 len()  3.切片 Go 为切片维护三个元素一一指向底层数组的指针、切片的元素数量和底层数组的容量 []elementType //切片类型使用[]后面跟切片元素类型来表示 切片的相关操作 1. 切片的创建 var array = [...]int{0,1,2,3,4,5,6,7} s1 := array[0:4] a := make([]int, 10) 或 a := make([]int, 10, 15) 2.切片支持的操作 内置函数len()返回切片长度 内置函数cap()返回切片底层数组容量 内置函数append()对切片追加元素 内置函数copy()用于复制一个切片 3.字符串和切片的相互转换 str := \u0026quot;hello,世界\u0026quot; a := []byte(str) // 将字符串转换为[]byte类型切片 b := []rune(str) // 将字符串转换为[]rune类型切片  4.字典 Go语言内置的字典类型叫map.map的类型格式是: map[K]T, 其中K可以是任意可进行比较的类型,T是值类型. map[keyType]valueType //map类型使用map[键类型]值类型来表示 字典的相关操作 1.map的创建 ma :=map[string]int{\u0026quot;a\u0026quot;:1, \u0026quot;b\u0026quot;:2} make(map[K]T) 或者 make(map[K]T, len) 2.map支持的操作 map的单个键值访问方式是: mapName[key] 可以使用range遍历一个map类型变量,但是不保证每次迭代元素的顺序 for k, v := range mp { fmt.Println(\u0026quot;key=\u0026quot;, k, \u0026quot;value=\u0026quot;, v) } 删除map中的某个键值,使用如下语法:delete(mapName, key) 可以使用内置的len()函数返回map中的键值对数量 注意: Go内置的map不是并发安全的,并发安全的map可以使用标准包sync中的map。 不要直接修改map value内某个元素的值, 如果想修改map的某个键值,则必须整体复制。 type User struct { name string age int } ma := make(map[int]User) andes := User{ name: \u0026quot;andes\u0026quot;, age: 18, } ma[1] = andes ma[1].age = 19 //Error 不能通过map引用直接修改andes.age=19 andes.age = 19 ma[1] = andes //必须整体替换value  5.通道 chan valueType //通道使用chan后面跟通道元素类型来表示  6.结构和接口  struct { feildType feildType feildType feildType ... } // 结构类型使用struct{} 将各个结构字段扩起来表示 struct类型字面量 struct { FeildName FeildType FeildName FeildType FeildName FeildType } 自定义struct类型 type TypeName struct { FeildName FeildType FeildName FeildType FeildName FeildType } struct类型变量的初始化 type Persion struct { Name string Age int } type Student struct { *Persion Number int } // 按照类型声明顺序,逐个赋值 a := Persion{\u0026quot;Tom\u0026quot;, 21} //不推荐这种初始化方式 // 推荐下面这种赋值方式 p := \u0026amp;Persion { Name: \u0026quot;tata\u0026quot;, Age: 12 } s := Strudent { Persion: p, Number: 110, } "});index.add({'id':70,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/','title':"网络命令",'content':"网络命令 网络环境查看命令 1. ifconfig 查看与配置网络状态命令\n2. 关闭与启动网卡 ifdown 网卡设备名 # 禁用该网卡设备\nifup 网卡设备名 # 启用该网卡设备\n3. 查询网络状态 netstat 选项:\n-t 列出TCP协议端口\n-u 列出UDP协议端口\n-n 不适用域名与服务名, 而使用IP地址和端口号\n-l 仅列出在监听状态网络服务\n-a 列出所有的网络连接\n4. route命令 route -n # 查看路由列表(可以看到网关)\nroute add default gw 192.168.1.1 # 临时设定网关\n在一台服务器里, 连内网的网卡是不能设置网关的\n5. 域名解析命令 nslookup [主机名或IP] # 进行域名或IP地址解析\nnslookup # 查看本机DNS服务器\n网络测试命令 1. ping 命令 ping -c 10 192.168.1.1 # ping 10次\n2. telnet 命令 telnet [域名或IP] 【端口】# 远程管理与端口探测命令(明文传输)\n3. traceroute traceroute [选项] IP或域名 #路由跟踪命令\n选项:\n-n 使用IP，不使用域名,速度更快\n4. wget 命令 5. tcpdump tcpdump -i eth0 -nnX port 21\n选项:\n-i 指定网卡接口\n-nn 将数据包中的域名和服务转为IP和端口\n-X 以十六进制和ASCII码显示数据包内容\nport 指定监听的端口\n"});index.add({'id':71,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/','title':"逃逸分析",'content':"逃逸分析 例子 /* * 闭包引用了x变量, a,b可以看做2个不同的实例,实例之间互不影响,实例内部,x变量是同一个地址,因此具有\u0026quot;累加效应\u0026quot; */ package main import \u0026quot;fmt\u0026quot; func main() { var a = acc() fmt.Printf(\u0026quot;%d\\n\u0026quot;, a(1)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, a(10)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, a(100)) fmt.Println(\u0026quot;-------------------\u0026quot;) var b = acc() fmt.Printf(\u0026quot;%d\\n\u0026quot;, b(1)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, b(10)) fmt.Printf(\u0026quot;%d\\n\u0026quot;, b(100)) } func acc() func(int) int { var x int return func(delta int) int { fmt.Printf(\u0026quot;%+v, %+v\u0026quot;, \u0026amp;x, x) x += delta return x } } 结果: 0xc000016070, 01 0xc000016070, 111 0xc000016070, 11111 ------------------- 0xc0000160b0, 01 0xc0000160b0, 111 0xc0000160b0, 11111 "});index.add({'id':72,'href':'/docs/datas_tructure/%E5%9B%BE/','title':"图",'content':"线 "});index.add({'id':73,'href':'/docs/go/%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AF%87/','title':"工具链篇",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':74,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/3.%E4%BD%BF%E7%94%A8diff%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81/','title':"使用diff查看修改了哪些代码",'content':"使用diff查看修改了哪些代码 名词定义 工作区 工作区，指的是当前正在编辑的文件，将还没有修改的内容通过git add命令暂存起来\n暂存区 暂存区，指的是文件修改之后并且通过git add命令临时存储到版本记录里了，但还没有正式通过git commit提交的阶段\n比较改动 git diff [文件]\n与指定记录比较 你可以先通过git log命令，找到历史提交记录的一个 hash 值。 将要比较的 hash 值复制下来，然后执行如下所示命令：git diff hash值\n与最新版本比较 git diff HEAD\n比较两个历史记录 git diff hash值1 hash值2\n查看暂存区的额外参数 \u0026ndash;cached "});index.add({'id':75,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/','title':"控制结构",'content':"控制结构 1.if语句 if err, file := os.Open(\u0026quot;xxx\u0026quot;); err == nil { //do smoething } else { return nil, err } if score \u0026gt;= 90 { } else if score \u0026gt;= 80 { } else { }  2.switch语句 switch 语句会根据传入的参数检测并执行符合条件的分支. switch 的语法特点如下: switch 和 if 语句一样, switch后面可以带一个可选的简单的初始化语句 switch 后面的表达式也是可选的, 如果没有表达式, 则case子句是一个布尔表达式. 而不是一个值, 此时就相当于多重if else语句 switch 条件表达式的值不像c语言那样必须限制为整数, 可以是任意支持相等比较运算的类型变量 通过fallthough语句来强制执行下一个case子句(不再判断下一个case子句的条件是否满足) switch支持default语句, 当所有的case分支都不符合时,执行default语句,并且default语句可以放到任意位置,并不影响switch的逻辑判断 swith和.(type)结合可以进行类型的查询， （//todo::） switch i := \u0026quot;y\u0026quot;; i { //switch后面可以带上一个初始化语句 case \u0026quot;y\u0026quot;, \u0026quot;Y\u0026quot;: //多个case值使用逗号分隔 fmt.Println(\u0026quot;yes\u0026quot;) fallthrough //fallthrough会跳过接下来的case条件， // 直接执行下一个case语句 case \u0026quot;n\u0026quot;, \u0026quot;N\u0026quot;: fmt.Println(\u0026quot;no\u0026quot;) } switch { case score \u0026gt;= 90: grade = \u0026quot;A\u0026quot; case score \u0026gt;= 80: grade = \u0026quot;B\u0026quot; default: grade = \u0026quot;F\u0026quot; }  3.for语句 Go 语言仅支持一种循环语句,即for语句 for init; condition; post {} //类似c里面的for循环语句 for condition {} // 类似c里面的while循环语句 for {} // 类似c里面的while(1)死循环语句 // 访问map for key, value := range map {} for key := range map{} // 访问数据 for index, value := range array {} for index := range array {} for _, value := range array{} // 访问切片 for index, value := range slice {} for index := range slice {} for _, value := range slice{} // 访问通道 for value := range channel {}  4.标签和跳转 Go 语言使用标签(Lable)来标识一个语句的位置, 用于goto, break, continue语句的跳转， 标签的语法是: Lable: Statement 标签的具体作用和使用见下面的goto、break、continue goto goto 语句用于函数的内部的跳转，需要配合标签一起使用，具体的格式如下： goto Lable //goto Lable 的语义是跳转到标签名后的语句处执行， goto语句有以下几个特点: goto 语句只能在函数内跳转。 goto 语句不能跳过内部变量声明语句，这些变量在goto语句 的标签语句处又是可见的。 例如: goto L //BAD, 跳过了v := 3这条语句是不允许的 v := 3 L: goto语句只能跳到同级作用域或者上层作用域内，不能跳到内部作用域内。 例如 ： if n%2 == 1 { goto L1 } for n \u0026gt; 0 { f() n-- L1: f() n-- } break break 用于函数内跳出 for、 switch、 select 语句的执行，有两种使用格式： 单独使用，用于跳出 break 当前所在的 for、 switch、 select 语句的执行。 和标签一起使用，用于跳出标签所标识的 for、 switch、 select 语句的执行，可用于跳出多重循环，但标签和 break 必须在同一个函数内。 例如： L1: for i := 0; ; i++ { for j := 0; ; j++ { if i \u0026gt;= 5 { break L1 // 跳出L1标签所在的for循环 } if j \u0026gt; 10 { break // 默认仅跳出离break最近的内层循环 } } } continue continue 用于跳出 for 循环的本次选代，跳到 for 循环的下一次选代的 post 语句处执行，也有两种使用格式: 单独使用，用于跳出 continue 当前所在的 for 循环的本次迭代 。 和标签一起使用，用于跳出标签所标识的 for 语句的本次选代，但标签和 continue 必须 在同一个函数内。 例如 ： L1: for i := 0; ; i++ { for j := 0; ; j++ { if i \u0026gt;= 5 { continue L1 // 跳出L1标签所在处的for循环 } if j \u0026gt; 10 { continue // 继续下次循环 } } }  5.return和函数调用 re阳m i吾句也能引 发控制流程的跳转，用于函数和方法的退出。 函数和方法的调用也能引 发程序控制流的跳转，这些在后续章节中会详细介绍。 "});index.add({'id':76,'href':'/docs/shell/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/','title':"环境变量配置文件",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':77,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/%E7%A9%BA%E7%99%BD%E6%A0%87%E8%AF%86%E7%AC%A61%E4%B8%AA/','title':"空白标识符(1个)",'content':"空白标识符(1个) _ // 空白标识符有特殊的含义, 用来声明一个匿名的变量,该变量在赋值表达式的左端,空白标识符引用通常被用作占位\n"});index.add({'id':78,'href':'/docs/linux/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%B7%A5%E5%85%B7/','title':"远程登录工具",'content':"远程登录工具 SSH协议原理 对称加密算法: 采用单秘钥密码系统的加密方法\n ssh 用户名@ip scp [-r]  "});index.add({'id':79,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/','title':"迭代器和生成器",'content':"迭代器和生成器 迭代器 什么是迭代呢？在编程中，迭代指的是通过重复执行某个操作，不断获取被迭代对象中的数据。这样的每一次操作就是就是一次迭代。\n迭代器是具有迭代功能的对象。我们使用迭代器来进行迭代操作。\n迭代器 = iter(容器)\n\u0026gt;\u0026gt;\u0026gt; numbers=[1,2,3,4,5] \u0026gt;\u0026gt;\u0026gt; it = iter(numbers) \u0026gt;\u0026gt;\u0026gt; it \u0026lt;listiterator object at 0x1007e6950\u0026gt; \u0026gt;\u0026gt;\u0026gt; for 循环的迭代过程 for 循环的迭代就是通过使用迭代器来完成的。它在背后所做的事情是：\n 对一个容器调用 iter() 函数，获取到该容器的迭代器 每次循环时对迭代器调用 next() 函数，以获取一个值 若捕获到 StopIteration 异常则结束循环  可迭代（Iterable）对象 并不是所有的对象都可以被 iter() 函数使用。\n什么是可迭代(的)？\n1、从表面来看，所有可用于 for 循环的对象是可迭代的，如列表、元组、字符串、集合、字典等容器\n2、从深层来看，定义了 iter() 方法的类对象就是可迭代的。当这个类对象被 iter() 函数使用时，将返回一个迭代器对象。如果对象具有__iter__() 方法，则可以说它支持迭代协议。\n判断一个已有的对象是否是可迭代的 1、 \u0026lsquo;iter\u0026rsquo; in dir(list)\n2、 isinstance(对象, Iterable)\n自定义迭代器 class MyIterator: def __next__(self): 代码块 def __iter__(self): return self 生成器 刚才我们自定义了迭代器，其实创建迭代器还有另一种方式，就是使用生成器。\n生成器是一个函数，这个函数的特殊之处在于它的 return 语句被 yield 语句替代。\ndef power_of_two(): for exponent in range(11):\t# range(11) 表示左闭右开区间 [0, 11)，不包含 11 yield 2 ** exponent\t# 以 2 为底数求指数幂 生成器使用方法： p = power_of_two()\t# 以函数调用的方式创建生成器对象 next(p)\t# 同样使用 next() 来取值 生成器的关键在于 yield 语句。yield 语句的作用和 return 语句有几分相似，都可以将结果返回。不同在于，生成器函数执行至 yield 语句，返回结果的同时记录下函数内的状态，下次执行这个生成器函数，将从上次退出的位置（yield 的下一句代码）继续执行。当生成器函数中的所有代码被执行完毕时，自动抛出 StopIteration 异常。\n我们可以看到，生成器的用法和迭代器相似，都使用 next() 来进行迭代。这是因为生成器其实就是创建迭代器的便捷方法，生产器会在背后自动定义 iter() 和 next() 方法。\n生成器表达式（Generator Expression） 可以用一种非常简便的方式来创建生成器，就是通过生成器表达式。生成器的写法非常简单，但是灵活性也有限，所能表达的内容相对简单。\n生成器表达式的写法如下：\n生成器 = (针对项的操作 for 项 in 可迭代对象)\n\u0026gt;\u0026gt;\u0026gt; letters = (item for item in 'abc') \u0026gt;\u0026gt;\u0026gt; letters \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x1007d4960\u0026gt; \u0026gt;\u0026gt;\u0026gt; next(letters) 'a' \u0026gt;\u0026gt;\u0026gt; next(letters) 'b' \u0026gt;\u0026gt;\u0026gt; 列表生成式 [对项的操作 for 项 in 可迭代对象]\n"});index.add({'id':80,'href':'/docs/go/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/','title':"单元测试",'content':"单元测试  Go Test 单元测试简明教程 Go Mock (gomock)简明教程  "});index.add({'id':81,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B015%E4%B8%AA/','title':"内置函数(15个)",'content':"内置函数(15个) make new len cap append copy delete panic recover close complex real image Print Printin\n"});index.add({'id':82,'href':'/docs/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/','title':"帮助命令",'content':"帮助命令 帮助命令man man 命令 man的级别 1: 查看命令帮助 2: 查看可被内核调用的函数的帮助 3: 查看函数和函数库的帮助 4: 查看特殊文件的帮助(主要是/dev目录下的文件) 5: 查看配置文件的帮助 6: 查看游戏的帮助 7: 查看其他杂项的帮助 8: 查看系统管理员可用命令的帮助 9: 查看和内核相关文件的帮助 查看命令拥有哪个级别的帮助 man -f 命令 或者 whatis 命令 举例: man -5 passwd man -4 null man -8 ifconfig 查看和命令相关的所有帮助 man -k 命令 或者 apropos 命令 举例: man -k passwd  其他帮助命令 * 选项帮助: 命令 --help #获取命令选项的帮助 例如: ls --help * shell内部命令帮助 help shell内部命令 #获取shell内部命令的帮助 例如: whereis cd #确定是否是shell内部命令 只要找不到执行文件都是内部命令 help cd #获取内部命令帮助 * 详细命令帮助info - 回车: 进入子帮助页面(带有*号标记) - u: 进入上层页面 - n: 进入下一个帮助小节 - p: 进入上一个帮助小节 - q: 退出  "});index.add({'id':83,'href':'/docs/shell/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/','title':"正则表达式",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':84,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/','title':"生成器表达式和列表生成式",'content':"生成器表达式和列表生成式 列表生成式 nums = [2 ** i for i in range(1, 11)] 这行代码就是我们这个章节要所讲的列表生成式。顾名思义，列表生成式最终生成的是一个列表，它是用已有的可迭代对象来构造新列表的便捷方法。\n列表生成式的写法 列表生成式的语法如下： [对项的操作 for 项 in 可迭代对象]\n列表生成式中使用 if 在列表生成式的中，每次迭代的 项 是可以被筛选过滤的，使用 if 关键字。如： [对项的操作 for 项 in 可迭代对象 if 对项的判断]\n列表生成式中嵌套 for 列表生成式中的 for 中还可以再嵌套 for。如：[对项1和(或)项2的操作 for 项1 in 可迭代对象1 for 项2 in 可迭代对象2]\n字典生成式 便捷地构造列表可以使用列表生成式，同样的，想要通过已有的可迭代对象来便捷地构造字典，可以使用字典生成式。\n字典生成式的写法是：{键: 值 for 项 in 可迭代对象}\n集合生成式 你可能已经猜到了，只需要将列表生成式的方括号（[]）替换为花括号（{}）即可：{对项的操作 for 项 in 可迭代对象}\n生成器表达式 Python 中并没有「元组生成式」！虽然 Python 中确实有类似的圆括号的写法：(对项的操作 for 项 in 可迭代对象)\n但这可不是什么「元组生成式」，而是我们上一章节学习过的生成器表达式。\n生成器表达式是一种创建生成器的便捷方法。虽然写法上和列表生成式、字典生成式、集合生成式相似，却有着本质的不同，因为它创建出来的是生成器，而不是列表、字典、集合这类容器。 (char.lower() for char in \u0026lsquo;ABCDEF\u0026rsquo;)\n\u0026gt;\u0026gt;\u0026gt; g = (char.lower() for char in ‘ABCDEF’) \u0026gt;\u0026gt;\u0026gt; g \u0026lt;generator object at 0x103da6c78\u0026gt; \u0026gt;\u0026gt;\u0026gt; next(g) ‘a’ \u0026gt;\u0026gt;\u0026gt; next(g) ‘b’ 生成器表达式中同样可以使用 if 和嵌套 for，使用方法和列表生成式相同。\n"});index.add({'id':85,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/4.%E8%A7%A3%E5%86%B3%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A2%AB%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/','title':"解决提示文件权限被修改问题",'content':"解决提示文件权限被修改问题 当执行git diff 命令时出现:\ndiff --git a/index.php b/index.php old mode 100644 new mode 100755 表示文件权限被修改了， 这时候我们git pull拉取下代码,会提示文件冲突: 例如:\ngit pull eror: Your local changes to the following files would be overwritten by merge: index.php Please commit your changes or stash them before you merge. Aborting 解决方法 在Git进行代码管理时,如果不想让 Git 记录文件权限，可以通过 Git 配置让其忽略文件权限的信息，参考命令如下：\n#当前版本库 git config core.filemode false #所有版本库 git config --global core.fileMode false 当上面的命令被执行之后，就设置了忽略文件权限，此时通过cat查看配置文件.git/config，参考命令如下：\ncat .git/config 在配置文件中，如果看到fileMode false则代表配置成功.\n这时候再次使用git pull命令更新代码就不会再提示有冲突.\n"});index.add({'id':86,'href':'/docs/python/%E8%BF%9B%E9%98%B6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/','title':"函数进阶",'content':"函数进阶 位置参数 位置参数这个东西我们并不陌生，之前所编写的函数使用的就是位置参数。位置参数，顾名思义，传入函数时每个参数都是通过位置来作区分的。函数调用时，传入的值需按照位置与参数一一对应。\ndef overspeed_rate(current, max, min): if current \u0026gt; max: return (current - max) / max # 超过最大时速，结果为正 elif current \u0026lt; min: return (current - min) / min # 超过最小时速，结果为负 else: return 0 # 不超速，结果为 0 参数默认值 def 函数(参数1, 参数2=默认值): pass 关键字参数 我们还可以在函数调用时，以 参数名=值 的形式来向指定的参数传入值。\noverspeed_rate(100, min=80) 任意参数列表 定义函数时，在参数列表中使用 **参数名，可以接收一切关键字参数。类似的，参数列表中使用 *参数名，就可以接受任意数量的非关键字参数，也就是可变参数。 如，计算任意个数的乘积：\ndef multiply(*nums): result = 1 for n in nums: result *= n return result \u0026gt;\u0026gt;\u0026gt; multiply(1,3,5,7) 105 这个函数能接收任意个参数，这正是 *nums 所发挥的作用。函数所有接收到的非关键字参数组装成一个元组，并绑定到 nums 上。来试验一下：\n\u0026gt;\u0026gt;\u0026gt; def multiply(*nums): … print(nums) … \u0026gt;\u0026gt;\u0026gt; multiply(1, 2, 3, 4, 5) (1, 2, 3, 4, 5) 多返回值 典型情况下，函数只有一个返回值，但是 Python 也支持函数返回多个返回值。\n要返回多个返回值，只需在 return 关键字后跟多个值（依次用逗号分隔）。\ndef date(): import datetime d = datetime.date.today() return d.year, d.month, d.day "});index.add({'id':87,'href':'/docs/git/0.%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/5.%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/','title':"忽略指定文件或目录",'content':"忽略指定文件或目录 我们可以在在Git工作区的根目录下创建一个.gitignore文件，把想忽略的文件名或者目录填进去，Git 就会自动忽略这些文件。\nvi .gitignore .DS_Store .idea 常见问题   无法添加.gitignore windows系统会出现\n  添加忽略文件 .gitignore 文件支持通配符，当你在文件中添加一些忽略规则之后，可能匹配过于宽松，导致某一个文件无法提交到 git ;这个时候你有两种方式来处理，\n  或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：\n$ git check-ignore -v 文件名 .gitignore:1:.DS_Store .DS_Store Git 会告诉我们，.gitignore 的第 1 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。\n除了修改 .gitignore 文件的规则之外还可以使用强制添加的方式:\ngit add -f .DS_Store "});index.add({'id':88,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%A0%87%E8%AF%86%E7%AC%A6/%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%88%86%E9%9A%94%E7%AC%A647%E4%B8%AA/','title':"操作符和分隔符(47个)",'content':"操作符和分隔符(47个) 算术运算符(5个) ＋ － ＊ ／ %  位运算符(6个) \u0026amp; | \u0026lt; \u0026amp;^ \u0026gt;\u0026gt; \u0026lt;\u0026lt;  赋值和赋值复核运算符(13个) :＝ ＝ += -= *= /= %= \u0026amp;= |= ^= \u0026amp;^= \u0026gt;\u0026gt;= \u0026lt;\u0026lt;=  比较运算符(6个) \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= == !=  括号(6个) () {} []  逻辑运算符(3个) \u0026amp;\u0026amp; || !  自增自减操作符(2个) ++ -- //go语言里面自增、自减操作符是语句而不是表达式  其他运算符(6个) : , ; . ... \u0026lt;-  "});index.add({'id':89,'href':'/docs/shell/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/','title':"流量控制语句",'content':"shell基础 Buttons are styled links that can lead to local page or external link.\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':90,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%87%BD%E6%95%B0/','title':"函数",'content':"函数  函数是一种类型,函数类型变量可以像其他类型变量一样使用,可以作为其他函数的参数或返回值,也可以直接调用执行。 函数支持多值返回 支持闭包 函数支持可变参数  基本概念 函数定义 func funcName(param-list) (result-list) { function-body }  函数的特点 1、函数可以没有输入, 也可以没有返回值(默认返回0) 2、多个相邻的相同类型的参数可以使用简写模式: func add(a, b int) int { //a int, b int 简写为 a,b int return a + b } 3、支持有名的返回值,参数名就相当于函数体内最外层的局部变量，命名返回值变量会被初始化为类型零值， 最后的return可以不带参数名直接返回 func add(a, b int) (sum int) { sum = a + b return //return sum的简写模式 // sum := a + b // 如果是 sum:=a + b, 则相当于新声明一个sum变量命名返回变量sum覆盖 // return sum //最后需要显示的调用return sum } 4、不支持默认值参数 5、不支持函数重载 6、不支持函数嵌套，严格地说是不支持命名函数的嵌套定义，但支持嵌套匿名函数 func add(a, b int) (sum int) { anonymouse := function(x, y int) int { return x + y } return anonymouse(a, b) }  多值返回 func swap(a, b int) (int, int) { return b, a }  实参到形参的传递 package main import \u0026quot;fmt\u0026quot; func chvalue(a int) int { a = a + 1 return a } func chpointer(a *int) { *a = *a + 1 return } func main() { a := 10 chvalue(a) //实参传递给形参是值拷贝 fmt.Println(a) chpointer(\u0026amp;a) // 实参传递给形参仍然是值拷贝,只不过复制的是a的地址值 fmt.Println(a) }  不定参数 go 函数支持不定数目的形式参数, 不定参数声明使用param ...type的语法形式 函数的不定参数有如下几个特点: 1、所有的不定参数类型必须是相同的 2、不定参数必须是函数的最后一个参数 3、不定参数名在函数体内相当于切片，对切片的操作同同样适合对不定参数的操作: 例如: func sum(arr ...int) (sum int) { for _, v := range arr { //此时arr就相当于切片,可以使用range访问 sum += v } return } 4、切片可以作为参数传递给不定参数,切片名后要加上\u0026quot;...\u0026quot;。 例如: func sum(arr ...int) (sum int) { sum += v } func main() { slice := []int{1,2,3,4} array := [...]int{1,2,3,4} sum(slice...) } 5、形参不定参数的函数和形参为切片的函数类型不相同. 例如: func suma(arr ...int) (sum int) { for v := range arr { sum += v } return } func sumb(arr []int) (sum int) { for v := range arr { sum += v } return } // suma和sumb的类型并不一样 fmt.Printf(\u0026quot;%T\\n\u0026quot;, suma) //func(...int) fmt.Printf(\u0026quot;%T\\n\u0026quot;, sumb) //func([]int)  函数签名和匿名函数 函数签名 函数类型又叫函数签名,一个函数的类型就是函数定义首行去掉函数名,参数名和{, 可以使用fmt.Printf的%T 格式化参数打印函数的类型。 package main import \u0026quot;fmt\u0026quot; func add(a, b int) int { return a + b } func main() { fmt.Printf(\u0026quot;%T\\n\u0026quot;, add) // func(int, int) int } 两个函数类型相同的条件是: 拥有相同的形参列表和返回值列表(列表元素的次序、个数和类型都相同), 形参名可以不同。 以下2个函数的参数类型完全一样. func add(a, b int) int {return a + b} func sub(x int, y int) (c int) {c = x -y; return c} 可以使用type定义函数类型, 函数类型变量可以作为函数的参数或返回值. package main import \u0026quot;fmt\u0026quot; func add(a, b int) int { return a + b } func sub(a, b int) int { return a - b } type Op func(int, int) int // 定义一个函数类型,输入的是两个int类型,返回值是一个int类型 func do(f Op, a, b int) int { // 定义一个函数,第一个参数是函数类型Op return f(a, b)\t//函数类型变量可以直接用来进行函数调用 } func main() { a := do(add, 1, 2) // 函数名add可以当做相同函数类型形象,不需要强制类型转换 fmt.Println(a) // 3 s := do(sub, 1, 3) fmt.Println(s) // -1 } 函数类型和map, slice, chan一样, 实际函数类型变量和函数名都可以当做指针变量,该指针执行函数代码的 开始位置. 通常说函数类型变量是一种引用类型，未初始化的函数类型的变量默认值是nil Go中函数是\u0026quot;第一公民\u0026quot;, 有名函数的函数名可以看做函数类型的常量，可以直接使用函数名调用函数，也可以直接 赋值给函数类型变量, 后续通过该变量来调用该函数. package main func sum(a, b int) int { return a + b } func main() { sum(3, 4) // 直接调用 f := sum //有名函数可以直接赋值给变量 f(1, 3) }  匿名函数 package main import \u0026quot;fmt\u0026quot; // 匿名函数被直接复制函数变量 var sum = func(a, b int) int { return a + b } func doinput(f func(int, int) int, a, b int) int { return f(a, b) } // 匿名函数作为返回值 func wrap(op string) func(int, int) int { switch op { case \u0026quot;add\u0026quot;: return func(a, b int) int { return a + b } case \u0026quot;sub\u0026quot;: return func(a int, b int) int { return a - b } default: return nil } } func main() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() sum(1, 2) // 匿名函数作为实参 doinput(func(x int, y int) int { return x + y }, 1, 2) opFunc := wrap(\u0026quot;add\u0026quot;) re := opFunc(2, 3) fmt.Printf(\u0026quot;%d\\n\u0026quot;, re) }  defer defer关键字, 可以注册多个延迟调用 package main func main() { // 先进后出 defer func() { println(\u0026quot;firts\u0026quot;) }() defer func() { println(\u0026quot;second\u0026quot;) }() println(\u0026quot;function body\u0026quot;) } defer后面必须是函数或方法, 不能是语句。 defer函数的实参在注册时通过值拷贝传递进去. 主动调用os.Exit(int)退出进程时,defer将不再被执行(即使defer已经提前注册) package main import \u0026quot;os\u0026quot; func main() { defer func() { println(\u0026quot;defer\u0026quot;) //这种情况 不执行 }() println(\u0026quot;func body\u0026quot;) os.Exit(1) } defer的好处是可以在一定程度上避免资源泄露, 特定是在有很多return语句, 有多个资源需要关闭的场景中，很 容易漏掉资源的关闭操作. defer语句的位置不当, 有可能导致panic, 一般defer语句放在错误检查语句之后 defer也有明显的副作用; defer会推迟资源的释放，defer尽量不要放到循环语句里面, 将大函数内部的defer 语句单独拆分成一个小函数是一种很好的实践方式. 另外，defer相当于普通的函数调用需要间接的数据结构的支持。 相对于普通函数调用有一定的性能耗损。 defer中最好不要对有名返回值参数进行操作，否则会引发匪夷所思的结果  闭包 闭包是由函数及其相关引用环境组合而成的实体, 一般通过在匿名函数中引用外部函数的局部变量或包全局变量构成。 闭包 = 函数 + 引用环境 闭包对闭包外的环境引入是直接引用,编译器检测到闭包，会将闭包引用的外部变量分配到堆上。 如果函数返回的闭包引用了该函数的局部变量(参数或函数内部变量) (1) 多次调用该函数，返回的多个闭包所引用的外部变量是多个副本，原因是每个调用函数都会为局部变量分配内存。 (2) 用一个闭包函数多次, 如果该闭包修改了其引用的外部变量。则每一次调用该闭包对该外部变量都有影响，因为闭包函数共享外部引用。 package main func fa(a int) func(i int) int { return func(i int) int { println(\u0026amp;a, a) a = a + i return a } } func main() { f := fa(1) // f引用的外部的闭包环境包括本次函数调用的形参a的值1 g := fa(1) //g引用的外部的闭包环境包括本次函数调用的形参a的值1 println(f(1)) //多次调用f引用的是同一个副本a println(f(1)) // g中a的值仍然是1 println(g(1)) println(g(1)) } f和g引用的是不同的a 如果一个函数调用返回的闭包引用修改了全局变量,则每次调用都会影响全局变量。 如果函数返回的闭包引用的是全局变量a, 则多次调用该函数返回的多个闭包引用的都是同一个a。同理,调用一个闭包 多次引用的也是同一个a。此时如果闭包中修改了a值的逻辑,则每次闭包调用都会影响全局变量a的值。 使用闭包是为了减少全局变量,所以闭包引用全局变量不是好的编程方式。  "});index.add({'id':91,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%8E%A5%E5%8F%A3/','title':"接口",'content':"接口 语法 type Traversal interface { Traverse() }  duck typing 定义 使用者-\u0026gt;实现者\n接口由使用者定义\n接口的实现: 接口的实现是隐式的\n只要实现接口里的方法\n接口的值类型 fmt.printf(\u0026quot;%T, %v\u0026quot;, 接口变量, 接口变量) #打印接口类型和值 // r.(type) r的类型 switch v := r.(type) { case mock.Retriever: case *real.Retrieve: } // type assertion r.(*real.Retruever) 或 r, ok := r.(mock.Retruever) if ok != nil { fmt.Printf(\u0026quot;Err: %s\u0026quot;, ok) } 接口变量里面有什么: * 接口变量自带指针 * 接口变量同样采用值传递, 几乎不需要使用接口的指针 * 指针接收者实现只能以指针方式使用； 值接收者都可以  接口的组合 // 把Retriever和poster接口组合成一个接口 type RetrieverPoster interface { Retriever Poster }  常用接口 string reader writer  "});index.add({'id':92,'href':'/docs/go/%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B9%B6%E5%8F%91/','title':"并发",'content':"并发 进程、线程、协程   进程:\n 进程是什么? 一种系统运行行动 进程的定位是什么? 程序的执行实体 进程长什么样子? 在terminal中查看 进程怎么使用? [一般情况]一个程序一个进程, [多进程]一个程序多个进程    线程:\n 线程是什么? 运算调度的最小单元 线程的作用是什么? 同时运算多个任务 和进程有什么区别? 大哥和小弟的关系 线程内存大小?\n怎么\u0026quot;切\u0026rdquo;? 内核控制\n\u0026ldquo;切多大\u0026rdquo;? 缓存+内核控制\n\u0026ldquo;等长吗\u0026rdquo;? 不等长 线程观摩  回到我们的terminal 输入命令ps -M [pid] 查看对应pid的线程      协程\n 协程(Coroutine)是什么? 轻量级的线程 协程的定位是什么? 用户控制的函数 有什么样的优势? 协程优势  协程的内存消耗更小  一个线程可以包含多个协程 线程大约8MB的内存申请量 协程大概2kb的内存申请量   上下文切换更快  协程少一道手续 线程申请内存, 需要走过内核 协程申请内存，不需要走过内核        灵魂Goroutine\n Goroutine是什么? 一种协程(Coroutine) Goroutine和协程有怎样的关系? 一种优化 为什么使用Goroutine?  去掉了冗余的协程声明周期管理  协程创建 协程完成 协程重用   降低额外的延迟和开销  由于协程简频繁交互导致的   降低加锁/解锁的频率 a. 降低一部分额外的开销   Goroutine如何使用    多协程的核心机理 什么是多协程?  官方定义: 一段时间内协程的并行 实际应用: 某个任务使用多个协程同时进行处理  多协程的相对性  同时处理非同一道菜的食材 不算多协程 同时处理同一道菜的食材 算多协程 同时处理同一道菜的同一种食材 算多协程  多协程的使用场景  运算比较多的流程上 协程间依赖性比较弱  channel阻塞 阻塞条件:\n输入channel的数据量不等于channel能接受的量\nchannel阻塞的严重后果 程序位置: 非主流程 channel下游获取不到结果， 造成数据丢失\n程序位置: 主流课 主流程卡带，整个程序沉睡，股中昂级别P0级别\nchannel解决办法 设定channel缓冲:\nmake(chan int, 10) 10=channel的大小,即可以放多少个元素 channel的大小如何设定: 一般根据业务场景需求来\n如何利用channel阻塞 实现资源争抢\n实现多协程锁, 变相的\u0026quot;锁\u0026rdquo;\n实现消息定额消费\n"});index.add({'id':93,'href':'/docs/chart/','title':"Chart",'content':"图 "});index.add({'id':94,'href':'/docs/git/','title':"git",'content':"Git 目录 "});index.add({'id':95,'href':'/docs/linux/','title':"Linux",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':96,'href':'/docs/nginx/','title':"Nginx",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':97,'href':'/docs/shell/','title':"Shell",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':98,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/','title':"架构师",'content':"架构师 "});index.add({'id':99,'href':'/docs/go/git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6/','title':"Git移除已经add的文件",'content':"git 移除已经add的文件 使用 git rm 命令即可，有两种选择,  一种是 git rm \u0026ndash;cached “文件路径”，不删除物理文件，仅将该文件从缓存中删除； 一种是 git rm \u0026ndash;f “文件路径”，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。  请问 git rm \u0026ndash;cache 和 git reset HEAD 的区别到底在哪里呢？ 如果要删除文件，最好用 git rm file_name，而不应该直接在工作区直接 rm file_name。\n如果一个文件已经add到暂存区，还没有 commit，此时如果不想要这个文件了 有两种方法：\n 1，用版本库内容清空暂存区，git reset HEAD 但要慎重使用 2，只把特定文件从暂存区删除，git rm \u0026ndash;cached xxx  "});index.add({'id':100,'href':'/docs/go/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E4%B8%8D%E8%83%BD%E5%8F%96%E5%9C%B0%E5%9D%80/','title':"不能取地址",'content':"cannot take address of temporary variables\n"});index.add({'id':101,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/yum/','title':"Yum",'content':""});index.add({'id':102,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E6%BA%90%E7%A0%81%E5%8C%85%E7%AE%A1%E7%90%86/','title':"源码包管理",'content':""});index.add({'id':103,'href':'/docs/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85/','title':"脚本安装包",'content':""});index.add({'id':104,'href':'/docs/rust/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/1.helloworld/','title':"1.helloworld",'content':""});index.add({'id':105,'href':'/docs/%E6%9E%B6%E6%9E%84%E5%B8%88/restapi%E8%A7%84%E8%8C%83/','title':"Restapi规范",'content':"restapi规范 规范 URI 设计原则  资源必须使用复数名词表示集合，如果该词语没有合适的复数形式，则应该使用单数形式  例如： GET /employees GET /weather 必须使用正斜杠（/）表示层次关系 正斜杠（/）字符用于URI的路径部分，以指示资源之间的层次关系。 例如： GET /employees/56   不应该在URI中使用尾部正斜杠（/）\n  应该使用连字符（ - ）来提高URI的可读性，不应该使用下划线（ _ ）\n  必须在URI中使用小写字母\n  资源包含父子嵌套关系必须遵循以下原则\n  如果该资源脱离父资源后没有意义，则如下设计，例如：文件的某行与文件的关系 GET /file/1000/line/20 如果该资源可以独立访问或可以从属于多个父资源，则不用嵌套显示， 例如：专辑和歌曲的关系 GET /albums/151 GET /songs/10 版本控制 由于一个API服务可以提供多个API接口，如果有不兼容和破坏性的更改，版本号将让你能更容易的发布API。版本控制格式约定为：vN（N=1,2,3\u0026hellip;）\n例如: GET /api/v1/employees/123 GET /api/v2/employees/123 资源操作 HTTP方法 资源操作必须尽可能使用正确的HTTP方法，并且必须遵守操作幂等性。HTTP方法通常被称为HTTP动词。\n   方法 安全 幂等     GET 是 是   POST 否 否   PUT 否 是   DELETE 否 是   PATCH 否 否   OPTIONS 是 是   HEAD 是 是    关于以上方法的说明：\n GET 用于从服务器获取某个资源的信息  完成请求后返回状态码 200 OK 完成请求后需要返回被请求的资源详细信息   POST 用于创建新资源  创建完成后返回状态码 201 Created 完成请求后需要返回被创建的资源详细信息   PUT 用于完整的替换资源，比如修改 id 为 123 的某个资源  如果是替换了资源，则返回 200 OK 完成请求后需要返回被修改的资源详细信息   PATCH 用于局部更新资源  完成请求后返回状态码 200 OK 完成请求后需要返回被修改的资源详细信息   DELETE 用于删除某个资源  完成请求后返回状态码 204 No Content   OPTIONS 用于获取资源支持的所有 HTTP 方法 HEAD 用于只获取请求某个资源返回的头信息  自定义动词 实际业务场景中，对资源对象的控制，如升级、上传、移动等操作，用以上规范约束并不能保证API语义的唯一性、可理解性、易用性，因此，允许使用自定义动词去显示表达API的语义，统一格式为：\n/{prefix}/{version}/{resources}:{action} 动词命名请参照自定义动词命名规范 例如，文件导入导出：\n/v1/some/resource:import /v1/some/resource:export 除此之外，撤销操作则使用cancel关键字与该动词用英文连字符-相连。\n例如，停止导入：\n/v1/some/resource/name:import-cancel 请求约束 请求约束  GET, DELETE, HEAD 方法，参数风格必须为标准的 GET 风格的参数，如 ?a=1\u0026amp;b=2 POST, PUT, PATCH, OPTIONS 方法 默认情况下请求实体会被视作标准 json 字符串进行处理，应该设置头信息的 Content-Type 为 application/json，在一些特殊接口中，可以允许 Content-Type 为 application/x-www-form-urlencoded 或者 multipart/form-data ，此时请求实体会被视作标准 POST 风格的参数进行处理 在特殊场景下，例如查询参数长度超过浏览器限制、不允许使用DELETE方法等，可以使用POST方法代替 使用过滤查询时，基本查询和高级查询必须不能同时使用  参数命名  参数定义必须使用 lower_case_underscore_separated_names 格式 参数名称必须是英文或英文和数字的组合 参数名称不应该包含介词（例如for、during、at）  reason_for_error 应该改成 error_reason cpu_usage_at_time_of_failure 应该改成 failure_time_cpu_usage  参数名称不应该使用后置形容词（名词后面的修饰符  例如： items_collected 应该改成 collected_items objects_imported 应该改成 imported_objects 响应约束 响应约束 客户端请求头如果没有提供Accept，默认的响应结果格式应该是application/json，否则应该使用请求头中Accept指定的格式响应。\n响应结果必须使用HTTP标准响应码\n 成功，响应数据为资源本身的描述 失败，响应数据为错误描述，且必须包含error对象 响应示例  调用成功 HTTP/1.1 200 OK Content-Type: application/json { \u0026quot;total\u0026quot;: 910, \u0026quot;items\u0026quot;:[{}, {} ...] } 调用失败，详见错误示例\n错误 如果是一个不支持的请求或者请求失败，服务必须提供一个错误响应结果，这个错误响应结果必须是一个标准的HTTP 错误码。\n响应示例 错误响应信息必须使用 error 字段，例如： 数据类型 安全 特殊场景 分页 过滤 排序 跨域 "});index.add({'id':106,'href':'/posts/','title':"Posts",'content':""});index.add({'id':107,'href':'/docs/','title':"Docs",'content':""});index.add({'id':108,'href':'/docs/go/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AF%87/%E5%A0%86%E6%A0%88/','title':"堆栈",'content':"堆栈 "});})();